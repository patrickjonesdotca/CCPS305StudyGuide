<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Spreadsort - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Spreadsort_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 2 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Spreadsort">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Spreadsort_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Spreadsort_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Spreadsort_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Spreadsort" selected="selected">English</option><option value="//fa.m.wikipedia.org/wiki/%D9%85%D8%B1%D8%AA%D8%A8_%D8%B3%D8%A7%D8%B2%DB%8C_%DA%AF%D8%B3%D8%AA%D8%B1%D8%AF%D9%87">فارسی</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Spreadsort</h1>			
<p><b>Spreadsort</b> is a <a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a> invented by Steven J. Ross in 2002.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup> It combines concepts from distribution-based sorts, such as <a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">radix sort</a> and <a href="http://en.m.wikipedia.org/wiki/Bucket_sort" title="Bucket sort">bucket sort</a>, with partitioning concepts from comparison sorts such as <a href="http://en.m.wikipedia.org/wiki/Quicksort" title="Quicksort">quicksort</a> and <a href="http://en.m.wikipedia.org/wiki/Mergesort" title="Mergesort" class="mw-redirect">mergesort</a>.
 In experimental results it was shown to be highly efficient, often 
outperforming traditional algorithms such as quicksort, particularly on 
distributions exhibiting structure.</p>
<p>Quicksort identifies a <i>pivot element</i> in the list and then 
partitions the list into two sublists, those elements less than the 
pivot and those greater than the pivot. Spreadsort generalizes this idea
 by partitioning the list into <i>n</i>/<i>c</i> partitions at each step, where <i>n</i> is the total number of elements in the list and <i>c</i>
 is a small constant (in practice usually between 4 and 8 when 
comparisons are slow, or much larger in situations where they are fast).
 It uses distribution-based techniques to accomplish this, first 
locating the minimum and maximum value in the list, and then dividing 
the region between them into <i>n</i>/<i>c</i> equal-sized bins. Where 
caching is an issue, it can help to have a maximum number of bins in 
each recursive division step, causing this division process to take 
multiple steps. Though this causes more iterations, it reduces cache 
misses and can make the algorithm run faster overall.</p>
<p>In the case where the number of bins is at least the number of 
elements, spreadsort degenerates to bucket sort and the sort completes. 
Otherwise, each bin is sorted recursively. The algorithm uses heuristic 
tests to determine whether each bin would be more efficiently sorted by 
spreadsort or some other classical sort algorithm, then recursively 
sorts the bin.</p>
<p>Like other distribution-based sorts, spreadsort has the weakness that
 the programmer is required to provide a means of converting each 
element into a numeric key, for the purpose of identifying which bin it 
falls in. Although it is possible to do this for arbitrary-length 
elements such as strings by considering each element to be followed by 
an infinite number of minimum values, and indeed for any datatype 
possessing a <a href="http://en.m.wikipedia.org/wiki/Total_order" title="Total order">total order</a>,
 this can be more difficult to implement correctly than a simple 
comparison function, especially on complex structures. Poor 
implementation of this <i>value</i> function can result in clustering that harms the algorithm's relative performance.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Performance">Performance</span></h2><div class="content_block" id="content_1">
<p>The worst-case performance of spreadsort ultimately depends on what sort it switches to on smaller bins — O(<i>n</i> log <i>n</i>) if it uses a worst-case O(<i>n</i> log <i>n</i>) sort such as <a href="http://en.m.wikipedia.org/wiki/Mergesort" title="Mergesort" class="mw-redirect">mergesort</a> or <a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">heapsort</a>, and O(<i>n</i><sup>2</sup>) if it uses quicksort. In the case of distributions where the size of the key in bits <i>k</i> times 2 is roughly the square of the log of the list size <i>n</i> or smaller (2<i>k</i> &lt; log(<i>n</i>)<sup>2</sup>), it does better in the worst case, achieving O(<i>n</i>·(<i>k</i> - log(<i>n</i>))<sup>.5</sup>) worst-case time for the originally published version, and O(<i>n</i>·((<i>k</i>/<i>s</i>) + s)) for the cache aware version.</p>
<p>Experiments were done comparing an optimized version of spreadsort to the highly-optimized C++ <code>std::sort</code>,
 implemented with introsort. On lists of integers and floats spreadsort 
shows a roughly 2-7X runtime improvement for random data on various 
operating systems.<a rel="nofollow" class="external autonumber" href="http://www.boostpro.com/vault/index.php?action=downloadfile&amp;filename=algorithm_sorting.zip&amp;directory=&amp;">[1]</a></p>
<p>In space performance, spreadsort is worse than most in-place 
algorithms: in its simplest form, it is not an in-place algorithm, using
 O(<i>n</i>) extra space; in experiments, about 20% more than quicksort 
using a c of 4-8. With a cache-aware form, less memory is used and there
 is an upper bound on memory usage of the maximum bin count times the 
maximum number of recursions, which ends up being a few kilobytes times 
the size of the key in bytes. Although it uses asymptotically more space
 than the O(log <i>n</i>) overhead of quicksort or the O(1) overhead of 
heapsort, it uses considerably less space than the basic form of 
mergesort, which uses auxiliary space equal to the space occupied by the
 list.</p>
<p>Spreadsort also works efficiently on problems too large to fit in memory and thus requiring disk access.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Implementation">Implementation</span></h2><div class="content_block" id="content_2">
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="c source-c">
<pre class="de1"><span class="kw4">unsigned</span> 
RoughLog2<span class="br0">(</span>DATATYPE input<span class="br0">)</span> 
<span class="br0">{</span>
        <span class="kw4">unsigned</span> <span class="kw4">char</span> cResult <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="co1">// The &amp;&amp; is necessary on some compilers to avoid infinite loops; it doesn't</span>
        <span class="co1">// significantly impair performance</span>
        <span class="kw1">if</span><span class="br0">(</span>input <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span>
                <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>input <span class="sy0">&gt;&gt;</span> cResult<span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>cResult <span class="sy0">&lt;</span> DATA_SIZE<span class="br0">)</span><span class="br0">)</span> cResult<span class="sy0">++;</span>
        <span class="kw1">else</span>
                <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span><span class="br0">(</span>input <span class="sy0">&gt;&gt;</span> cResult<span class="br0">)</span> <span class="sy0">&lt;</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>cResult <span class="sy0">&lt;</span> DATA_SIZE<span class="br0">)</span><span class="br0">)</span> cResult<span class="sy0">++;</span>
        <span class="kw1">return</span> cResult<span class="sy0">;</span>
<span class="br0">}</span>
SIZETYPE
GetMaxCount<span class="br0">(</span><span class="kw4">unsigned</span> logRange<span class="sy0">,</span> <span class="kw4">unsigned</span> uCount<span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw4">unsigned</span> logSize <span class="sy0">=</span> RoughLog2Size<span class="br0">(</span>uCount<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw4">unsigned</span> uRelativeWidth <span class="sy0">=</span> <span class="br0">(</span>LOG_CONST <span class="sy0">*</span> logRange<span class="br0">)</span><span class="sy0">/</span><span class="br0">(</span><span class="br0">(</span>logSize <span class="sy0">&gt;</span> MAX_SPLITS<span class="br0">)</span> <span class="sy0">?</span> MAX_SPLITS <span class="sy0">:</span> logSize<span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Don't try to bitshift more than the size of an element</span>
        <span class="kw1">if</span><span class="br0">(</span>DATA_SIZE <span class="sy0">&lt;=</span> uRelativeWidth<span class="br0">)</span>
                uRelativeWidth <span class="sy0">=</span> DATA_SIZE <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="br0">(</span><span class="br0">(</span>uRelativeWidth <span class="sy0">&lt;</span> <span class="br0">(</span>LOG_MEAN_BIN_SIZE <span class="sy0">+</span> LOG_MIN_SPLIT_COUNT<span class="br0">)</span><span class="br0">)</span> <span class="sy0">?</span> 
                <span class="br0">(</span>LOG_MEAN_BIN_SIZE <span class="sy0">+</span> LOG_MIN_SPLIT_COUNT<span class="br0">)</span> <span class="sy0">:</span>  uRelativeWidth<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> 
FindExtremes<span class="br0">(</span>DATATYPE <span class="sy0">*</span>Array<span class="sy0">,</span> SIZETYPE uCount<span class="sy0">,</span> DATATYPE <span class="sy0">&amp;</span> piMax<span class="sy0">,</span> DATATYPE <span class="sy0">&amp;</span> piMin<span class="br0">)</span>
<span class="br0">{</span>
        SIZETYPE u<span class="sy0">;</span>
        piMin <span class="sy0">=</span> piMax <span class="sy0">=</span> Array<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>u <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> u <span class="sy0">&lt;</span> uCount<span class="sy0">;</span> <span class="sy0">++</span>u<span class="br0">)</span><span class="br0">{</span>
                <span class="kw1">if</span><span class="br0">(</span>Array<span class="br0">[</span>u<span class="br0">]</span> <span class="sy0">&gt;</span> piMax<span class="br0">)</span>
                        piMax<span class="sy0">=</span>Array<span class="br0">[</span>u<span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>Array<span class="br0">[</span>u<span class="br0">]</span> <span class="sy0">&lt;</span> piMin<span class="br0">)</span>
                        piMin<span class="sy0">=</span> Array<span class="br0">[</span>u<span class="br0">]</span><span class="sy0">;</span>
        <span class="br0">}</span>
<span class="br0">}</span>       
 
<span class="co1">//---------------------SpreadSort Source-----------------</span>
 
Bin <span class="sy0">*</span>
SpreadSortCore<span class="br0">(</span>DATATYPE <span class="sy0">*</span>Array<span class="sy0">,</span> SIZETYPE uCount<span class="sy0">,</span> SIZETYPE <span class="sy0">&amp;</span> uBinCount<span class="sy0">,</span> DATATYPE <span class="sy0">&amp;</span>iMax<span class="sy0">,</span> DATATYPE <span class="sy0">&amp;</span>iMin<span class="br0">)</span>
<span class="br0">{</span>
        <span class="co1">// This step is roughly 10% of runtime but it helps avoid worst-case</span>
        <span class="co1">// behavior and improves behavior with real data.  If you know the</span>
        <span class="co1">// maximum and minimum ahead of time, you can pass those values in</span>
        <span class="co1">// and skip this step for the first iteration</span>
        FindExtremes<span class="br0">(</span><span class="br0">(</span>DATATYPE <span class="sy0">*</span><span class="br0">)</span> Array<span class="sy0">,</span> uCount<span class="sy0">,</span> iMax<span class="sy0">,</span> iMin<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>iMax <span class="sy0">==</span> iMin<span class="br0">)</span>
                <span class="kw1">return</span> NULL<span class="sy0">;</span>
        DATATYPE divMin<span class="sy0">,</span>divMax<span class="sy0">;</span>
        SIZETYPE u<span class="sy0">;</span>
        <span class="kw4">int</span> LogDivisor<span class="sy0">;</span>
        Bin <span class="sy0">*</span> BinArray<span class="sy0">;</span>
        Bin<span class="sy0">*</span> CurrentBin<span class="sy0">;</span>
        <span class="kw4">unsigned</span> logRange<span class="sy0">;</span>
        logRange <span class="sy0">=</span> RoughLog2Size<span class="br0">(</span><span class="br0">(</span>SIZETYPE<span class="br0">)</span>iMax<span class="sy0">-</span>iMin<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span><span class="br0">(</span>LogDivisor <span class="sy0">=</span> logRange <span class="sy0">-</span> RoughLog2Size<span class="br0">(</span>uCount<span class="br0">)</span> <span class="sy0">+</span> LOG_MEAN_BIN_SIZE<span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span>
                LogDivisor <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="co1">// The below if statement is only necessary on systems with high memory</span>
        <span class="co1">// latency relative to processor speed (most modern processors)</span>
        <span class="kw1">if</span><span class="br0">(</span><span class="br0">(</span>logRange <span class="sy0">-</span> LogDivisor<span class="br0">)</span> <span class="sy0">&gt;</span> MAX_SPLITS<span class="br0">)</span>
                LogDivisor <span class="sy0">=</span> logRange <span class="sy0">-</span> MAX_SPLITS<span class="sy0">;</span>
        divMin <span class="sy0">=</span> iMin <span class="sy0">&gt;&gt;</span> LogDivisor<span class="sy0">;</span>
        divMax <span class="sy0">=</span> iMax <span class="sy0">&gt;&gt;</span> LogDivisor<span class="sy0">;</span>
        uBinCount <span class="sy0">=</span> divMax <span class="sy0">-</span> divMin <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
 
        <span class="co1">// Allocate the bins and determine their sizes</span>
        BinArray <span class="sy0">=</span> <span class="kw3">calloc</span><span class="br0">(</span>uBinCount<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>Bin<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Memory allocation failure check and clean return with sorted results</span>
    <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>BinArray<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Using std::sort because of memory allocation failure<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
                std<span class="sy0">::</span><span class="me2">sort</span><span class="br0">(</span>Array<span class="sy0">,</span> Array <span class="sy0">+</span> uCount<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> NULL<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="co1">// Calculating the size of each bin; this takes roughly 10% of runtime</span>
        <span class="kw1">for</span><span class="br0">(</span>u <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> u <span class="sy0">&lt;</span> uCount<span class="sy0">;</span> <span class="sy0">++</span>u<span class="br0">)</span>
                BinArray<span class="br0">[</span><span class="br0">(</span>Array<span class="br0">[</span>u<span class="br0">]</span> <span class="sy0">&gt;&gt;</span> LogDivisor<span class="br0">)</span> <span class="sy0">-</span> divMin<span class="br0">]</span>.<span class="me1">uCount</span><span class="sy0">++;</span>
        <span class="co1">// Assign the bin positions</span>
        BinArray<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">=</span> <span class="br0">(</span>DATATYPE <span class="sy0">*</span><span class="br0">)</span>Array<span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>u <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> u <span class="sy0">&lt;</span> uBinCount <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> u<span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
                BinArray<span class="br0">[</span>u <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">=</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">+</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span><span class="sy0">;</span>
                BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span> <span class="sy0">=</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">-</span> Array<span class="sy0">;</span>
        <span class="br0">}</span>
        BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span> <span class="sy0">=</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">-</span> Array<span class="sy0">;</span>
 
        <span class="co1">// Swap into place.  This dominates runtime, especially in the swap;</span>
        <span class="co1">// std::sort calls are the other main time-user.</span>
        <span class="kw1">for</span><span class="br0">(</span>u <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> u <span class="sy0">&lt;</span> uCount<span class="sy0">;</span> <span class="sy0">++</span>u<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">for</span><span class="br0">(</span>CurrentBin <span class="sy0">=</span> BinArray <span class="sy0">+</span> <span class="br0">(</span><span class="br0">(</span>Array<span class="br0">[</span>u<span class="br0">]</span> <span class="sy0">&gt;&gt;</span> LogDivisor<span class="br0">)</span> <span class="sy0">-</span> divMin<span class="br0">)</span><span class="sy0">;</span>  <span class="br0">(</span>CurrentBin<span class="sy0">-&gt;</span>uCount <span class="sy0">&gt;</span> u<span class="br0">)</span><span class="sy0">;</span> 
                        CurrentBin <span class="sy0">=</span> BinArray <span class="sy0">+</span> <span class="br0">(</span><span class="br0">(</span>Array<span class="br0">[</span>u<span class="br0">]</span> <span class="sy0">&gt;&gt;</span> LogDivisor<span class="br0">)</span> <span class="sy0">-</span> divMin<span class="br0">)</span><span class="br0">)</span>
                                SWAP<span class="br0">(</span>Array <span class="sy0">+</span> u<span class="sy0">,</span> CurrentBin<span class="sy0">-&gt;</span>CurrentPosition<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="co1">// Now that we've found the item belonging in this position,</span>
                <span class="co1">// increment the bucket count</span>
                <span class="kw1">if</span><span class="br0">(</span>CurrentBin<span class="sy0">-&gt;</span>CurrentPosition <span class="sy0">==</span> Array <span class="sy0">+</span> u<span class="br0">)</span>
                        <span class="sy0">++</span><span class="br0">(</span>CurrentBin<span class="sy0">-&gt;</span>CurrentPosition<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="co1">// If we've bucketsorted, the array is sorted and we should skip recursion</span>
        <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>LogDivisor<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">free</span><span class="br0">(</span>BinArray<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> NULL<span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> BinArray<span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span>
SpreadSortBins<span class="br0">(</span>DATATYPE <span class="sy0">*</span>Array<span class="sy0">,</span> SIZETYPE uCount<span class="sy0">,</span> SIZETYPE uBinCount<span class="sy0">,</span> <span class="kw4">const</span> DATATYPE <span class="sy0">&amp;</span>iMax
                                <span class="sy0">,</span> <span class="kw4">const</span> DATATYPE <span class="sy0">&amp;</span>iMin<span class="sy0">,</span> Bin <span class="sy0">*</span> BinArray<span class="sy0">,</span> SIZETYPE uMaxCount<span class="br0">)</span>
<span class="br0">{</span>
        SIZETYPE u<span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>u <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> u <span class="sy0">&lt;</span> uBinCount<span class="sy0">;</span> u<span class="sy0">++</span><span class="br0">)</span><span class="br0">{</span>
                SIZETYPE count <span class="sy0">=</span> <span class="br0">(</span>BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">CurrentPosition</span> <span class="sy0">-</span> Array<span class="br0">)</span> <span class="sy0">-</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span><span class="sy0">;</span>
                <span class="co1">// Don't sort unless there are at least two items to compare</span>
                <span class="kw1">if</span><span class="br0">(</span>count <span class="sy0">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
                        <span class="kw1">continue</span><span class="sy0">;</span>
                <span class="kw1">if</span><span class="br0">(</span>count <span class="sy0">&lt;</span> uMaxCount<span class="br0">)</span>
                        std<span class="sy0">::</span><span class="me2">sort</span><span class="br0">(</span>Array <span class="sy0">+</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span><span class="sy0">,</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">CurrentPosition</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                        SpreadSortRec<span class="br0">(</span>Array <span class="sy0">+</span> BinArray<span class="br0">[</span>u<span class="br0">]</span>.<span class="me1">uCount</span><span class="sy0">,</span> count<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw3">free</span><span class="br0">(</span>BinArray<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> 
SpreadSortRec<span class="br0">(</span>DATATYPE <span class="sy0">*</span>Array<span class="sy0">,</span> SIZETYPE uCount<span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>uCount <span class="sy0">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
                <span class="kw1">return</span><span class="sy0">;</span>         
        DATATYPE iMax<span class="sy0">,</span> iMin<span class="sy0">;</span>
        SIZETYPE uBinCount<span class="sy0">;</span>
        Bin <span class="sy0">*</span> BinArray <span class="sy0">=</span> SpreadSortCore<span class="br0">(</span>Array<span class="sy0">,</span> uCount<span class="sy0">,</span> uBinCount<span class="sy0">,</span> iMax<span class="sy0">,</span> iMin<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>BinArray<span class="br0">)</span>
                <span class="kw1">return</span><span class="sy0">;</span>
        SpreadSortBins<span class="br0">(</span>Array<span class="sy0">,</span> uCount<span class="sy0">,</span> uBinCount<span class="sy0">,</span> iMax<span class="sy0">,</span> iMin<span class="sy0">,</span> BinArray<span class="sy0">,</span>
                       GetMaxCount<span class="br0">(</span>RoughLog2Size<span class="br0">(</span><span class="br0">(</span>SIZETYPE<span class="br0">)</span>iMax<span class="sy0">-</span>iMin<span class="br0">)</span><span class="sy0">,</span> uCount<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
</div>
</div>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Two_Levels_are_as_Good_as_Any">Two Levels are as Good as Any</span></h2><div class="content_block" id="content_3">
<p>An interesting result for algorithms of this general type (splitting 
based on the radix, then comparison-based sorting) is that they are O(<i>n</i>) for any continuous integrable function. <sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup>
 This result can be obtained by forcing Spreadsort to always iterate at 
least twice if the bin size after the first iteration is above some 
constant value. If data is known to come in based upon some continuous 
integrable function at all times, this modification of Spreadsort can 
attain some performance improvement over the basic algorithm, and will 
have better worst-case performance. If this restriction cannot usually 
be depended on, this change will add a little extra runtime overhead to 
the algorithm and gain little. Other similar algorithms are Flashsort 
(which is simpler) and Adaptive Left Radix. Adaptive Left Radix is 
apparently quite similar, the main difference being recursive behavior, 
with Spreadsort checking for worst-case situations and using std::sort 
to avoid performance problems where necessary, and Adaptive Left Radix 
recursing continuously until done or the data is small enough to use 
insertionsort.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_4">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text">Steven J. Ross. The Spreadsort High-performance General-case Sorting Algorithm. <i>Parallel and Distributed Processing Techniques and Applications</i>, Volume 3, pp.1100–1106. Las Vegas Nevada. 2002.</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Markku Tamminen: Two Levels are as Good as Any. J. Algorithms 6(1): 138-144 (1985)</span>
</li>
</ol>
<table class="navbox" style="border-spacing: 0pt;" cellspacing="0"><tbody><tr>
<td style="padding: 2px;">
<table class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing: 0pt; background: none repeat scroll 0% 0% transparent; color: inherit;" cellspacing="0">
<tbody><tr>
<th scope="col" style="" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:Sorting" title="Template:Sorting"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:Sorting" title="Template talk:Sorting"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:Sorting&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;"><a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">Sorting algorithms</a></div>
</th>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Theory</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Computational_complexity_theory" title="Computational complexity theory">Computational complexity theory</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation">Big O notation</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Total_order" title="Total order">Total order</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/List_%28computing%29" title="List (computing)" class="mw-redirect">Lists</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm#Stability" title="Sorting algorithm">Stability</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">Comparison sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Adaptive_sort" title="Adaptive sort">Adaptive sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Sorting_network" title="Sorting network">Sorting network</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Integer_sorting" title="Integer sorting">Integer sorting</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Exchange sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Bubble_sort" title="Bubble sort">Bubble sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cocktail_sort" title="Cocktail sort">Cocktail sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Odd%E2%80%93even_sort" title="Odd–even sort">Odd–even sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Comb_sort" title="Comb sort">Comb sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Gnome_sort" title="Gnome sort">Gnome sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Quicksort" title="Quicksort">Quicksort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Stooge_sort" title="Stooge sort">Stooge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bogosort" title="Bogosort">Bogosort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Selection sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Selection_sort" title="Selection sort">Selection sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">Heapsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Smoothsort" title="Smoothsort">Smoothsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting" title="Cartesian tree">Cartesian tree sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Tournament_sort" title="Tournament sort">Tournament sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cycle_sort" title="Cycle sort">Cycle sort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Insertion sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">Insertion sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Shellsort" title="Shellsort">Shellsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Tree_sort" title="Tree sort">Tree sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Library_sort" title="Library sort">Library sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Patience_sorting" title="Patience sorting">Patience sorting</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Merge sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">Merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Polyphase_merge_sort" title="Polyphase merge sort">Polyphase merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Strand_sort" title="Strand sort">Strand sort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Distribution sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/American_flag_sort" title="American flag sort">American flag sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bead_sort" title="Bead sort">Bead sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bucket_sort" title="Bucket sort">Bucket sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Burstsort" title="Burstsort">Burstsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Counting_sort" title="Counting sort">Counting sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pigeonhole_sort" title="Pigeonhole sort">Pigeonhole sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Proxmap_sort" title="Proxmap sort">Proxmap sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">Radix sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Flashsort" title="Flashsort">Flashsort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Concurrent sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Bitonic_sorter" title="Bitonic sorter">Bitonic sorter</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Batcher_odd%E2%80%93even_mergesort" title="Batcher odd–even mergesort">Batcher odd–even mergesort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pairwise_sorting_network" title="Pairwise sorting network">Pairwise sorting network</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Hybrid sorts</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Timsort" title="Timsort">Timsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Introsort" title="Introsort">Introsort</a></li>
<li><strong class="selflink">Spreadsort</strong></li>
<li><a href="http://en.m.wikipedia.org/wiki/UnShuffle_sort" title="UnShuffle sort">UnShuffle sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/JSort" title="JSort">JSort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Other</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Topological_sorting" title="Topological sorting">Topological sorting</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pancake_sorting" title="Pancake sorting">Pancake sorting</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Spaghetti_sort" title="Spaghetti sort">Spaghetti sort</a></li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</td>
</tr></tbody></table>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Spreadsort&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Spreadsort&amp;mobiletoken=5c89e355d2af09275b3b2ed3653e1683" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Spreadsort&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Spreadsort&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Spreadsort_files/load_002.php" type="text/javascript"></script>
<script src="Spreadsort_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>