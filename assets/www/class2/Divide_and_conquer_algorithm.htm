<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Divide and conquer algorithm - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Divide_and_conquer_algorithm_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 23 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Divide_and_conquer_algorithm_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Divide_and_conquer_algorithm_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Divide_and_conquer_algorithm_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" selected="selected">English</option><option value="//ar.m.wikipedia.org/wiki/%D8%AE%D9%88%D8%A7%D8%B1%D8%B2%D9%85%D9%8A%D8%A9_%D9%81%D8%B1%D9%82_%D8%AA%D8%B3%D8%AF">العربية</option><option value="//cs.m.wikipedia.org/wiki/Rozd%C4%9Bl_a_panuj_(algoritmus)">česky</option><option value="//de.m.wikipedia.org/wiki/Teile_und_herrsche_(Informatik)">Deutsch</option><option value="//el.m.wikipedia.org/wiki/%CE%94%CE%B9%CE%B1%CE%AF%CF%81%CE%B5%CE%B9_%CE%BA%CE%B1%CE%B9_%CE%B2%CE%B1%CF%83%CE%AF%CE%BB%CE%B5%CF%85%CE%B5_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)">Ελληνικά</option><option value="//es.m.wikipedia.org/wiki/Algoritmo_divide_y_vencer%C3%A1s">español</option><option value="//fa.m.wikipedia.org/wiki/%D8%A7%D9%84%DA%AF%D9%88%D8%B1%DB%8C%D8%AA%D9%85_%D8%AA%D9%82%D8%B3%DB%8C%D9%85_%D9%88_%D8%AD%D9%84">فارسی</option><option value="//fr.m.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)">français</option><option value="//gl.m.wikipedia.org/wiki/Agoritmo_divide_e_vencer%C3%A1s">galego</option><option value="//ko.m.wikipedia.org/wiki/%EB%B6%84%ED%95%A0_%EC%A0%95%EB%B3%B5_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">한국어</option><option value="//id.m.wikipedia.org/wiki/Divide_and_Conquer">Bahasa Indonesia</option><option value="//is.m.wikipedia.org/wiki/Deili-_og_drottnunarreiknirit">íslenska</option><option value="//it.m.wikipedia.org/wiki/Divide_et_impera_(informatica)">italiano</option><option value="//he.m.wikipedia.org/wiki/%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D_%D7%94%D7%A4%D7%A8%D7%93_%D7%95%D7%9E%D7%A9%D7%95%D7%9C">עברית</option><option value="//ja.m.wikipedia.org/wiki/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95">日本語</option><option value="//pl.m.wikipedia.org/wiki/Dziel_i_zwyci%C4%99%C5%BCaj">polski</option><option value="//pt.m.wikipedia.org/wiki/Divis%C3%A3o_e_conquista">português</option><option value="//ro.m.wikipedia.org/wiki/Divide_et_impera_(informatic%C4%83)">română</option><option value="//ru.m.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9_%D0%B8_%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)">русский</option><option value="//sl.m.wikipedia.org/wiki/Deli_in_vladaj_(ra%C4%8Dunalni%C5%A1tvo)">slovenščina</option><option value="//sr.m.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8_%D0%BF%D0%B0_%D0%B2%D0%BB%D0%B0%D0%B4%D0%B0%D1%98_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)">српски / srpski</option><option value="//vi.m.wikipedia.org/wiki/Thu%E1%BA%ADt_to%C3%A1n_chia_%C4%91%E1%BB%83_tr%E1%BB%8B">Tiếng Việt</option><option value="//zh.m.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">中文</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Divide and conquer algorithm</h1>			
<p>In <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, <b>divide and conquer</b> (<b>D&amp;C</b>) is an important <a href="http://en.m.wikipedia.org/wiki/Algorithm_design" title="Algorithm design">algorithm design</a> <a href="http://en.m.wikipedia.org/wiki/Paradigm" title="Paradigm">paradigm</a> based on multi-branched <a href="http://en.m.wikipedia.org/wiki/Recursion" title="Recursion">recursion</a>. A divide and conquer <a href="http://en.m.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a>
 works by recursively breaking down a problem into two or more 
sub-problems of the same (or related) type, until these become simple 
enough to be solved directly. The solutions to the sub-problems are then
 combined to give a solution to the original problem.</p>
<p>This technique is the basis of efficient algorithms for all kinds of problems, such as <a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">sorting</a> (e.g., <a href="http://en.m.wikipedia.org/wiki/Quicksort" title="Quicksort">quicksort</a>, <a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">merge sort</a>), <a href="http://en.m.wikipedia.org/wiki/Multiplication_algorithm" title="Multiplication algorithm">multiplying large numbers</a> (e.g. <a href="http://en.m.wikipedia.org/wiki/Karatsuba_algorithm" title="Karatsuba algorithm">Karatsuba</a>), <a href="http://en.m.wikipedia.org/wiki/Syntactic_analysis" title="Syntactic analysis" class="mw-redirect">syntactic analysis</a> (e.g., <a href="http://en.m.wikipedia.org/wiki/Top-down_parser" title="Top-down parser" class="mw-redirect">top-down parsers</a>), and computing the <a href="http://en.m.wikipedia.org/wiki/Discrete_Fourier_transform" title="Discrete Fourier transform">discrete Fourier transform</a> (<a href="http://en.m.wikipedia.org/wiki/Fast_Fourier_transform" title="Fast Fourier transform">FFTs</a>).</p>
<p>On the other hand, the ability to understand and design D&amp;C algorithms is a skill that takes time to master. As when <a href="http://en.m.wikipedia.org/wiki/Proof_%28mathematics%29" title="Proof (mathematics)" class="mw-redirect">proving</a> a <a href="http://en.m.wikipedia.org/wiki/Theorem" title="Theorem">theorem</a>
 by induction, it is often necessary to replace the original problem by a
 more general or complicated problem in order to get the recursion 
going, and there is no systematic method for finding the proper 
generalization.</p>
<p>The name "divide and conquer" is sometimes applied also to algorithms
 that reduce each problem to only one subproblem, such as the <a href="http://en.m.wikipedia.org/wiki/Binary_search" title="Binary search" class="mw-redirect">binary search</a> algorithm for finding a record in a sorted list (or its analog in <a href="http://en.m.wikipedia.org/wiki/Numerical_algorithm" title="Numerical algorithm" class="mw-redirect">numerical computing</a>, the <a href="http://en.m.wikipedia.org/wiki/Bisection_algorithm" title="Bisection algorithm" class="mw-redirect">bisection algorithm</a> for <a href="http://en.m.wikipedia.org/wiki/Root-finding_algorithm" title="Root-finding algorithm">root finding</a>).<sup id="cite_ref-CLR_0-0" class="reference"><a href="#cite_note-CLR-0"><span>[</span>1<span>]</span></a></sup> These algorithms can be implemented more efficiently than general divide-and-conquer algorithms; in particular, if they use <a href="http://en.m.wikipedia.org/wiki/Tail_recursion" title="Tail recursion" class="mw-redirect">tail recursion</a>, they can be converted into simple <a href="http://en.m.wikipedia.org/wiki/Loop_%28computing%29" title="Loop (computing)" class="mw-redirect">loops</a>.
 Under this broad definition, however, every algorithm that uses 
recursion or loops could be regarded as a "divide and conquer 
algorithm". Therefore, some authors consider that the name "divide and 
conquer" should be used only when each problem may generate two or more 
subproblems.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup> The name <b>decrease and conquer</b> has been proposed instead for the single-subproblem class.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>3<span>]</span></a></sup></p>
<p>The correctness of a divide and conquer algorithm is usually proved by <a href="http://en.m.wikipedia.org/wiki/Mathematical_induction" title="Mathematical induction">mathematical induction</a>, and its computational cost is often determined by solving <a href="http://en.m.wikipedia.org/wiki/Recurrence_relation" title="Recurrence relation">recurrence relations</a>.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Early_historical_examples">Early historical examples</span></h2><div class="content_block" id="content_1">
<p>Binary search, a divide and conquer algorithm in which the original problem is successively broken down into <i>single</i>
 subproblems of roughly half the original size, has a long history. 
While a clear description of the algorithm on computers appeared in 1946
 in an article by <a href="http://en.m.wikipedia.org/wiki/John_Mauchly" title="John Mauchly">John Mauchly</a>, the idea of using a sorted list of items to facilitate searching dates back at least as far as <a href="http://en.m.wikipedia.org/wiki/Babylonia" title="Babylonia">Babylonia</a> in 200&nbsp;BC.<sup id="cite_ref-Knuth3_3-0" class="reference"><a href="#cite_note-Knuth3-3"><span>[</span>4<span>]</span></a></sup> Another divide and conquer algorithm with a single subproblem is the <a href="http://en.m.wikipedia.org/wiki/Euclidean_algorithm" title="Euclidean algorithm">Euclidean algorithm</a> to compute the <a href="http://en.m.wikipedia.org/wiki/Greatest_common_divisor" title="Greatest common divisor">greatest common divisor</a> of two numbers (by reducing the numbers to smaller and smaller equivalent subproblems), which dates to several centuries BC.</p>
<p>An early example of a divide-and-conquer algorithm with multiple subproblems is <a href="http://en.m.wikipedia.org/wiki/Carl_Friedrich_Gauss" title="Carl Friedrich Gauss">Gauss</a>'s 1805 description of what is now called the <a href="http://en.m.wikipedia.org/wiki/Cooley-Tukey_FFT_algorithm" title="Cooley-Tukey FFT algorithm" class="mw-redirect">Cooley-Tukey fast Fourier transform</a> (FFT) algorithm,<sup id="cite_ref-Heideman84_4-0" class="reference"><a href="#cite_note-Heideman84-4"><span>[</span>5<span>]</span></a></sup> although he did not analyze its <a href="http://en.m.wikipedia.org/wiki/Algorithmic_complexity" title="Algorithmic complexity" class="mw-redirect">operation count</a> quantitatively and FFTs did not become widespread until they were rediscovered over a century later.</p>
<p>An early two-subproblem D&amp;C algorithm that was specifically developed for computers and properly analyzed is the <a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">merge sort</a> algorithm, invented by <a href="http://en.m.wikipedia.org/wiki/John_von_Neumann" title="John von Neumann">John von Neumann</a> in 1945.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>6<span>]</span></a></sup></p>
<p>Another notable example is the <a href="http://en.m.wikipedia.org/wiki/Karatsuba_algorithm" title="Karatsuba algorithm">algorithm</a> invented by <a href="http://en.m.wikipedia.org/wiki/Anatolii_Alexeevitch_Karatsuba" title="Anatolii Alexeevitch Karatsuba">Anatolii A. Karatsuba</a> in 1960<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>7<span>]</span></a></sup> that could multiply two <i>n</i>-digit numbers in <img class="tex" alt="O(n^{\log_2 3})" src="Divide_and_conquer_algorithm_files/afb447a7bcf68d53382a81484f5e5575.png"> operations (in <a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation">Big O notation</a>). This algorithm disproved <a href="http://en.m.wikipedia.org/wiki/Andrey_Kolmogorov" title="Andrey Kolmogorov">Andrey Kolmogorov</a>'s 1956 conjecture that <img class="tex" alt="\Omega(n^2)\,\!" src="Divide_and_conquer_algorithm_files/ff620471fd91a871ed916be9864d20d0.png"> operations would be required for that task.</p>
<p>As another example of a divide and conquer algorithm that did not originally involve computers, <a href="http://en.m.wikipedia.org/wiki/Donald_Knuth" title="Donald Knuth">Knuth</a> gives the method a <a href="http://en.m.wikipedia.org/wiki/Post_office" title="Post office">post office</a>
 typically uses to route mail: letters are sorted into separate bags for
 different geographical areas, each of these bags is itself sorted into 
batches for smaller sub-regions, and so on until they are delivered.<sup id="cite_ref-Knuth3_3-1" class="reference"><a href="#cite_note-Knuth3-3"><span>[</span>4<span>]</span></a></sup> This is related to a <a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">radix sort</a>, described for <a href="http://en.m.wikipedia.org/wiki/IBM_80_series_Card_Sorters" title="IBM 80 series Card Sorters" class="mw-redirect">punch-card sorting</a> machines as early as 1929.<sup id="cite_ref-Knuth3_3-2" class="reference"><a href="#cite_note-Knuth3-3"><span>[</span>4<span>]</span></a></sup></p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Advantages">Advantages</span></h2><div class="content_block" id="content_2">
<h3> <span class="mw-headline" id="Solving_difficult_problems">Solving difficult problems</span>
</h3>
<p>Divide and conquer is a powerful tool for solving conceptually difficult problems, such as the classic <a href="http://en.m.wikipedia.org/wiki/Tower_of_Hanoi" title="Tower of Hanoi">Tower of Hanoi</a>
 puzzle: all it requires is a way of breaking the problem into 
sub-problems, of solving the trivial cases and of combining sub-problems
 to the original problem.</p>
<h3> <span class="mw-headline" id="Algorithm_efficiency">Algorithm efficiency</span>
</h3>
<p>The divide-and-conquer paradigm often helps in the discovery of 
efficient algorithms. It was the key, for example, to Karatsuba's fast 
multiplication method, the quicksort and mergesort algorithms, the <a href="http://en.m.wikipedia.org/wiki/Strassen_algorithm" title="Strassen algorithm">Strassen algorithm</a> for matrix multiplication, and fast Fourier transforms.</p>
<p>In all these examples, the D&amp;C approach led to an improvement in the <a href="http://en.m.wikipedia.org/wiki/Asymptotic_complexity" title="Asymptotic complexity" class="mw-redirect">asymptotic cost</a>
 of the solution. For example, if the base cases have constant-bounded 
size, the work of splitting the problem and combining the partial 
solutions is proportional to the problem's size <i>n</i>, and there are a bounded number <i>p</i> of subproblems of size ~ <i>n</i>/<i>p</i> at each stage, then the cost of the divide-and-conquer algorithm will be O(<i>n</i> log <i>n</i>).</p>
<h3> <span class="mw-headline" id="Parallelism">Parallelism</span>
</h3>
<p>Divide and conquer algorithms are naturally adapted for execution in 
multi-processor machines, especially shared-memory systems where the 
communication of data between processors does not need to be planned in 
advance, because distinct sub-problems can be executed on different 
processors.</p>
<h3> <span class="mw-headline" id="Memory_access">Memory access</span>
</h3>
<p>Divide-and-conquer algorithms naturally tend to make efficient use of <a href="http://en.m.wikipedia.org/wiki/Memory_cache" title="Memory cache" class="mw-redirect">memory caches</a>.
 The reason is that once a sub-problem is small enough, it and all its 
sub-problems can, in principle, be solved within the cache, without 
accessing the slower main memory. An algorithm designed to exploit the 
cache in this way is called <i><a href="http://en.m.wikipedia.org/wiki/Cache-oblivious_algorithm" title="Cache-oblivious algorithm">cache-oblivious</a></i>, because it does not contain the cache size(s) as an explicit parameter.<sup id="cite_ref-cahob_7-0" class="reference"><a href="#cite_note-cahob-7"><span>[</span>8<span>]</span></a></sup> Moreover, D&amp;C algorithms can be designed for important algorithms (e.g., sorting, FFTs, and matrix multiplication) to be <i>optimal</i>
 cache-oblivious algorithms–they use the cache in a provably optimal 
way, in an asymptotic sense, regardless of the cache size. In contrast, 
the traditional approach to exploiting the cache is <i>blocking</i>, 
where the problem is explicitly divided into chunks of the appropriate 
size—this can also use the cache optimally, but only when the algorithm 
is tuned for the specific cache size(s) of a particular machine.</p>
<p>The same advantage exists with regards to other hierarchical storage systems, such as <a href="http://en.m.wikipedia.org/wiki/Non-Uniform_Memory_Access" title="Non-Uniform Memory Access">NUMA</a> or <a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">virtual memory</a>,
 as well as for multiple levels of cache: once a sub-problem is small 
enough, it can be solved within a given level of the hierarchy, without 
accessing the higher (slower) levels.</p>
<h3> <span class="mw-headline" id="Roundoff_control">Roundoff control</span>
</h3>
<p>In computations with rounded arithmetic, e.g. with <a href="http://en.m.wikipedia.org/wiki/Floating_point" title="Floating point">floating point</a>
 numbers, a divide-and-conquer algorithm may yield more accurate results
 than a superficially equivalent iterative method. For example, one can 
add <i>N</i> numbers either by a simple loop that adds each datum to a single variable, or by a D&amp;C algorithm called <a href="http://en.m.wikipedia.org/wiki/Pairwise_summation" title="Pairwise summation">pairwise summation</a>
 that breaks the data set into two halves, recursively computes the sum 
of each half, and then adds the two sums. While the second method 
performs the same number of additions as the first, and pays the 
overhead of the recursive calls, it is usually more accurate.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>9<span>]</span></a></sup></p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Implementation_issues">Implementation issues</span></h2><div class="content_block" id="content_3">
<h3> <span class="mw-headline" id="Recursion">Recursion</span>
</h3>
<p>Divide-and-conquer algorithms are naturally implemented as <a href="http://en.m.wikipedia.org/wiki/Subroutine" title="Subroutine">recursive procedures</a>. In that case, the partial sub-problems leading to the one currently being solved are automatically stored in the <a href="http://en.m.wikipedia.org/wiki/Call_stack" title="Call stack">procedure call stack</a>.</p>
<h3> <span class="mw-headline" id="Explicit_stack">Explicit stack</span>
</h3>
<p>Divide and conquer algorithms can also be implemented by a 
non-recursive program that stores the partial sub-problems in some 
explicit data structure, such as a <a href="http://en.m.wikipedia.org/wiki/Stack_%28data_structure%29" title="Stack (data structure)" class="mw-redirect">stack</a>, <a href="http://en.m.wikipedia.org/wiki/Queue_%28data_structure%29" title="Queue (data structure)" class="mw-redirect">queue</a>, or <a href="http://en.m.wikipedia.org/wiki/Priority_queue" title="Priority queue">priority queue</a>.
 This approach allows more freedom in the choice of the sub-problem that
 is to be solved next, a feature that is important in some applications —
 e.g. in <a href="http://en.m.wikipedia.org/wiki/Breadth_first_recursion" title="Breadth first recursion" class="mw-redirect">breadth-first recursion</a> and the <a href="http://en.m.wikipedia.org/wiki/Branch_and_bound" title="Branch and bound">branch and bound</a>
 method for function optimization. This approach is also the standard 
solution in programming languages that do not provide support for 
recursive procedures.</p>
<h3> <span class="mw-headline" id="Stack_size">Stack size</span>
</h3>
<p>In recursive implementations of D&amp;C algorithms, one must make 
sure that there is sufficient memory allocated for the recursion stack, 
otherwise the execution may fail because of <a href="http://en.m.wikipedia.org/wiki/Stack_overflow" title="Stack overflow">stack overflow</a>.
 Fortunately, D&amp;C algorithms that are time-efficient often have 
relatively small recursion depth. For example, the quicksort algorithm 
can be implemented so that it never requires more than <img class="tex" alt="\log_2 n" src="Divide_and_conquer_algorithm_files/5275c7578d44491bc4df25a5ebc0086c.png"> nested recursive calls to sort <img class="tex" alt="n" src="Divide_and_conquer_algorithm_files/7b8b965ad4bca0e41ab51de7b31363a1.png"> items.</p>
<p>Stack overflow may be difficult to avoid when using recursive 
procedures, since many compilers assume that the recursion stack is a 
contiguous area of memory, and some allocate a fixed amount of space for
 it. Compilers may also save more information in the recursion stack 
than is strictly necessary, such as return address, unchanging 
parameters, and the internal variables of the procedure. Thus, the risk 
of stack overflow can be reduced by minimizing the parameters and 
internal variables of the recursive procedure, and/or by using an 
explicit stack structure.</p>
<h3> <span class="mw-headline" id="Choosing_the_base_cases">Choosing the base cases</span>
</h3>
<p>In any recursive algorithm, there is considerable freedom in the choice of the <i>base cases</i>, the small subproblems that are solved directly in order to terminate the recursion.</p>
<p>Choosing the smallest or simplest possible base cases is more elegant
 and usually leads to simpler programs, because there are fewer cases to
 consider and they are easier to solve. For example, an FFT algorithm 
could stop the recursion when the input is a single sample, and the 
quicksort list-sorting algorithm could stop when the input is the empty 
list; in both examples there is only one base case to consider, and it 
requires no processing.</p>
<p>On the other hand, efficiency often improves if the recursion is 
stopped at relatively large base cases, and these are solved 
non-recursively. This strategy avoids the overhead of recursive calls 
that do little or no work, and may also allow the use of specialized 
non-recursive algorithms that, for those base cases, are more efficient 
than explicit recursion. Since a D&amp;C algorithm eventually reduces 
each problem or sub-problem instance to a large number of base 
instances, these often dominate the overall cost of the algorithm, 
especially when the splitting/joining overhead is low. Note that these 
considerations do not depend on whether recursion is implemented by the 
compiler or by an explicit stack.</p>
<p>Thus, for example, many library implementations of quicksort will switch to a simple loop-based <a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">insertion sort</a>
 (or similar) algorithm once the number of items to be sorted is 
sufficiently small. Note that, if the empty list were the only base 
case, sorting a list with <i>n</i> entries would entail <i>n</i>+1 
quicksort calls that would do nothing but return immediately. Increasing
 the base cases to lists of size 2 or less will eliminate most of those 
do-nothing calls, and more generally a base case larger than 2 is 
typically used to reduce the fraction of time spent in function-call 
overhead or stack manipulation.</p>
<p>Alternatively, one can employ large base cases that still use a 
divide-and-conquer algorithm, but implement the algorithm for 
predetermined set of fixed sizes where the algorithm can be completely <a href="http://en.m.wikipedia.org/wiki/Loop_unwinding" title="Loop unwinding">unrolled</a> into code that has no recursion, loops, or <a href="http://en.m.wikipedia.org/wiki/Conditional_%28programming%29" title="Conditional (programming)">conditionals</a> (related to the technique of <a href="http://en.m.wikipedia.org/wiki/Partial_evaluation" title="Partial evaluation">partial evaluation</a>).
 For example, this approach is used in some efficient FFT 
implementations, where the base cases are unrolled implementations of 
divide-and-conquer FFT algorithms for a set of fixed sizes.<sup id="cite_ref-fftw_9-0" class="reference"><a href="#cite_note-fftw-9"><span>[</span>10<span>]</span></a></sup><a href="http://en.m.wikipedia.org/wiki/Source_code_generation" title="Source code generation" class="mw-redirect">Source code generation</a> methods may be used to produce the large number of separate base cases desirable to implement this strategy efficiently.<sup id="cite_ref-fftw_9-1" class="reference"><a href="#cite_note-fftw-9"><span>[</span>10<span>]</span></a></sup></p>
<p>The generalized version of this idea is known as recursion 
"unrolling" or "coarsening" and various techniques have been proposed 
for automating the procedure of enlarging the base case.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>11<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Sharing_repeated_subproblems">Sharing repeated subproblems</span>
</h3>
<p>For some problems, the branched recursion may end up evaluating the 
same sub-problem many times over. In such cases it may be worth 
identifying and saving the solutions to these overlapping subproblems, a
 technique commonly known as <a href="http://en.m.wikipedia.org/wiki/Memoization" title="Memoization">memoization</a>. Followed to the limit, it leads to <a href="http://en.m.wikipedia.org/wiki/Bottom-up_design" title="Bottom-up design" class="mw-redirect">bottom-up</a> divide-and-conquer algorithms such as <a href="http://en.m.wikipedia.org/wiki/Dynamic_programming" title="Dynamic programming">dynamic programming</a> and <a href="http://en.m.wikipedia.org/wiki/Chart_parsing" title="Chart parsing" class="mw-redirect">chart parsing</a>.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_4">
<div class="noprint tright portal" style="border:solid #aaa 1px; margin:0.5em 0 0.5em 0.5em;">
<table style="background: none repeat scroll 0% 0% rgb(249, 249, 249); font-size: 85%; line-height: 110%; max-width: 175px;"><tbody><tr>
<td style="text-align: center;"><a href="http://en.m.wikipedia.org/wiki/File:Internet_map_1024.jpg" class="image"><img alt="Portal icon" src="Divide_and_conquer_algorithm_files/28px-Internet_map_1024.jpg" width="28" height="28"></a></td>
<td style="padding: 0pt 0.2em; vertical-align: middle; font-style: italic; font-weight: bold;"><a href="http://en.m.wikipedia.org/wiki/Portal:Computer_Science" title="Portal:Computer Science" class="mw-redirect">Computer Science  portal</a></td>
</tr></tbody></table>
</div>
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Mathematical_induction" title="Mathematical induction">Mathematical induction</a></li>
<li>The <a href="http://en.m.wikipedia.org/wiki/Master_theorem" title="Master theorem">Master theorem</a>
</li>
<li>The <a href="http://en.m.wikipedia.org/wiki/Akra-Bazzi_method" title="Akra-Bazzi method" class="mw-redirect">Akra-Bazzi method</a>
</li>
<li><a href="http://en.m.wikipedia.org/wiki/Binary_search_algorithm" title="Binary search algorithm">Binary search algorithm</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Quicksort" title="Quicksort">Quicksort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Prune_and_search" title="Prune and search">Prune and search</a></li>
</ul>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_5">
<ol class="references">
<li id="cite_note-CLR-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-CLR_0-0">^</a></b></span> <span class="reference-text">Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest, <i>Introduction to Algorithms</i> (MIT Press, 2000).</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Brassard, G. and Bratley, P. Fundamental of Algorithmics, Prentice-Hall, 1996.</span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Anany V. Levitin, <i>Introduction to the Design and Analysis of Algorithms</i> (Addison Wesley, 2002).</span>
</li>
<li id="cite_note-Knuth3-3">
<span class="mw-cite-backlink">^ <a href="#cite_ref-Knuth3_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Knuth3_3-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Knuth3_3-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Donald E. Knuth, <i>The Art of Computer Programming: Volume 3, Sorting and Searching</i>, second edition (Addison-Wesley, 1998).</span>
</li>
<li id="cite_note-Heideman84-4">
<span class="mw-cite-backlink"><b><a href="#cite_ref-Heideman84_4-0">^</a></b></span> <span class="reference-text">Heideman,
 M. T., D. H. Johnson, and C. S. Burrus, "Gauss and the history of the 
fast Fourier transform," IEEE ASSP Magazine, 1, (4), 14–21 (1984)</span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Donald_Knuth" title="Donald Knuth">Knuth, Donald</a> (1998). <i>The Art of Computer Programming: Volume 3 Sorting and Searching</i>. p.&nbsp;159. <a href="http://en.m.wikipedia.org/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-201-89685-0" title="Special:BookSources/0-201-89685-0">0-201-89685-0</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Art+of+Computer+Programming%3A+Volume+3+Sorting+and+Searching&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald&amp;rft.au=Knuth%2C%26%2332%3BDonald&amp;rft.date=1998&amp;rft.pages=p.%26nbsp%3B159&amp;rft.isbn=0-201-89685-0&amp;rfr_id=info:sid/en.wikipedia.org:Divide_and_conquer_algorithm"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Anatolii_Alexeevitch_Karatsuba" title="Anatolii Alexeevitch Karatsuba">Karatsuba, Anatolii A.</a>; <a href="http://en.m.wikipedia.org/wiki/Yuri_Petrovich_Ofman" title="Yuri Petrovich Ofman">Yuri P. Ofman</a> (1962). "Умножение многозначных чисел на автоматах". <i><a href="http://en.m.wikipedia.org/wiki/Doklady_Akademii_Nauk_SSSR" title="Doklady Akademii Nauk SSSR" class="mw-redirect">Doklady Akademii Nauk SSSR</a></i> <b>146</b>: 293–294.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5+%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%BD%D1%8B%D1%85+%D1%87%D0%B8%D1%81%D0%B5%D0%BB+%D0%BD%D0%B0+%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0%D1%85&amp;rft.jtitle=%5B%5BDoklady+Akademii+Nauk+SSSR%5D%5D&amp;rft.aulast=Karatsuba&amp;rft.aufirst=Anatolii+A.&amp;rft.au=Karatsuba%2C%26%2332%3BAnatolii+A.&amp;rft.date=1962&amp;rft.volume=146&amp;rft.pages=293%E2%80%93294&amp;rfr_id=info:sid/en.wikipedia.org:Divide_and_conquer_algorithm"><span style="display: none;">&nbsp;</span></span> Translated in <span class="citation Journal"><i>Physics-Doklady</i> <b>7</b>: 595–596. 1963.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=&amp;rft.jtitle=Physics-Doklady&amp;rft.date=1963&amp;rft.volume=7&amp;rft.pages=595%E2%80%93596&amp;rfr_id=info:sid/en.wikipedia.org:Divide_and_conquer_algorithm"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-cahob-7">
<span class="mw-cite-backlink"><b><a href="#cite_ref-cahob_7-0">^</a></b></span> <span class="reference-text"><span class="citation Journal">M. Frigo; C. E. Leiserson, H. Prokop (1999). "Cache-oblivious algorithms". <i>Proc. 40th Symp. on the Foundations of Computer Science</i>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Cache-oblivious+algorithms&amp;rft.jtitle=Proc.+40th+Symp.+on+the+Foundations+of+Computer+Science&amp;rft.aulast=M.+Frigo&amp;rft.au=M.+Frigo&amp;rft.date=1999&amp;rfr_id=info:sid/en.wikipedia.org:Divide_and_conquer_algorithm"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-8">
<span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text">Nicholas J. Higham, "The accuracy of floating point summation", <i>SIAM J. Scientific Computing</i> <b>14</b> (4), 783–799 (1993).</span>
</li>
<li id="cite_note-fftw-9">
<span class="mw-cite-backlink">^ <a href="#cite_ref-fftw_9-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-fftw_9-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation Journal">Frigo, M.; Johnson, S. G. (February 2005). <a rel="nofollow" class="external text" href="http://www.fftw.org/fftw-paper-ieee.pdf">"The design and implementation of FFTW3"</a>. <i>Proceedings of the IEEE</i> <b>93</b> (2): 216–231. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1109%2FJPROC.2004.840301">10.1109/JPROC.2004.840301</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.fftw.org/fftw-paper-ieee.pdf">http://www.fftw.org/fftw-paper-ieee.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=The+design+and+implementation+of+FFTW3&amp;rft.jtitle=Proceedings+of+the+IEEE&amp;rft.aulast=Frigo%2C+M.&amp;rft.au=Frigo%2C+M.&amp;rft.date=February+2005&amp;rft.volume=93&amp;rft.issue=2&amp;rft.pages=216%E2%80%93231&amp;rft_id=info:doi/10.1109%2FJPROC.2004.840301&amp;rft_id=http%3A%2F%2Fwww.fftw.org%2Ffftw-paper-ieee.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Divide_and_conquer_algorithm"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-10">
<span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text">Radu Rugina and Martin Rinard, "<a rel="nofollow" class="external text" href="http://people.csail.mit.edu/rinard/paper/lcpc00.pdf">Recursion unrolling for divide and conquer programs</a>," in <i>Languages and Compilers for Parallel Computing</i>, chapter 3, pp. 34–48. <i>Lecture Notes in Computer Science</i> vol. 2017 (Berlin: Springer, 2001).</span>
</li>
</ol>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_6">





</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Divide_and_conquer_algorithm&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Divide+and+conquer+algorithm&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Divide_and_conquer_algorithm&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Divide+and+conquer+algorithm&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Divide_and_conquer_algorithm_files/load_002.php" type="text/javascript"></script>
<script src="Divide_and_conquer_algorithm_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>