<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Interpolation search - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Interpolation_search_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 5 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Interpolation_search">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Interpolation_search_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Interpolation_search_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Interpolation_search_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Interpolation_search" selected="selected">English</option><option value="//de.m.wikipedia.org/wiki/Interpolationssuche">Deutsch</option><option value="//fa.m.wikipedia.org/wiki/%D8%AC%D8%B3%D8%AA%D8%AC%D9%88%DB%8C_%D8%AF%D8%B1%D9%88%D9%86%E2%80%8C%DB%8C%D8%A7%D8%A8%DB%8C">فارسی</option><option value="//ru.m.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA">русский</option><option value="//th.m.wikipedia.org/wiki/%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%84%E0%B9%89%E0%B8%99%E0%B9%82%E0%B8%94%E0%B8%A2%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%9B%E0%B8%A3%E0%B8%B0%E0%B8%A1%E0%B8%B2%E0%B8%93%E0%B8%8A%E0%B9%88%E0%B8%A7%E0%B8%87">ไทย</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Interpolation search</h1>			
<p><b>Interpolation search</b> (sometimes referred to as <b>extrapolation search</b>) is an <a href="http://en.m.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a> for <a href="http://en.m.wikipedia.org/wiki/Search_algorithm" title="Search algorithm">searching</a> for a given key value in an indexed array that has been <a href="http://en.m.wikipedia.org/wiki/Collation" title="Collation">ordered</a>
 by the values of the key. It parallels how humans search through a 
telephone book for a particular name, the key value by which the book's 
entries are ordered. In each search step it calculates where in the 
remaining <a href="http://en.m.wikipedia.org/wiki/Search_space" title="Search space">search space</a>
 the sought item might be, based on the key values at the bounds of the 
search space and the value of the sought key, usually via a linear 
interpolation. The key value actually found at this estimated position 
is then compared to the key value being sought. If it is not equal, then
 depending on the comparison, the remaining search space is reduced to 
the part before or after the estimated position. This method will only 
work if calculations on the size of differences between key values are 
sensible.</p>
<p>By comparison, the <a href="http://en.m.wikipedia.org/wiki/Binary_search" title="Binary search" class="mw-redirect">binary search</a>
 always chooses the middle of the remaining search space, discarding one
 half or the other, again depending on the comparison between the key 
value found at the estimated position and the key value sought. The 
remaining search space is reduced to the part before or after the 
estimated position. The <a href="http://en.m.wikipedia.org/wiki/Linear_search" title="Linear search">linear search</a> uses equality only as it compares elements one-by-one from the start, ignoring any sorting.</p>
<p>On average the interpolation search makes about log(log(<i>n</i>)) comparisons (if the elements are uniformly distributed), where <i>n</i>
 is the number of elements to be searched. In the worst case (for 
instance where the numerical values of the keys increase exponentially) 
it can make up to <a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation">O</a>(<i>n</i>) comparisons.</p>
<p>In <span class="new" title="Interpolation-sequential search (page does not exist)">interpolation-sequential search</span>, interpolation is used to find an item near the one being searched for, then <a href="http://en.m.wikipedia.org/wiki/Linear_search" title="Linear search">linear search</a> is used to find the exact item.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Performance">Performance</span></h2><div class="content_block" id="content_1">
<p>Using big-O notation, the performance of the interpolation algorithm on a data set of size <i>N</i> is <i>O</i>(<i>N</i>);
 however under the assumption of a uniform distribution of the data on 
the linear scale used for interpolation, the performance can be shown to
 be <i>O</i>(log log <i>N</i>).<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>3<span>]</span></a></sup>. However, Dynamic Interpolation Search is possible in <i>o</i>(log log <i>n</i>) time using a novel data structure. <sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>4<span>]</span></a></sup></p>
<p>Practical performance of interpolation search depends on whether the 
reduced number of probes is outweighed by the more complicated 
calculations needed for each probe. It can be useful for locating a 
record in a large sorted file on disk, where each probe involves a disk 
seek and is much slower than the interpolation arithmetic.</p>
<p>Index structures like <a href="http://en.m.wikipedia.org/wiki/B-tree" title="B-tree">B-trees</a>
 also reduce the number of disk accesses, and are more often used to 
index on-disk data in part because they can index many types of data and
 can be updated <a href="http://en.m.wikipedia.org/wiki/Online_algorithm" title="Online algorithm">online</a>. Still, interpolation search may be useful when one is forced to search certain sorted but unindexed on-disk datasets.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Adaptation_to_different_datasets">Adaptation to different datasets</span></h2><div class="content_block" id="content_2">
<p>When sort keys for a dataset are uniformly distributed numbers, 
linear interpolation is straightforward to implement and will find an 
index very near the sought value.</p>
<p>On the other hand, for a phone book sorted by name, the 
straightforward approach to interpolation search doesn't apply. The same
 high-level principles can still apply, though: one can estimate a 
name's position in the phone book using the relative frequencies of 
letters in names and use that as a probe location.</p>
<p>Some interpolation search implementations may not work as expected 
when a run of equal key values exists. The simplest implementation of 
interpolation search won't necessarily select the first (or last) 
element of such a run. The interpolation calculation also must be 
written to avoid division by zero.</p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Book-based_searching">Book-based searching</span></h2><div class="content_block" id="content_3">
<p>The conversion of names in a telephone book to some sort of number 
clearly will not provide numbers having a uniform distribution (except 
via immense effort such as sorting the names and calling them name #1, 
name #2, etc.) and further, it is well-known that some names are much 
more common than others (Smith, Jones,) Similarly with dictionaries, 
where there are many more words starting with some letters than others. 
Some publishers go to the effort of preparing marginal annotations or 
even cutting into the side of the pages to show markers for each letter 
so that at a glance a segmented interpolation can be performed.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Sample_implementation">Sample implementation</span></h2><div class="content_block" id="content_4">
<p>The following code example for the <a href="http://en.m.wikipedia.org/wiki/Java_%28programming_language%29" title="Java (programming language)">Java programming language</a>
 is a simple implementation. At each stage it computes a probe position 
then as with the binary search, moves either the upper or lower bound in
 to define a smaller interval containing the sought value. Unlike the 
binary search which guarantees a halving of the interval's size with 
each stage, a misled interpolation may reduce/increase the mid index by 
only one, thus resulting in a worst-case efficiency of O(<i>n</i>).</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1"> <span class="kw1">public</span> <span class="kw4">int</span> interpolationSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> sortedArray, <span class="kw4">int</span> toFind<span class="br0">)</span><span class="br0">{</span>
  <span class="co1">// Returns index of toFind in sortedArray, or -1 if not found</span>
  <span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw4">int</span> high <span class="sy0">=</span> sortedArray.<span class="me1">length</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw4">int</span> mid<span class="sy0">;</span>
 
  <span class="kw1">while</span> <span class="br0">(</span>sortedArray<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">&lt;=</span> toFind <span class="sy0">&amp;&amp;</span> sortedArray<span class="br0">[</span>high<span class="br0">]</span> <span class="sy0">&gt;=</span> toFind<span class="br0">)</span> <span class="br0">{</span>
   mid <span class="sy0">=</span> low <span class="sy0">+</span>
         <span class="br0">(</span><span class="br0">(</span>toFind <span class="sy0">-</span> sortedArray<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span> <span class="sy0">*</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="br0">)</span> <span class="sy0">/</span>
         <span class="br0">(</span>sortedArray<span class="br0">[</span>high<span class="br0">]</span> <span class="sy0">-</span> sortedArray<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">//out of range is possible  here</span>
 
   <span class="kw1">if</span> <span class="br0">(</span>sortedArray<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> toFind<span class="br0">)</span>
    low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
   <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>sortedArray<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&gt;</span> toFind<span class="br0">)</span>
    <span class="co1">// Repetition of the comparison code is forced by syntax limitations.</span>
    high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
   <span class="kw1">else</span>
    <span class="kw1">return</span> mid<span class="sy0">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">if</span> <span class="br0">(</span>sortedArray<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">==</span> toFind<span class="br0">)</span>
   <span class="kw1">return</span> low<span class="sy0">;</span>
  <span class="kw1">else</span>
   <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="co1">// Not found</span>
 <span class="br0">}</span>
</pre>
</div>
</div>
<p>Notice that having probed the list at index <i>mid</i>, for reasons of loop control administration, this code sets either <i>high</i> or <i>low</i> to be not <i>mid</i>
 but an adjacent index, which location is then probed during the next 
iteration. Since an adjacent entry's value will not be much different 
the interpolation calculation is not much improved by this one step 
adjustment, at the cost of an additional reference to distant memory 
such as disc.</p>
<p>Each iteration of the above code requires between five and six 
comparisons (the extra is due to the repetitions needed to distinguish 
the three states of &lt; &gt; and = via binary comparisons in the 
absence of a <a href="http://en.m.wikipedia.org/wiki/Three-way_comparison" title="Three-way comparison">three-way comparison</a>) plus some messy arithmetic, while the <a href="http://en.m.wikipedia.org/wiki/Binary_search_algorithm" title="Binary search algorithm">binary search algorithm</a>
 can be written with one comparison per iteration and uses only trivial 
integer arithmetic. It would thereby search an array of a million 
elements with no more than twenty comparisons (involving accesses to 
slow memory where the array elements are stored); to beat that the 
interpolation search as written above would be allowed no more than 
three iterations.</p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_5">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Linear_search" title="Linear search">Linear search</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Binary_search" title="Binary search" class="mw-redirect">Binary search</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Ternary_search" title="Ternary search">Ternary search</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Hash_table" title="Hash table">Hash table</a></li>
</ul>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_6">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text">Weiss, Mark Allen (2006). <i>Data structures and problem solving using Java</i>, Pearson Addison Wesley</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Armenakis,
 A. C., Garey, L. E., Gupta, R. D., An adaptation of a root finding 
method to searching ordered disk files, BIT Numerical Mathematics, 
Volume 25, Number 4 / December, 1985.</span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Sedgewick, Robert (1990), <i>Algorithms in C</i>, Addison-Wesley</span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Andersson, Arne, and Christer Mattsson. ‘Dynamic Interpolation Search in <i>o</i>(log log <i>n</i>)
 Time’. In Automata, Languages and Programming, edited by Andrzej 
Lingas, Rolf Karlsson, and Svante Carlsson, 700:15–27. Lecture Notes in 
Computer Science. Springer Berlin / Heidelberg, 1993. <a rel="nofollow" class="external free" href="http://dx.doi.org/10.1007/3-540-56939-1_58">http://dx.doi.org/10.1007/3-540-56939-1_58</a>.</span>
</li>
</ol>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li><a rel="nofollow" class="external text" href="http://www.dcc.uchile.cl/%7Erbaeza/handbook/algs/3/322.srch.p.html">Interpolation search</a></li>
<li><a rel="nofollow" class="external text" href="http://www.nist.gov/dads/HTML/interpolationSearch.html">National Institute of Standards and Technology</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eitai/publications/Algorithms/p550-perl.pdf">Interpolation Search - A Log LogN Search</a></li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Interpolation_search&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Interpolation+search&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Interpolation_search&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Interpolation+search&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Interpolation_search_files/load_002.php" type="text/javascript"></script>
<script src="Interpolation_search_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>