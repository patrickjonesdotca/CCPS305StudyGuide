<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Smart pointer - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Smart_pointer_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 10 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Smart_pointer">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Smart_pointer_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Smart_pointer_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Smart_pointer_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Smart_pointer" selected="selected">English</option><option value="//ar.m.wikipedia.org/wiki/%D9%85%D8%A4%D8%B4%D8%B1_%D8%B0%D9%83%D9%8A">العربية</option><option value="//cs.m.wikipedia.org/wiki/Smart_pointer">česky</option><option value="//de.m.wikipedia.org/wiki/Intelligenter_Zeiger">Deutsch</option><option value="//es.m.wikipedia.org/wiki/Puntero_inteligente">español</option><option value="//fr.m.wikipedia.org/wiki/Pointeur_intelligent">français</option><option value="//pl.m.wikipedia.org/wiki/Sprytny_wska%C5%BAnik">polski</option><option value="//pt.m.wikipedia.org/wiki/Ponteiro_inteligente">português</option><option value="//ru.m.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B9_%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C">русский</option><option value="//zh.m.wikipedia.org/wiki/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">中文</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Smart pointer</h1>			
<p>In computer science, a <b>smart pointer</b> is an <a href="http://en.m.wikipedia.org/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a> that simulates a <a href="http://en.m.wikipedia.org/wiki/Pointer_%28computer_programming%29" title="Pointer (computer programming)">pointer</a> while providing additional features, such as <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">automatic garbage collection</a> or <a href="http://en.m.wikipedia.org/wiki/Bounds_checking" title="Bounds checking">bounds checking</a>.
 These additional features are intended to reduce bugs caused by the 
misuse of pointers while retaining efficiency. Smart pointers typically 
keep track of the objects they point to for the purpose of <a href="http://en.m.wikipedia.org/wiki/Memory_management" title="Memory management">memory management</a>. They may also be used to manage other resources, such as network connections and file handles.</p>
<p>The misuse of pointers is a major source of bugs: the constant 
allocation, deallocation and referencing that must be performed by a 
program written using pointers introduces the risk that <a href="http://en.m.wikipedia.org/wiki/Memory_leak" title="Memory leak">memory leaks</a>
 will occur. Smart pointers try to prevent memory leaks by making the 
resource deallocation automatic: when the pointer (or the last in a 
series of pointers) to an object is destroyed, for example because it 
goes out of <a href="http://en.m.wikipedia.org/wiki/Scope_%28programming%29" title="Scope (programming)" class="mw-redirect">scope</a>, the pointed object is destroyed too.</p>
<p>Several types of smart pointers exist. Some work with <a href="http://en.m.wikipedia.org/wiki/Reference_counting" title="Reference counting">reference counting</a>,
 others by assigning ownership of the object to a single pointer. If the
 language supports automatic garbage collection (for instance, <a href="http://en.m.wikipedia.org/wiki/Java_%28programming_language%29" title="Java (programming language)">Java</a> or <a href="http://en.m.wikipedia.org/wiki/C_Sharp_%28programming_language%29" title="C Sharp (programming language)">C#</a>), then smart pointers are unnecessary for memory management, but may still be useful in managing other resources.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="C.2B.2B_smart_pointers">C++ smart pointers</span></h2><div class="content_block" id="content_1">
<p>In <a href="http://en.m.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>, smart pointers may be implemented as a template class that mimics, by means of <a href="http://en.m.wikipedia.org/wiki/Operator_overloading" title="Operator overloading">operator overloading</a>, the behaviour of traditional <a href="http://en.m.wikipedia.org/wiki/Void_pointer" title="Void pointer" class="mw-redirect">(raw) pointers</a>, (e.g. dereferencing, assignment) while providing additional memory management algorithms.</p>
<p>Smart pointers can facilitate <a href="http://en.m.wikipedia.org/wiki/Intentional_programming" title="Intentional programming">intentional programming</a>
 by expressing the use of a pointer in the type itself. For example, if a
 C++ function returns a pointer, there is no way to know whether the 
caller should delete the memory pointed to when the caller is finished 
with the information.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">some_type<span class="sy2">*</span> ambiguous_function<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// What should be done with the result?</span>
</pre>
</div>
</div>
<p>Traditionally, this has been solved with comments, but this can be error-prone. By returning an <code><a href="http://en.m.wikipedia.org/wiki/Auto_ptr" title="Auto ptr">auto_ptr</a></code>,</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">auto_ptr<span class="sy1">&lt;</span>some_type<span class="sy1">&gt;</span> obvious_function1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
</div>
</div>
<p>the function makes explicit that the caller will take ownership of 
the result, and furthermore, that if the caller does nothing, no memory 
will be leaked.</p>
<h3> <span class="mw-headline" id="unique_ptr">unique_ptr</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/C%2B%2B11" title="C++11">C++11</a> provides <code><span class="mw-geshi text source-text">​std::unique_ptr​</span></code>, defined in the header <code><span class="mw-geshi text source-text">​&lt;memory&gt;​</span></code>.</p>
<p>The copy constructor and assignment operators of <code><span class="mw-geshi text source-text">​std::auto_ptr​</span></code> do not actually copy the stored pointer. Instead, they <a href="http://en.m.wikipedia.org/wiki/Auto_ptr#Semantics" title="Auto ptr">transfer it</a>, leaving the previous <code><span class="mw-geshi text source-text">​std::auto_ptr​</span></code> object empty. This was one way to implement strict ownership, so that only one <code><span class="mw-geshi text source-text">​auto_ptr​</span></code> object could own the pointer at any given time. This means that <code><span class="mw-geshi text source-text">​auto_ptr​</span></code> should not be used where copy semantics are needed.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup></p>
<p>C++11 provides support for move semantics; it allows for the explicit
 support of transferring values as a different operation from copying 
them. C++11 also provided support for explicitly preventing an object 
from being copied. Since <code><span class="mw-geshi text source-text">​std::auto_ptr​</span></code> already existed with its copy semantics, it could not be upgraded to be a move-only pointer without breaking <a href="http://en.m.wikipedia.org/wiki/Backwards_compatibility" title="Backwards compatibility" class="mw-redirect">backwards compatibility</a> with existing code. Therefore, C++11 introduced a new pointer type: <code><span class="mw-geshi text source-text">​std::unique_ptr​</span></code>.</p>
<p>This pointer type has its copy constructor and assignment operator 
explicitly deleted; it cannot be copied. It can be moved using <code><span class="mw-geshi text source-text">​std::move​</span></code>, which allows one <code><span class="mw-geshi text source-text">​unique_ptr​</span></code> object to transfer ownership to another.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">unique_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p1<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">unique_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p2 <span class="sy1">=</span> p1<span class="sy4">;</span> <span class="co1">//Compile error.</span>
std<span class="sy4">::</span><span class="me2">unique_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p3 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>p1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Transfers ownership. p3 now owns the memory and p1 is rendered invalid.</span>
 
p3.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Deletes the memory.</span>
p1.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Does nothing.</span>
</pre>
</div>
</div>
<p><code><span class="mw-geshi text source-text">​std::auto_ptr​</span></code> is still available, but it is <a href="http://en.m.wikipedia.org/wiki/Deprecation" title="Deprecation">deprecated</a> under C++11.</p>
<h3> <span class="mw-headline" id="shared_ptr_and_weak_ptr">shared_ptr and weak_ptr</span>
</h3>
<p>C++11 incorporates <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> and <code><span class="mw-geshi text source-text">​weak_ptr​</span></code>, based on versions used by the <a href="http://en.m.wikipedia.org/wiki/Boost_library" title="Boost library" class="mw-redirect">Boost libraries</a>. <a href="http://en.m.wikipedia.org/wiki/C%2B%2B_Technical_Report_1#Smart_pointers" title="C++ Technical Report 1">TR1</a> first introduced them to the standard, but C++11 gives them additional functionality in line with the Boost version.</p>
<p><code><span class="mw-geshi text source-text">​std::shared_ptr​</span></code> represents <a href="http://en.m.wikipedia.org/wiki/Reference_count" title="Reference count" class="mw-redirect">reference counted</a> ownership of a pointer. Each copy of the same <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> owns the same pointer. That pointer will only be freed if all instances of the <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> in the program are destroyed.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p1<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p2 <span class="sy1">=</span> p1<span class="sy4">;</span> <span class="co1">//Both now own the memory.</span>
 
p1.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Memory still exists, due to p2.</span>
p2.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Deletes the memory, since no one else owns the memory.</span>
</pre>
</div>
</div>
<p>A <code><span class="mw-geshi text source-text">​std::shared_ptr​</span></code> uses reference counting, so <a href="http://en.m.wikipedia.org/wiki/Reference_count#Dealing_with_reference_cycles" title="Reference count" class="mw-redirect">circular references</a> are potentially a problem. To break up cycles, <code><span class="mw-geshi text source-text">​std::weak_ptr​</span></code> can be used to access the stored object. The stored object will be deleted if the only references to the object are <code><span class="mw-geshi text source-text">​weak_ptr​</span></code> references. <code><span class="mw-geshi text source-text">​weak_ptr​</span></code> therefore does not ensure that the object will continue to exist, but it can ask for the resource.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p1<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">weak_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> wp1 <span class="sy1">=</span> p1<span class="sy4">;</span> <span class="co1">//p1 owns the memory.</span>
 
<span class="br0">{</span>
  std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p2 <span class="sy1">=</span> wp1.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Now p1 and p2 own the memory.</span>
  <span class="kw1">if</span><span class="br0">(</span>p2<span class="br0">)</span> <span class="co1">//Always check to see if the memory still exists</span>
  <span class="br0">{</span> 
    <span class="co1">//Do something with p2</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="co1">//p2 is destroyed. Memory is owned by p1.</span>
 
p1.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Memory is deleted.</span>
 
std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p3 <span class="sy1">=</span> wp1.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//Memory is gone, so we get an empty shared_ptr.</span>
<span class="kw1">if</span><span class="br0">(</span>p3<span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">//Will not execute this.</span>
<span class="br0">}</span>
</pre>
</div>
</div>
<h4> <span class="mw-headline" id="Concurrency_issues">Concurrency issues</span>
</h4>
<p>Operations that change the reference count, due to copying or destroying <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> or <code><span class="mw-geshi text source-text">​weak_ptr​</span></code> objects, do not provoke data <a href="http://en.m.wikipedia.org/wiki/Race_condition" title="Race condition">race conditions</a>. This means that multiple threads can safely store <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> or <code><span class="mw-geshi text source-text">​weak_ptr​</span></code>
 objects that reference the same object. This only protects the 
reference count itself; it does not protect the object being stored by 
the smart pointer.</p>
<p>The above only applies when multiple threads have their own <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> instances that are referring to the same object. In cases where multiple threads are accessing the same <code><span class="mw-geshi text source-text">​shared_ptr​</span></code> instance, C++11 provides a number of <a href="http://en.m.wikipedia.org/wiki/Atomic_%28computer_science%29" title="Atomic (computer science)" class="mw-redirect">atomic functions</a> for accessing and manipulating the <code><span class="mw-geshi text source-text">​shared_ptr​</span></code>.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_2">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/RAII" title="RAII" class="mw-redirect">RAII (Resource Acquisition Is Initialization)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Auto_ptr" title="Auto ptr">auto_ptr</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Opaque_pointer" title="Opaque pointer">Opaque pointer</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Reference_%28computer_science%29" title="Reference (computer science)">Reference</a></li>
<li>The <a href="http://en.m.wikipedia.org/wiki/Boost_library" title="Boost library" class="mw-redirect">Boost library</a> includes a reference-counting and intrusively counted smart pointer implementation for C++</li>
</ul>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_3">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external autonumber" href="https://www.securecoding.cert.org/confluence/display/cplusplus/MEM00-CPP.+Don%27t+use+auto_ptr+where+copy+semantics+might+be+expected">[1]</a></span>
</li>
</ol>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_4">
<ul>
<li>Sample chapter "<a rel="nofollow" class="external text" href="http://www.informit.com/articles/article.aspx?p=25264">Smart Pointers</a>" from the book <i><a href="http://en.m.wikipedia.org/wiki/Modern_C%2B%2B_Design" title="Modern C++ Design">Modern C++ Design: Generic Programming and Design Patterns Applied</a></i> by <a href="http://en.m.wikipedia.org/wiki/Andrei_Alexandrescu" title="Andrei Alexandrescu">Andrei Alexandrescu</a>, Addison-Wesley, 2001.</li>
<li>Code example "<a rel="nofollow" class="external text" href="http://www.josuttis.com/libbook/cont/countptr.hpp.html">countptr.hpp</a>" from the book <i><a rel="nofollow" class="external text" href="http://www.josuttis.com/libbook/">The C++ Standard Library - A Tutorial and Reference</a></i> by <span class="new" title="Nicolai M. Josuttis (page does not exist)">Nicolai M. Josuttis</span>
</li>
<li>"<a rel="nofollow" class="external text" href="http://boost.org/libs/smart_ptr/smart_ptr.htm">Boost Smart Pointers</a>"</li>
<li>Article "<a rel="nofollow" class="external text" href="http://www.drdobbs.com/184403837/">The New C++: Smart(er) Pointers</a>" by <a href="http://en.m.wikipedia.org/wiki/Herb_Sutter" title="Herb Sutter">Herb Sutter</a> August 1, 2002</li>
<li>"<a rel="nofollow" class="external text" href="http://ootips.org/yonat/4dev/smart-pointers.html">Smart Pointers - What, Why, Which?</a>" by <span class="new" title="Yonat Sharon (page does not exist)">Yonat Sharon</span>
</li>
<li>"<a rel="nofollow" class="external text" href="http://dlugosz.com/Repertoire/refman/Classics/Smart%20Pointers%20Overview.html">Smart Pointers Overview</a>" by <span class="new" title="John M. Dlugosz (page does not exist)">John M. Dlugosz</span>
</li>
<li>The <a rel="nofollow" class="external text" href="http://yasper.sourceforge.net/">YASPER library</a> Yet Another Smart Pointer implementation in C++</li>
<li><a rel="nofollow" class="external text" href="http://barrkel.blogspot.com/2008/09/smart-pointers-in-delphi.html">Smart Pointers in Delphi</a></li>
<li><a rel="nofollow" class="external text" href="http://www.technical-recipes.com/2012/creating-smart-pointers-in-c/">How to create your own smart pointer in C++</a></li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Smart_pointer&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Smart+pointer&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Smart_pointer&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Smart+pointer&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Smart_pointer_files/load_002.php" type="text/javascript"></script>
<script src="Smart_pointer_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>