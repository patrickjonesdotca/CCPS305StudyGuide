<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Reference counting - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Reference_counting_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 10 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Reference_counting">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Reference_counting_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Reference_counting_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Reference_counting_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Reference_counting" selected="selected">English</option><option value="//de.m.wikipedia.org/wiki/Referenzz%C3%A4hlung">Deutsch</option><option value="//es.m.wikipedia.org/wiki/Conteo_de_referencias">español</option><option value="//fa.m.wikipedia.org/wiki/%D9%85%D8%B1%D8%AC%D8%B9_%D8%B4%D9%85%D8%A7%D8%B1%DB%8C">فارسی</option><option value="//ko.m.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D">한국어</option><option value="//it.m.wikipedia.org/wiki/Reference_counting">italiano</option><option value="//ja.m.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88">日本語</option><option value="//pl.m.wikipedia.org/wiki/Zliczanie_referencji">polski</option><option value="//ru.m.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA">русский</option><option value="//uk.m.wikipedia.org/wiki/%D0%9F%D1%96%D0%B4%D1%80%D0%B0%D1%85%D1%83%D0%BD%D0%BE%D0%BA_%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D1%8C">українська</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Reference counting</h1>			
<table class="metadata plainlinks ambox ambox-content ambox-Refimprove" style=""><tbody><tr>
<td class="mbox-image">
<div style="width: 52px;"><img alt="" src="Reference_counting_files/50px-Question_book-new.png" width="50" height="39"></div>
</td>
<td class="mbox-text" style=""><span class="mbox-text-span">This article <b>needs additional <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citing_sources#Inline_citations" title="Wikipedia:Citing sources">citations</a> for <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Verifiability" title="Wikipedia:Verifiability">verification</a></b>. <span class="hide-when-compact">Please help <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Reference_counting&amp;action=edit">improve this article</a> by adding citations to <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Identifying_reliable_sources" title="Wikipedia:Identifying reliable sources">reliable sources</a>. Unsourced material may be <a href="http://en.m.wikipedia.org/wiki/Template:Citation_needed" title="Template:Citation needed">challenged</a> and <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Verifiability#Burden_of_evidence" title="Wikipedia:Verifiability">removed</a>.</span> <small><i>(November 2009)</i></small> </span></td>
</tr></tbody></table>
<p>In <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, <b>reference counting</b>
 is a technique of storing the number of references, pointers, or 
handles to a resource such as an object, block of memory, disk space or 
other resource. It may also refer, more specifically, to a <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">garbage collection</a> algorithm that uses these reference counts to deallocate objects which are no longer referenced.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Use_in_garbage_collection">Use in garbage collection</span></h2><div class="content_block" id="content_1">
<p>As a garbage collection algorithm, reference counting tracks, for each object, a count of the number of <a href="http://en.m.wikipedia.org/wiki/Reference_%28computer_science%29" title="Reference (computer science)">references</a>
 to it held by other objects. If an object's reference count reaches 
zero, the object has become inaccessible, and can be destroyed.</p>
<p>When an object is destroyed, any objects referenced by that object 
also have their reference counts decreased. Because of this, removing a 
single reference can potentially lead to a large number of objects being
 freed. A common modification allows reference counting to be made <a href="http://en.m.wikipedia.org/wiki/Incremental" title="Incremental" class="mw-redirect">incremental</a>:
 instead of destroying an object as soon as its reference count becomes 
zero, it is added to a list of unreferenced objects, and periodically 
(or as needed) one or more items from this list are destroyed.</p>
<p>Simple reference counts require frequent updates. Whenever a 
reference is destroyed or overwritten, the reference count of the object
 it references is decremented, and whenever one is created or copied, 
the reference count of the object it references is incremented.</p>
<p>Reference counting is also used in disk operating systems and 
distributed systems, where full non-incremental tracing garbage 
collection is too time consuming because of the size of the object graph
 and slow access speed.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Advantages_and_disadvantages">Advantages and disadvantages</span></h2><div class="content_block" id="content_2">
<p>The main advantage of reference counting over <a href="http://en.m.wikipedia.org/wiki/Tracing_garbage_collection" title="Tracing garbage collection" class="mw-redirect">tracing garbage collection</a> is that objects are reclaimed <i>as soon as</i>
 they can no longer be referenced, and in an incremental fashion, 
without long pauses for collection cycles and with clearly defined 
lifetime of every object. In real-time applications or systems with 
limited memory, this is important to maintain responsiveness. Reference 
counting is also among the simplest forms of garbage collection to 
implement. It also allows for effective management of non-memory 
resources such as operating system objects, which are often much scarcer
 than memory (tracing GC systems use finalizers for this, but the 
delayed reclamation may cause problems). <a href="http://en.m.wikipedia.org/wiki/Reference_counting#Weighted_reference_counting" title="Reference counting">Weighted reference counts</a> are a good solution for garbage collecting a distributed system.</p>
<p>Tracing garbage collection cycles are triggered too often if the set 
of live objects fills most of the available memory; it requires extra 
space to be efficient. Reference counting performance does not 
deteriorate as the total amount of free space decreases.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup></p>
<p>Reference counts are also useful information to use as input to other
 runtime optimizations. For example, systems that depend heavily on <a href="http://en.m.wikipedia.org/wiki/Immutable_object" title="Immutable object">immutable objects</a> such as many <a href="http://en.m.wikipedia.org/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming languages</a>
 can suffer an efficiency penalty due to frequent copies. However, if we
 know an object has only one reference (as most do in many systems), and
 that reference is lost at the same time that a similar new object is 
created (as in the string append statement <code>str ← str + "a"</code>), we can replace the operation with a mutation on the original object.</p>
<p>Reference counting in naive form has two main disadvantages over the 
tracing garbage collection, both of which require additional mechanisms 
to ameliorate:</p>
<ul>
<li>The frequent updates it involves are a source of inefficiency. While
 tracing garbage collectors can impact efficiency severely via <a href="http://en.m.wikipedia.org/wiki/Context_switch" title="Context switch">context switching</a>
 and cache line faults, they collect relatively infrequently, while 
accessing objects is done continually. Also, less importantly, reference
 counting requires every memory-managed object to reserve space for a 
reference count. In tracing garbage collectors, this information is 
stored implicitly in the references that refer to that object, saving 
space, although tracing garbage collectors, particularly incremental 
ones, can require additional space for other purposes.</li>
<li>The naive algorithm described above can't handle <span id="reference_cycle"></span><span id="reference_cycles">reference cycles</span>,
 an object which refers directly or indirectly to itself. A mechanism 
relying purely on reference counts will never consider cyclic chains of 
objects for deletion, since their reference count is guaranteed to stay 
nonzero. Methods for dealing with this issue exist but can also increase
 the overhead and complexity of reference counting&nbsp;— on the other 
hand, these methods need only be applied to data that might form cycles,
 often a small subset of all data. One such method is the use of <a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">weak references</a>.</li>
</ul>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Graph_interpretation">Graph interpretation</span></h2><div class="content_block" id="content_3">
<p>When dealing with garbage collection schemes, it's often helpful to think of the <b>reference graph</b>, which is a <a href="http://en.m.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a> where the <a href="http://en.m.wikipedia.org/wiki/Vertex_%28graph_theory%29" title="Vertex (graph theory)">vertices</a>
 are objects and there is an edge from an object&nbsp;A to an 
object&nbsp;B if A holds a reference to&nbsp;B. We also have a special 
vertex or vertices representing the local variables and references held 
by the runtime system, and no edges ever go to these nodes, although 
edges can go from them to other nodes.</p>
<p>In this context, the simple reference count of an object is the <a href="http://en.m.wikipedia.org/wiki/In-degree" title="In-degree" class="mw-redirect">in-degree</a>
 of its vertex. Deleting a vertex is like collecting an object. It can 
only be done when the vertex has no incoming edges, so it does not 
affect the out-degree of any other vertices, but it can affect the 
in-degree of other vertices, causing their corresponding objects to be 
collected as well.</p>
<p>The connected component containing the special vertex contains the 
objects that can't be collected, while other connected components of the
 graph only contain garbage. By the nature of reference counting, each 
of these garbage components must contain at least one cycle.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Dealing_with_inefficiency_of_updates">Dealing with inefficiency of updates</span></h2><div class="content_block" id="content_4">
<p>Incrementing and decrementing reference counts every time a reference
 is created or destroyed can significantly impede performance. Not only 
do the operations take time, but they damage <a href="http://en.m.wikipedia.org/wiki/CPU_cache" title="CPU cache">cache</a> performance and can lead to <a href="http://en.m.wikipedia.org/wiki/Pipeline_bubble" title="Pipeline bubble" class="mw-redirect">pipeline bubbles</a>.
 Even read-only operations like calculating the length of a list require
 a large number of reads and writes for reference updates with naive 
reference counting.</p>
<p>One simple technique is for the compiler to combine a number of 
nearby reference updates into one. This is especially effective for 
references which are created and quickly destroyed. Care must be taken, 
however, to put the combined update at the right position so that a 
premature free be avoided.</p>
<p>The Deutsch-Bobrow method of reference counting capitalizes on the 
fact that most reference count updates are in fact generated by 
references stored in local variables. It ignores these references, only 
counting references in data structures, but before an object with 
reference count zero can be deleted, the system must verify with a scan 
of the stack and registers that no other reference to it still exists.</p>
<p>Another technique devised by <a href="http://en.m.wikipedia.org/wiki/Henry_Baker_%28computer_scientist%29" title="Henry Baker (computer scientist)">Henry Baker</a> involves <b>deferred increments</b>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup>
 in which references which are stored in local variables do not 
immediately increment the corresponding reference count, but instead 
defer this until it is necessary. If such a reference is destroyed 
quickly, then there is no need to update the counter. This eliminates a 
large number of updates associated with short-lived references. However,
 if such a reference is copied into a data structure, then the deferred 
increment must be performed at that time. It is also critical to perform
 the deferred increment before the object's count drops to zero, 
resulting in a premature free.</p>
<p>A dramatic decrease in the overhead on counter updates was obtained by Levanoni and <a href="http://en.m.wikipedia.org/wiki/Erez_Petrank" title="Erez Petrank">Petrank</a>.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>3<span>]</span></a></sup><sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>4<span>]</span></a></sup>
 They introduce the update coalescing method which coalesces many of the
 redundant reference count updates. Consider a pointer that in a given 
interval of the execution is updated several times. It first points to 
an object <i>O1</i>, then to an object <i>O2</i>, and so forth until at the end of the interval it points to some object <i>On</i>. A reference counting algorithm would typically execute <i>rc(O1)--</i>, <i>rc(O2)++</i>, <i>rc(O2)--</i>, <i>rc(O3)++</i>, <i>rc(O3)--</i>, ..., <i>rc(On)++</i>.
 But most of these updates are redundant. In order to have the reference
 count properly evaluated at the end of the interval it is enough to 
perform <i>rc(O1)--</i> and <i>rc(On)++</i>. The rest of the updates are
 redundant. Levanoni and Petrank show how to use such update coalescing 
in a reference counting collector. It turns out that when using update 
coalescing with an appropriate treatment of new objects, more than 99% 
of the counter updates are eliminated for typical Java benchmarks. In 
addition, the need for atomic operations during pointer updates on 
parallel processors is eliminated. Finally, they present an enhanced 
algorithm that may run concurrently with multithreaded applications 
employing only fine synchronization. The details appear in the paper, 
see <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf">paper</a>.</p>
<p>Blackburn and McKinley's ulterior reference counting<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>5<span>]</span></a></sup>
 combines deferred reference counting with a copying nursery, observing 
that the majority of pointer mutations occur in young objects. This 
algorithm achieves throughput comparable with the fastest generational 
copying collectors with the low bounded pause times of reference 
counting.</p>
<p>More work on improving performance of reference counting collectors<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text in the vicinity of this tag needs clarification or removal of jargon from September 2009">clarification needed</span></a></i>]</sup> can be found in <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2006/PHD/PHD-2006-10.pdf">Paz's Ph.D thesis</a>. In particular, he advocates the use of <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/ao-cc.pdf">age oriented collectors</a> and <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/rc-prefetch-cc07.pdf">prefetching</a>.</p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="Dealing_with_reference_cycles">Dealing with reference cycles</span></h2><div class="content_block" id="content_5">
<p>There are a variety of ways of handling the problem of <a href="http://en.m.wikipedia.org/wiki/Cycle_detection_%28graph_theory%29" title="Cycle detection (graph theory)" class="mw-redirect">detecting</a>
 and collecting reference cycles. One is that a system may explicitly 
forbid reference cycles. In some systems like filesystems this is a 
common solution. Another example is the <a href="http://en.m.wikipedia.org/wiki/Cocoa_%28API%29" title="Cocoa (API)">Cocoa</a>
 framework, which recommends avoiding reference cycles by using "strong"
 (counted) references for "parent-to-child" references, and "weak" 
(non-counted) references for "child-to-parent" references.<a rel="nofollow" class="external autonumber" href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmObjectOwnership.html#//apple_ref/doc/uid/20000043-1044135-BCICCFAE">[1]</a>
 Cycles are also sometimes ignored in systems with short lives and a 
small amount of cyclic garbage, particularly when the system was 
developed using a methodology of avoiding cyclic data structures 
wherever possible, typically at the expense of efficiency.</p>
<p>Another solution is to periodically use a tracing <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">garbage collector</a>
 to reclaim cycles. Since cycles typically constitute a relatively small
 amount of reclaimed space, the collection cycles can be spaced much 
farther apart than with an ordinary tracing garbage collector.</p>
<p>Bacon describes a cycle-collection algorithm for reference counting 
systems with some similarities to tracing systems, including the same 
theoretical time bounds, but that takes advantage of reference count 
information to run much more quickly and with less cache damage. It's 
based on the observation that an object cannot appear in a cycle until 
its reference count is decremented to a nonzero value. All objects which
 this occurs to are put on a <i>roots</i> list, and then periodically 
the program searches through the objects reachable from the roots for 
cycles. It knows it has found a cycle when decrementing all the 
reference counts on a cycle of references brings them all down to zero. 
An enhanced version of this algorithm by Paz et al.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>6<span>]</span></a></sup>
 is able to run concurrently with other operations and improve its 
efficiency by using the update coalescing method of Levanoni and 
Petrank. See the <a rel="nofollow" class="external text" href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf">paper</a> for more.</p>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="Variants_of_reference_counting">Variants of reference counting</span></h2><div class="content_block" id="content_6">
<p>Although it's possible to augment simple reference counts in a 
variety of ways, often a better solution can be found by performing 
reference counting in a fundamentally different way. Here we describe 
some of the variants on reference counting and their benefits and 
drawbacks.</p>
<h3> <span class="mw-headline" id="Weighted_reference_counting">Weighted reference counting</span>
</h3>
<p>In weighted reference counting, we assign each reference a <i>weight</i>,
 and each object tracks not the number of references referring to it, 
but the total weight of the references referring to it. The initial 
reference to a newly-created object has a large weight, such as 2<sup>16</sup>.
 Whenever this reference is copied, half of the weight goes to the new 
reference, and half of the weight stays with the old reference. Because 
the total weight does not change, the object's reference count does not 
need to be updated.</p>
<p>Destroying a reference decrements the total weight by the weight of 
that reference. When the total weight becomes zero, all references have 
been destroyed. If an attempt is made to copy a reference with a weight 
of 1, we have to "get more weight" by adding to the total weight and 
then adding this new weight to our reference, and then split it.</p>
<p>The property of not needing to access a reference count when a 
reference is copied is particularly helpful when the object's reference 
count is expensive to access, for example because it is in another 
process, on disk, or even across a network. It can also help increase 
concurrency by avoiding many threads locking a reference count to 
increase it. Thus, weighted reference counting is most useful in 
parallel, multiprocess, database, or distributed applications.</p>
<p>The primary problem with simple weighted reference counting is that 
destroying a reference still requires accessing the reference count, and
 if many references are destroyed this can cause the same bottlenecks we
 seek to avoid. Some adaptations of weighted reference counting seek to 
avoid this by attempting to give weight back from a dying reference to 
one which is still active.</p>
<p>Weighted reference counting was independently devised by Bevan, in the paper <i>Distributed garbage collection using reference counting</i>, and Watson, in the paper <i>An efficient garbage collection scheme for parallel computer architectures</i>, both in 1987.</p>
<h3> <span class="mw-headline" id="Indirect_reference_counting">Indirect reference counting</span>
</h3>
<p>In indirect reference counting, it is necessary to keep track of whom
 the reference was obtained from. This means that two references are 
kept to the object: a direct one which is used for invocations; and an 
indirect one which forms part of a diffusion tree, such as in the <a href="http://en.m.wikipedia.org/wiki/Dijkstra-Scholten_algorithm" title="Dijkstra-Scholten algorithm" class="mw-redirect">Dijkstra-Scholten algorithm</a>, which allows a garbage collector to identify dead objects. This approach prevents an object from being discarded prematurely.</p>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="Examples_of_use">Examples of use</span></h2><div class="content_block" id="content_7">
<h3> <span class="mw-headline" id="COM">COM</span>
</h3>
<p>Microsoft's <a href="http://en.m.wikipedia.org/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> (COM) makes pervasive use of reference counting. In fact, the three methods that all COM objects must provide (in the <a href="http://en.m.wikipedia.org/wiki/IUnknown" title="IUnknown">IUnknown</a> interface) all increment or decrement the reference count. Much of the <a href="http://en.m.wikipedia.org/wiki/Windows_Shell" title="Windows Shell" class="mw-redirect">Windows Shell</a> and many Windows applications (including <a href="http://en.m.wikipedia.org/wiki/Microsoft_Internet_Explorer" title="Microsoft Internet Explorer" class="mw-redirect">MS Internet Explorer</a>, <a href="http://en.m.wikipedia.org/wiki/Microsoft_Office" title="Microsoft Office">MS Office</a>,
 and countless third-party products) are built on COM, demonstrating the
 viability of reference counting in large-scale systems.</p>
<p>One primary motivation for reference counting in COM is to enable 
interoperability across different programming languages and runtime 
systems. A client need only know how to invoke object methods in order 
to manage object life cycle; thus, the client is completely abstracted 
from whatever memory allocator the implementation of the COM object 
uses. As a typical example, a <a href="http://en.m.wikipedia.org/wiki/Visual_Basic" title="Visual Basic">Visual Basic</a>
 program using a COM object is agnostic towards whether that object was 
allocated (and must later be deallocated) by a C++ allocator or another 
Visual Basic component.</p>
<p>However, this support for heterogeneity has a major cost: it requires
 correct reference count management by all parties involved. While 
high-level languages like Visual Basic manage reference counts 
automatically, C/C++ programmers are entrusted to increment and 
decrement reference counts at the appropriate time. C++ programs can and
 should avoid the task of managing reference counts manually by using <a href="http://en.m.wikipedia.org/wiki/Smart_pointer" title="Smart pointer">smart pointers</a>,
 usually a CComPtr. Bugs caused by incorrect reference counting in COM 
systems are notoriously hard to resolve, especially because the error 
may occur in an opaque, third-party component.</p>
<p>Microsoft has abandoned reference counting in favor of tracing garbage collection for the <a href="http://en.m.wikipedia.org/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>.</p>
<h3> <span class="mw-headline" id="Cocoa">Cocoa</span>
</h3>
<p>Apple's <a href="http://en.m.wikipedia.org/wiki/Cocoa_%28API%29" title="Cocoa (API)">Cocoa</a> framework (and related frameworks, such as <a href="http://en.m.wikipedia.org/wiki/Core_Foundation" title="Core Foundation">Core Foundation</a>) use manual reference counting, much like <a href="http://en.m.wikipedia.org/wiki/Component_Object_Model" title="Component Object Model">COM</a>. However, as of <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X_v10.5" title="Mac OS X v10.5" class="mw-redirect">Mac OS X v10.5</a>, Cocoa when used with <a href="http://en.m.wikipedia.org/wiki/Objective-C" title="Objective-C">Objective-C</a> 2.0 also has automatic garbage collection. Apple's <a href="http://en.m.wikipedia.org/wiki/Cocoa_Touch" title="Cocoa Touch">Cocoa Touch</a> framework, used on its <a href="http://en.m.wikipedia.org/wiki/IOS_%28Apple%29" title="IOS (Apple)" class="mw-redirect">iOS</a>
 devices, also uses manual reference counting, and does not support 
automatic garbage collection, though automatic reference counting was 
added in <a href="http://en.m.wikipedia.org/wiki/IOS_%28Apple%29" title="IOS (Apple)" class="mw-redirect">iOS</a> 5<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>7<span>]</span></a></sup> and <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X_10.7" title="Mac OS X 10.7" class="mw-redirect">Mac OS X 10.7</a>.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>8<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Delphi">Delphi</span>
</h3>
<p>One language that uses reference counting for garbage collection is <a href="http://en.m.wikipedia.org/wiki/Delphi_programming_language" title="Delphi programming language" class="mw-redirect">Delphi</a>.
 Delphi is not a completely garbage collected language, in that 
user-defined types must still be manually allocated and deallocated. It 
does provide automatic collection, however, for a few built-in types, 
such as strings, dynamic arrays, and interfaces, for ease of use and to 
simplify the generic database functionality. It is up to the programmer 
to decide whether to use the built-in types or not; Delphi programmers 
have complete access to low-level memory management like in C/C++. So 
all potential cost of Delphi's reference counting can, if desired, be 
easily circumvented.</p>
<p>Some of the reasons reference counting may have been preferred to other forms of garbage collection in Delphi include:</p>
<ul>
<li>The general benefits of reference counting, such as prompt collection.</li>
<li>Cycles either cannot occur or do not occur in practice because all 
of the small set of garbage-collected built-in types are not arbitrarily
 nestable.</li>
<li>The overhead in code size required for reference counting is very 
small (typically a single LOCK INC or LOCK DEC instruction, which 
ensures atomicity in any environment), and no separate thread of control
 is needed for collection as would be needed for a tracing garbage 
collector.</li>
<li>Many instances of the most commonly used garbage-collected type, the
 string, have a short lifetime, since they are typically intermediate 
values in string manipulation.</li>
<li>The reference count of a string is checked before mutating a string.
 This allows reference count 1 strings to be mutated directly whilst 
higher reference count strings are copied before mutation. This allows 
the general behaviour of old style pascal strings to be preserved whilst
 eliminating the cost of copying the string on every assignment.</li>
<li>Because garbage-collection is only done on built-in types, reference
 counting can be efficiently integrated into the library routines used 
to manipulate each datatype, keeping the overhead needed for updating of
 reference counts low. Moreover a lot of the runtime library is in 
handoptimized assembler.</li>
</ul>
<h3> <span class="mw-headline" id="GObject">GObject</span>
</h3>
<p>The <a href="http://en.m.wikipedia.org/wiki/GObject" title="GObject">GObject</a> object-oriented programming framework implements reference counting on its base types, including <a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">weak references</a>. Reference incrementing and decrementing uses <a href="http://en.m.wikipedia.org/wiki/Atomic_operation" title="Atomic operation" class="mw-redirect">atomic operations</a>
 for thread safety. A significant amount of the work in writing bindings
 to GObject from high-level languages lies in adapting GObject reference
 counting to work with the language's own memory management system.</p>
<h3> <span class="mw-headline" id="PHP">PHP</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/PHP" title="PHP">PHP</a> uses
 a reference counting mechanism for its internal variable management. 
Since PHP 5.3, it implements the algorithm from Bacon's above mentioned 
paper. PHP allows you to turn on and off the cycle collection with 
user-level functions. It also allows you to manually force the purging 
mechanism to be run.</p>
<h3> <span class="mw-headline" id="Python">Python</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Python_%28programming_language%29" title="Python (programming language)">Python</a> also uses reference counting and offers cycle detection as well. See <a rel="nofollow" class="external text" href="http://docs.python.org/extending/extending.html#reference-counts">Extending and Embedding the Python Interpreter</a>.</p>
<h3> <span class="mw-headline" id="Squirrel">Squirrel</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Squirrel_programming_language" title="Squirrel programming language" class="mw-redirect">Squirrel</a>
 also uses reference counting and offers cycle detection as well. This 
tiny language is relatively unknown outside the video game industry; 
however, it is a concrete example of how reference counting can be 
practical and efficient (especially in realtime environments).<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from April 2009">citation needed</span></a></i>]</sup></p>
<h3> <span class="mw-headline" id="Tcl">Tcl</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Tcl" title="Tcl">Tcl</a> 8 uses reference counting for memory management of values (<span class="new" title="Tcl Obj (page does not exist)">Tcl Obj</span> <a href="http://en.m.wikipedia.org/wiki/Struct" title="Struct">structs</a>).
 Since Tcl's values are immutable, reference cycles are impossible to 
form and no cycle detection scheme is needed. Operations that would 
replace a value with a modified copy are generally optimized to instead 
modify the original when its reference count indicates it to be 
unshared. The references are counted at a data structure level, so the 
problems with very frequent updates discussed above do not arise.</p>
<h3> <span class="mw-headline" id="Disk_operating_systems">Disk operating systems</span>
</h3>
<p>Many disk operating systems maintain a count of the number of 
references to any particular block or file. When the count falls to 
zero, the file can be safely deallocated. In addition, while references 
can still be made from <a href="http://en.m.wikipedia.org/wiki/Directory_%28file_systems%29" title="Directory (file systems)" class="mw-redirect">directories</a>,
 some Unixes allow that the referencing can be solely made by live 
processes, and there can be files that do not exist in the file system 
hierarchy.</p>
</div><a id="anchor_7" href="#section_7" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_8"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_8">
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text"><span class="citation book">Wilson, Paul R.. <a rel="nofollow" class="external text" href="ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps">"Uniprocessor Garbage Collection Techniques"</a>. <i>Proceedings of the International Workshop on Memory Management</i>. London, UK: Springer-Verlag. pp.&nbsp;1–42. <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/354055940X" class="internal mw-magiclink-isbn">ISBN 3-540-55940-X</a><span class="printonly">. <a rel="nofollow" class="external free" href="ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps">ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps</a></span><span class="reference-accessdate">. Retrieved December 5, 2009</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Uniprocessor+Garbage+Collection+Techniques&amp;rft.atitle=Proceedings+of+the+International+Workshop+on+Memory+Management&amp;rft.aulast=Wilson&amp;rft.aufirst=Paul+R.&amp;rft.au=Wilson%2C%26%2332%3BPaul+R.&amp;rft.pages=pp.%26nbsp%3B1%E2%80%9342&amp;rft.place=London%2C+UK&amp;rft.pub=Springer-Verlag&amp;rft_id=ftp%3A%2F%2Fftp.cs.utexas.edu%2Fpub%2Fgarbage%2Fgcsurvey.ps&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span> Section 2.1.</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Henry_Baker_%28computer_scientist%29" title="Henry Baker (computer scientist)">Henry Baker</a> (September 1994). <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/baker94minimizing.html">"Minimizing Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures"</a>. <i><a href="http://en.m.wikipedia.org/wiki/ACM_SIGPLAN_Notices" title="ACM SIGPLAN Notices" class="mw-redirect">ACM SIGPLAN Notices</a></i> <b>29</b> (9): 38–43. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F185009.185016">10.1145/185009.185016</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://citeseer.ist.psu.edu/baker94minimizing.html">http://citeseer.ist.psu.edu/baker94minimizing.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Minimizing+Reference+Count+Updating+with+Deferred+and+Anchored+Pointers+for+Functional+Data+Structures&amp;rft.jtitle=%5B%5BACM+SIGPLAN+Notices%5D%5D&amp;rft.aulast=%5B%5BHenry+Baker+%28computer+scientist%29%7CHenry+Baker%5D%5D&amp;rft.au=%5B%5BHenry+Baker+%28computer+scientist%29%7CHenry+Baker%5D%5D&amp;rft.date=September+1994&amp;rft.volume=29&amp;rft.issue=9&amp;rft.pages=38%E2%80%9343&amp;rft_id=info:doi/10.1145%2F185009.185016&amp;rft_id=http%3A%2F%2Fciteseer.ist.psu.edu%2Fbaker94minimizing.html&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Yossi Levanoni, <a href="http://en.m.wikipedia.org/wiki/Erez_Petrank" title="Erez Petrank">Erez Petrank</a> (2001). <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.ps">"An on-the-fly reference-counting garbage collector for java"</a>. <i>Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications</i>. <a href="http://en.m.wikipedia.org/wiki/OOPSLA" title="OOPSLA">OOPSLA</a> 2001. pp.&nbsp;367--380. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F504282.504309">10.1145/504282.504309</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.ps">http://www.cs.technion.ac.il/~erez/Papers/refcount.ps</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=An+on-the-fly+reference-counting+garbage+collector+for+java&amp;rft.atitle=Proceedings+of+the+16th+ACM+SIGPLAN+conference+on+Object-oriented+programming%2C+systems%2C+languages%2C+and+applications&amp;rft.aulast=Yossi+Levanoni%2C+%5B%5BErez+Petrank%5D%5D&amp;rft.au=Yossi+Levanoni%2C+%5B%5BErez+Petrank%5D%5D&amp;rft.date=2001&amp;rft.pages=pp.%26nbsp%3B367--380&amp;rft_id=info:doi/10.1145%2F504282.504309&amp;rft_id=http%3A%2F%2Fwww.cs.technion.ac.il%2F%7Eerez%2FPapers%2Frefcount.ps&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation Journal">Yossi Levanoni, <a href="http://en.m.wikipedia.org/wiki/Erez_Petrank" title="Erez Petrank">Erez Petrank</a> (2006). <a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.ps">"An on-the-fly reference-counting garbage collector for java"</a>. <i>ACM Trans. Program. Lang. Syst.</i> <b>28</b>: 31–69. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F1111596.1111597">10.1145/1111596.1111597</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.ps">http://www.cs.technion.ac.il/~erez/Papers/refcount.ps</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=An+on-the-fly+reference-counting+garbage+collector+for+java&amp;rft.jtitle=ACM+Trans.+Program.+Lang.+Syst.&amp;rft.aulast=Yossi+Levanoni%2C+%5B%5BErez+Petrank%5D%5D&amp;rft.au=Yossi+Levanoni%2C+%5B%5BErez+Petrank%5D%5D&amp;rft.date=2006&amp;rft.volume=28&amp;rft.pages=31%E2%80%9369&amp;rft_id=info:doi/10.1145%2F1111596.1111597&amp;rft_id=http%3A%2F%2Fwww.cs.technion.ac.il%2F%7Eerez%2FPapers%2Frefcount.ps&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-4">
<span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Stephen Blackburn, Kathryn McKinley (2003). <a rel="nofollow" class="external text" href="http://cs.anu.edu.au/%7ESteve.Blackburn/pubs/abstracts.html#urc-oopsla-2003">"Ulterior Reference Counting: Fast Garbage Collection without a Long Wait"</a>. <i>Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications</i>. <a href="http://en.m.wikipedia.org/wiki/OOPSLA" title="OOPSLA">OOPSLA</a> 2003. pp.&nbsp;344–358. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F949305.949336">10.1145/949305.949336</a>. <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/1581137125" class="internal mw-magiclink-isbn">ISBN 1-58113-712-5</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://cs.anu.edu.au/%7ESteve.Blackburn/pubs/abstracts.html#urc-oopsla-2003">http://cs.anu.edu.au/~Steve.Blackburn/pubs/abstracts.html#urc-oopsla-2003</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Ulterior+Reference+Counting%3A+Fast+Garbage+Collection+without+a+Long+Wait&amp;rft.atitle=Proceedings+of+the+18th+annual+ACM+SIGPLAN+conference+on+Object-oriented+programing%2C+systems%2C+languages%2C+and+applications&amp;rft.aulast=Stephen+Blackburn%2C+Kathryn+McKinley&amp;rft.au=Stephen+Blackburn%2C+Kathryn+McKinley&amp;rft.date=2003&amp;rft.pages=pp.%26nbsp%3B344%E2%80%93358&amp;rft_id=info:doi/10.1145%2F949305.949336&amp;rft_id=http%3A%2F%2Fcs.anu.edu.au%2F%7ESteve.Blackburn%2Fpubs%2Fabstracts.html%23urc-oopsla-2003&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation book">Harel Paz, David F. Bacon, Elliot K. Kolodner, <a href="http://en.m.wikipedia.org/wiki/Erez_Petrank" title="Erez Petrank">Erez Petrank</a>, V. T. Rajan (2007). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?doid=1255450.1255453">"An efficient on-the-fly cycle collection"</a>. <i>ACM Transactions on Programming Languages and Systems (TOPLAS)</i>. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F1255450.1255453">10.1145/1255450.1255453</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?doid=1255450.1255453">http://portal.acm.org/citation.cfm?doid=1255450.1255453</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=An+efficient+on-the-fly+cycle+collection&amp;rft.atitle=ACM+Transactions+on+Programming+Languages+and+Systems+%28TOPLAS%29&amp;rft.aulast=Harel+Paz%2C+David+F.+Bacon%2C+Elliot+K.+Kolodner%2C+%5B%5BErez+Petrank%5D%5D%2C+V.+T.+Rajan&amp;rft.au=Harel+Paz%2C+David+F.+Bacon%2C+Elliot+K.+Kolodner%2C+%5B%5BErez+Petrank%5D%5D%2C+V.+T.+Rajan&amp;rft.date=2007&amp;rft_id=info:doi/10.1145%2F1255450.1255453&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fdoid%3D1255450.1255453&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://developer.apple.com/technologies/ios5/">http://developer.apple.com/technologies/ios5/</a></span>
</li>
<li id="cite_note-7">
<span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://developer.apple.com/library/mac/#releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_7.html#//apple_ref/doc/uid/TP40010355-SW62">http://developer.apple.com/library/mac/#releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_7.html#//apple_ref/doc/uid/TP40010355-SW62</a></span>
</li>
</ol>
</div>
<p><span class="citation foldoc">This article is based on material taken from the <a href="http://en.m.wikipedia.org/wiki/Free_On-line_Dictionary_of_Computing" title="Free On-line Dictionary of Computing">Free On-line Dictionary of Computing</a> prior to 1 November 2008 and incorporated under the "relicensing" terms of the <a href="http://en.m.wikipedia.org/wiki/GNU_Free_Documentation_License" title="GNU Free Documentation License">GFDL</a>, version 1.3 or later.</span></p>
</div><a id="anchor_8" href="#section_8" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_9"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_9">
<ul>
<li><a rel="nofollow" class="external text" href="http://www.memorymanagement.org/articles/recycle.html#reference">The Memory Manager Reference: Beginner's Guide: Recycling: Reference Counts</a></li>
<li><a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.955"><i>Minimizing Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures</i>, Henry G. Baker</a></li>
<li><a rel="nofollow" class="external text" href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf"><i>Concurrent Cycle Collection in Reference Counted Systems</i>, David F. Bacon</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf"><i>An On-the-Fly Reference-Counting Garbage Collector for Java</i>, Yossi Levanoni and Erez Petrank</a></li>
<li><a rel="nofollow" class="external text" href="http://www.drdobbs.com/architecture-and-design/184401888"><i>Atomic Reference Counting Pointers: A lock-free, async-free, thread-safe, multiprocessor-safe reference counting pointer</i>, Kirk Reinholtz</a></li>
<li><a rel="nofollow" class="external text" href="http://www.python.org/doc/2.4.2/ext/refcounts.html"><i>Extending and Embedding the Python Interpreter: Extending Python with C or C++: Reference Counts</i>, Guido van Rossum</a></li>
</ul>
<table class="navbox" style="border-spacing: 0pt;" cellspacing="0"><tbody><tr>
<td style="padding: 2px;">
<table class="nowraplinks hlist collapsible autocollapse navbox-inner" style="border-spacing: 0pt; background: none repeat scroll 0% 0% transparent; color: inherit;" cellspacing="0">
<tbody><tr>
<th scope="col" style="" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:Memory_management_navbox" title="Template:Memory management navbox"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:Memory_management_navbox" title="Template talk:Memory management navbox"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:Memory_management_navbox&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;"><a href="http://en.m.wikipedia.org/wiki/Memory_management" title="Memory management">Memory management</a></div>
</th>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Manual_memory_management" title="Manual memory management">Manual memory management</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Delete_%28C%2B%2B%29" title="Delete (C++)">delete (C++)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/C_dynamic_memory_allocation" title="C dynamic memory allocation">C dynamic memory allocation</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/New_%28C%2B%2B%29" title="New (C++)">new (C++)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Static_memory_allocation" title="Static memory allocation">Static memory allocation</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">Virtual memory</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Demand_paging" title="Demand paging">Demand paging</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Page_table" title="Page table">Page table</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Paging" title="Paging">Paging</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Hardware</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Memory_management_unit" title="Memory management unit">Memory management unit</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">Translation lookaside buffer</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">Garbage collection</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Garbage_%28computer_science%29" title="Garbage (computer science)">Garbage</a></li>
<li><strong class="selflink">Reference counting</strong></li>
<li><a href="http://en.m.wikipedia.org/wiki/Strong_reference" title="Strong reference">Strong reference</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">Weak reference</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Memory_segmentation" title="Memory segmentation">Memory segmentation</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Protected_mode" title="Protected mode">Protected mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Real_mode" title="Real mode">Real mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Virtual_8086_mode" title="Virtual 8086 mode">Virtual 8086 mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/X86_memory_segmentation" title="X86 memory segmentation">x86 memory segmentation</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Memory_safety" title="Memory safety">Memory safety</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Buffer_overflow" title="Buffer overflow">Buffer overflow</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Dangling_pointer" title="Dangling pointer">Dangling pointer</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Stack_overflow" title="Stack overflow">Stack overflow</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Issues</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Fragmentation_%28computer%29" title="Fragmentation (computer)" class="mw-redirect">Fragmentation</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Memory_leak" title="Memory leak">Memory leak</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Unreachable_memory" title="Unreachable memory">Unreachable memory</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Other</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Automatic_variable" title="Automatic variable">Automatic variable</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/International_Symposium_on_Memory_Management" title="International Symposium on Memory Management">International Symposium on Memory Management</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Region-based_memory_management" title="Region-based memory management">Region-based memory management</a></li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</td>
</tr></tbody></table>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Reference_counting&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Reference+counting&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Reference_counting&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Reference+counting&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Reference_counting_files/load_002.php" type="text/javascript"></script>
<script src="Reference_counting_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>