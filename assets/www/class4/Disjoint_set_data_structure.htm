<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Disjoint-set data structure - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Disjoint-set_data_structure_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 10 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Disjoint-set_data_structure_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Disjoint-set_data_structure_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Disjoint-set_data_structure_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Disjoint-set_data_structure" selected="selected">English</option><option value="//de.m.wikipedia.org/wiki/Union-Find-Struktur">Deutsch</option><option value="//fa.m.wikipedia.org/wiki/%D9%85%D8%AC%D9%85%D9%88%D8%B9%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D9%85%D8%AC%D8%B2%D8%A7_(%D8%B3%D8%A7%D8%AE%D8%AA%D9%85%D8%A7%D9%86_%D8%AF%D8%A7%D8%AF%D9%87)">فارسی</option><option value="//fr.m.wikipedia.org/wiki/Union-Find">français</option><option value="//it.m.wikipedia.org/wiki/Mfset">italiano</option><option value="//ja.m.wikipedia.org/wiki/%E7%B4%A0%E9%9B%86%E5%90%88%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0">日本語</option><option value="//pl.m.wikipedia.org/wiki/Struktura_zbior%C3%B3w_roz%C5%82%C4%85cznych">polski</option><option value="//ru.m.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BD%D0%B5%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D1%85%D1%81%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2">русский</option><option value="//vi.m.wikipedia.org/wiki/C%E1%BA%A5u_tr%C3%BAc_d%E1%BB%AF_li%E1%BB%87u_cho_c%C3%A1c_t%E1%BA%ADp_h%E1%BB%A3p_kh%C3%B4ng_giao_nhau">Tiếng Việt</option><option value="//zh.m.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">中文</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Disjoint-set data structure</h1>			
<p>In <a href="http://en.m.wikipedia.org/wiki/Computing" title="Computing">computing</a>, a <b>disjoint-set data structure</b> is a <a href="http://en.m.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> that keeps track of a <a href="http://en.m.wikipedia.org/wiki/Set_%28mathematics%29" title="Set (mathematics)">set</a> of elements <a href="http://en.m.wikipedia.org/wiki/Partition_of_a_set" title="Partition of a set">partitioned</a> into a number of <a href="http://en.m.wikipedia.org/wiki/Disjoint_sets" title="Disjoint sets">disjoint</a> (nonoverlapping) subsets. A <b>union-find algorithm</b> is an algorithm that performs two useful operations on such a data structure:</p>
<ul>
<li>
<i>Find</i>: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.</li>
<li>
<i>Union</i>: Join two subsets into a single subset.</li>
</ul>
<p>Because it supports these two operations, a disjoint-set data structure is sometimes called a <i>union-find data structure</i> or <i>merge-find set</i>. The other important operation, <i>MakeSet</i>, which makes a set containing only a given element (a <a href="http://en.m.wikipedia.org/wiki/Singleton_%28mathematics%29" title="Singleton (mathematics)">singleton</a>), is generally trivial. With these three operations, many practical <a href="http://en.m.wikipedia.org/wiki/Partitioning_problem" title="Partitioning problem" class="mw-redirect">partitioning problems</a> can be solved (see the <i>Applications</i> section).</p>
<p>In order to define these operations more precisely, some way of 
representing the sets is needed. One common approach is to select a 
fixed element of each set, called its <i>representative</i>, to represent the set as a whole. Then, <i>Find</i>(x) returns the representative of the set that <i>x</i> belongs to, and <i>Union</i> takes two set representatives as its arguments.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Disjoint-set_linked_lists">Disjoint-set linked lists</span></h2><div class="content_block" id="content_1">
<p>A simple approach to creating a disjoint-set data structure is to create a <a href="http://en.m.wikipedia.org/wiki/Linked_list" title="Linked list">linked list</a> for each set. The element at the head of each list is chosen as its representative.</p>
<p><i>MakeSet</i> creates a list of one element. <i>Union</i> appends the two lists, a constant-time operation. The drawback of this implementation is that <i>Find</i> requires <a href="http://en.m.wikipedia.org/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">Ω</a>(<i>n</i>) or linear time to traverse the list backwards from a given element to the head of the list.</p>
<p>This can be avoided by including in each linked list node a pointer to the head of the list; then <i>Find</i> takes constant time, since this pointer refers directly to the set representative. However, <i>Union</i> now has to update each element of the list being appended to make it point to the head of the new combined list, requiring <a href="http://en.m.wikipedia.org/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">Ω</a>(<i>n</i>) time.</p>
<p>When the length of each list is tracked, the required time can be 
improved by always appending the smaller list to the longer. Using this <i>weighted-union heuristic</i>, a sequence of <i>m</i> <i>MakeSet</i>, <i>Union</i>, and <i>Find</i> operations on <i>n</i> elements requires O(<i>m</i>&nbsp;+&nbsp;<i>n</i>log&nbsp;<i>n</i>) time.<sup id="cite_ref-IntroductionToAlgorithms_0-0" class="reference"><a href="#cite_note-IntroductionToAlgorithms-0"><span>[</span>1<span>]</span></a></sup> For asymptotically faster operations, a different data structure is needed.</p>
<h3> <span class="mw-headline" id="Analysis_of_the_naive_approach">Analysis of the naive approach</span>
</h3>
<p>We now explain the bound <img class="tex" alt="O(n \log(n))" src="Disjoint-set_data_structure_files/8f1bbb5f5c8a76d0d83f0cdab5eb3bf8.png"> above.</p>
<p>Suppose you have a collection of lists, each node of a list contains 
an object, the name of the list to which it belongs, and the number of 
elements in that list. Also assume that the sum of the number of 
elements in all lists is <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png"> (i.e. there are <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png">
 elements overall). We wish to be able to merge any two of these lists, 
and update all of their nodes so that they still contain the name of the
 list to which they belong. The rule for merging the lists <img class="tex" alt="A" src="Disjoint-set_data_structure_files/7fc56270e7a70fa81a5935b72eacbe29.png"> and <img class="tex" alt="B" src="Disjoint-set_data_structure_files/9d5ed678fe57bcca610140957afab571.png"> is that if <img class="tex" alt="A" src="Disjoint-set_data_structure_files/7fc56270e7a70fa81a5935b72eacbe29.png"> is larger than <img class="tex" alt="B" src="Disjoint-set_data_structure_files/9d5ed678fe57bcca610140957afab571.png"> then merge the elements of <img class="tex" alt="B" src="Disjoint-set_data_structure_files/9d5ed678fe57bcca610140957afab571.png"> into <img class="tex" alt="A" src="Disjoint-set_data_structure_files/7fc56270e7a70fa81a5935b72eacbe29.png"> and update the elements that used to belong to <img class="tex" alt="B" src="Disjoint-set_data_structure_files/9d5ed678fe57bcca610140957afab571.png">, and vice versa.</p>
<p>Choose an arbitrary element of list <img class="tex" alt="L" src="Disjoint-set_data_structure_files/d20caec3b48a1eef164cb4ca81ba2587.png">, say <img class="tex" alt="x" src="Disjoint-set_data_structure_files/9dd4e461268c8034f5c8564e155c67a6.png">. We wish to count how many times in the worst case will <img class="tex" alt="x" src="Disjoint-set_data_structure_files/9dd4e461268c8034f5c8564e155c67a6.png"> need to have the name of the list to which it belongs updated. The element <img class="tex" alt="x" src="Disjoint-set_data_structure_files/9dd4e461268c8034f5c8564e155c67a6.png">
 will only have its name updated when the list it belongs to is merged 
with another list of the same size or of greater size. Each time that 
happens, the size of the list to which <img class="tex" alt="x" src="Disjoint-set_data_structure_files/9dd4e461268c8034f5c8564e155c67a6.png"> belongs at least doubles. So finally, the question is "how many times can a number double before it is the size of <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png">?" (then the list containing <img class="tex" alt="x" src="Disjoint-set_data_structure_files/9dd4e461268c8034f5c8564e155c67a6.png"> will contain all <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png"> elements). The answer is exactly <img class="tex" alt="\log_2(n)" src="Disjoint-set_data_structure_files/a89909a60d5c523a5b966220ebbda670.png">. So for any given element of any given list in the structure described, it will need to be updated <img class="tex" alt="\log_2(n)" src="Disjoint-set_data_structure_files/a89909a60d5c523a5b966220ebbda670.png"> times in the worst case. Therefore updating a list of <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png"> elements stored in this way takes <img class="tex" alt="O(n \log(n))" src="Disjoint-set_data_structure_files/8f1bbb5f5c8a76d0d83f0cdab5eb3bf8.png"> time in the worst case. A find operation can be done in <img class="tex" alt="O(1)" src="Disjoint-set_data_structure_files/5e079a28737d5dd019a3b8f6133ee55e.png"> for this structure because each node contains the name of the list to which it belongs.</p>
<p>A similar argument holds for merging the trees in the data structures
 discussed below, additionally it helps explain the time analysis of 
some operations in the <a href="http://en.m.wikipedia.org/wiki/Binomial_heap" title="Binomial heap">binomial heap</a> and <a href="http://en.m.wikipedia.org/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci heap</a> data structures.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Disjoint-set_forests">Disjoint-set forests</span></h2><div class="content_block" id="content_2">
<p>Disjoint-set forests are data structures where each set is represented by a <a href="http://en.m.wikipedia.org/wiki/Tree_data_structure" title="Tree data structure" class="mw-redirect">tree data structure</a>, in which each node holds a <a href="http://en.m.wikipedia.org/wiki/Reference" title="Reference">reference</a> to its parent node (see <a href="http://en.m.wikipedia.org/wiki/Spaghetti_stack" title="Spaghetti stack">spaghetti stack</a>). They were first described by <a href="http://en.m.wikipedia.org/wiki/Bernard_A._Galler" title="Bernard A. Galler" class="mw-redirect">Bernard A. Galler</a> and <a href="http://en.m.wikipedia.org/wiki/Michael_J._Fischer" title="Michael J. Fischer">Michael J. Fischer</a> in 1964,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup> although their precise analysis took years.</p>
<p>In a disjoint-set forest, the representative of each set is the root of that set's tree. <i>Find</i> follows parent nodes until it reaches the root. <i>Union</i> combines two trees into one by attaching the root of one to the root of the other. One way of implementing these might be:</p>
<pre> <b>function</b> MakeSet(x)
     x.parent := x
</pre>
<pre> <b>function</b> Find(x)
     <b>if</b> x.parent == x
        <b>return</b> x
     <b>else</b>
        <b>return</b> Find(x.parent)
</pre>
<pre> <b>function</b> Union(x, y)
     xRoot := Find(x)
     yRoot := Find(y)
     xRoot.parent := yRoot
</pre>
<p>In this naive form, this approach is no better than the linked-list 
approach, because the tree it creates can be highly unbalanced; however,
 it can be enhanced in two ways.</p>
<p>The first way, called <i>union by rank</i>, is to always attach the 
smaller tree to the root of the larger tree, rather than vice versa. 
Since it is the depth of the tree that affects the running time, the 
tree with smaller depth gets added under the root of the deeper tree, 
which only increases the depth if the depths were equal. In the context 
of this algorithm, the term <i>rank</i> is used instead of <i>depth</i> 
since it stops being equal to the depth if path compression (described 
below) is also used. One-element trees are defined to have a rank of 
zero, and whenever two trees of the same rank <i>r</i> are united, the rank of the result is <i>r</i>+1. Just applying this technique alone yields a worst-case running-time of <img class="tex" alt="O(\log n)" src="Disjoint-set_data_structure_files/0ca47d9a481af371d1210a620c1945db.png"> per <i>MakeSet</i>, <i>Union</i>, or <i>Find</i> operation. Pseudocode for the improved <code>MakeSet</code> and <code>Union</code>:</p>
<pre> <b>function</b> MakeSet(x)
     x.parent := x
     x.rank   := 0
</pre>
<pre> <b>function</b> Union(x, y)
     xRoot := Find(x)
     yRoot := Find(y)
     <b>if</b> xRoot == yRoot
         return

     <i>// x and y are not already in same set. Merge them.</i>
     <b>if</b> xRoot.rank &lt; yRoot.rank
         xRoot.parent := yRoot
     <b>else if</b> xRoot.rank &gt; yRoot.rank
         yRoot.parent := xRoot
     <b>else</b>
         yRoot.parent := xRoot
         xRoot.rank := xRoot.rank + 1
</pre>
<p>The second improvement, called <i>path compression</i>, is a way of flattening the structure of the tree whenever <i>Find</i>
 is used on it. The idea is that each node visited on the way to a root 
node may as well be attached directly to the root node; they all share 
the same representative. To effect this, as <code>Find</code> 
recursively traverses up the tree, it changes each node's parent 
reference to point to the root that it found. The resulting tree is much
 flatter, speeding up future operations not only on these elements but 
on those referencing them, directly or indirectly. Here is the improved <code>Find</code>:</p>
<pre> <b>function</b> Find(x)
     <b>if</b> x.parent != x
        x.parent := Find(x.parent)
     <b>return</b> x.parent
</pre>
<p>These two techniques complement each other; applied together, the <a href="http://en.m.wikipedia.org/wiki/Amortized_analysis" title="Amortized analysis">amortized</a> time per operation is only <img class="tex" alt="O(\alpha(n))" src="Disjoint-set_data_structure_files/583932d69eb3744b3a5e7377983f4252.png">, where <img class="tex" alt="\alpha(n)" src="Disjoint-set_data_structure_files/32f83f739501188cd05abd5b593a2bac.png"> is the inverse of the function <img class="tex" alt="f(n) = A(n,n)" src="Disjoint-set_data_structure_files/7570f1e1a9ba9351113d8e84563df6e8.png">, and <img class="tex" alt="A" src="Disjoint-set_data_structure_files/7fc56270e7a70fa81a5935b72eacbe29.png"> is the extremely fast-growing <a href="http://en.m.wikipedia.org/wiki/Ackermann_function" title="Ackermann function">Ackermann function</a>. Since <img class="tex" alt="\alpha(n)" src="Disjoint-set_data_structure_files/32f83f739501188cd05abd5b593a2bac.png"> is the inverse of this function, <img class="tex" alt="\alpha(n)" src="Disjoint-set_data_structure_files/32f83f739501188cd05abd5b593a2bac.png"> is less than 5 for all remotely practical values of <img class="tex" alt="n" src="Disjoint-set_data_structure_files/7b8b965ad4bca0e41ab51de7b31363a1.png">. Thus, the amortized running time per operation is effectively a small constant.</p>
<p>In fact, this is <a href="http://en.m.wikipedia.org/wiki/Asymptotically_optimal" title="Asymptotically optimal" class="mw-redirect">asymptotically optimal</a>: <a href="http://en.m.wikipedia.org/wiki/Michael_Fredman" title="Michael Fredman">Fredman</a> and Saks showed in 1989 that <img class="tex" alt="\Omega(\alpha(n))" src="Disjoint-set_data_structure_files/8e03fd45de82704a50dab32c512ae5b4.png"> words must be accessed by <i>any</i> disjoint-set data structure per operation on average.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>3<span>]</span></a></sup></p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Applications">Applications</span></h2><div class="content_block" id="content_3">
<p>Disjoint-set data structures model the <a href="http://en.m.wikipedia.org/wiki/Partition_of_a_set" title="Partition of a set">partitioning of a set</a>, for example to keep track of the <a href="http://en.m.wikipedia.org/wiki/Connected_component_%28graph_theory%29" title="Connected component (graph theory)">connected components</a> of an <a href="http://en.m.wikipedia.org/wiki/Undirected_graph" title="Undirected graph" class="mw-redirect">undirected graph</a>.
 This model can then be used to determine whether two vertices belong to
 the same component, or whether adding an edge between them would result
 in a cycle. The Union-Find algorithm is used in high-performance 
implementations of <a href="http://en.m.wikipedia.org/wiki/Unification_%28computer_science%29" title="Unification (computer science)">Unification</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>4<span>]</span></a></sup></p>
<p>This data structure is used by the <a href="http://en.m.wikipedia.org/wiki/Boost_Graph_Library" title="Boost Graph Library" class="mw-redirect">Boost Graph Library</a> to implement its <a rel="nofollow" class="external text" href="http://www.boost.org/libs/graph/doc/incremental_components.html">Incremental Connected Components</a> functionality. It is also used for implementing <a href="http://en.m.wikipedia.org/wiki/Kruskal%27s_algorithm" title="Kruskal's algorithm">Kruskal's algorithm</a> to find the <a href="http://en.m.wikipedia.org/wiki/Minimum_spanning_tree" title="Minimum spanning tree">minimum spanning tree</a> of a graph.</p>
<p>Note that the implementation as disjoint-set forests doesn't allow 
deletion of edges—even without path compression or the rank heuristic.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="History">History</span></h2><div class="content_block" id="content_4">
<p>While the ideas used in disjoint-set forests have long been familiar, <a href="http://en.m.wikipedia.org/wiki/Robert_Tarjan" title="Robert Tarjan">Robert Tarjan</a> was the first to prove the upper bound (and a restricted version of the lower bound) in terms of the inverse <a href="http://en.m.wikipedia.org/wiki/Ackermann_function" title="Ackermann function">Ackermann function</a>, in 1975.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>5<span>]</span></a></sup> Until this time the best bound on the time per operation, proven by <a href="http://en.m.wikipedia.org/wiki/John_Hopcroft" title="John Hopcroft">Hopcroft</a> and <a href="http://en.m.wikipedia.org/wiki/Jeffrey_Ullman" title="Jeffrey Ullman">Ullman</a>,<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>6<span>]</span></a></sup> was <a href="http://en.m.wikipedia.org/wiki/Proof_of_O%28log*n%29_time_complexity_of_Union_Find" title="Proof of O(log*n) time complexity of Union Find">O(log<sup>*</sup> n)</a>, the <a href="http://en.m.wikipedia.org/wiki/Iterated_logarithm" title="Iterated logarithm">iterated logarithm</a> of n, another slowly growing function (but not quite as slow as the inverse Ackermann function).</p>
<p><a href="http://en.m.wikipedia.org/wiki/Robert_E._Tarjan" title="Robert E. Tarjan" class="mw-redirect">Tarjan</a> and <a href="http://en.m.wikipedia.org/wiki/Jan_van_Leeuwen" title="Jan van Leeuwen">Van Leeuwen</a> also developed one-pass <i>Find</i> algorithms that are more efficient in practice while retaining the same worst-case complexity.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>7<span>]</span></a></sup></p>
<p>In 2007, Sylvain Conchon and Jean-Christophe Filliâtre developed a <a href="http://en.m.wikipedia.org/wiki/Persistent_data_structure" title="Persistent data structure">persistent</a>
 version of the disjoint-set forest data structure, allowing previous 
versions of the structure to be efficiently retained, and formalized its
 correctness using the <a href="http://en.m.wikipedia.org/wiki/Proof_assistant" title="Proof assistant">proof assistant</a> <a href="http://en.m.wikipedia.org/wiki/Coq" title="Coq">Coq</a>.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>8<span>]</span></a></sup></p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_5">
<ul>
<li>
<a href="http://en.m.wikipedia.org/wiki/Partition_refinement" title="Partition refinement">Partition refinement</a>, a different data structure for maintaining disjoint sets, with updates that split sets apart rather than merging them together</li>
</ul>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_6">
<ol class="references">
<li id="cite_note-IntroductionToAlgorithms-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-IntroductionToAlgorithms_0-0">^</a></b></span> <span class="reference-text"><a href="http://en.m.wikipedia.org/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="http://en.m.wikipedia.org/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="http://en.m.wikipedia.org/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="http://en.m.wikipedia.org/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="http://en.m.wikipedia.org/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw–Hill, 2001. <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0262032937" class="internal mw-magiclink-isbn">ISBN 0-262-03293-7</a>. Chapter 21: Data structures for Disjoint Sets, pp. 498–524.</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Bernard A. Galler and Michael J. Fischer. An improved equivalence algorithm. <i><a href="http://en.m.wikipedia.org/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a>,</i> Volume 7, Issue 5 (May 1964), pp. 301–303. The paper originating disjoint-set forests. <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?doid=364099.364331">ACM Digital Library</a></span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a href="http://en.m.wikipedia.org/wiki/Michael_Fredman" title="Michael Fredman">M. Fredman</a> and M. Saks. The cell probe complexity of dynamic data structures. <i>Proceedings of the Twenty-First Annual ACM Symposium on Theory of Computing</i>, pp. 345–354. May 1989. "Theorem 5: Any CPROBE(log <i>n</i>) implementation of the set union problem requires Ω(<i>m</i> α(<i>m</i>, <i>n</i>)) time to execute <i>m</i> Find's and <i>n</i>−1 Union's, beginning with <i>n</i> singleton sets."</span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation Journal">Knight, Kevin (1989). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=62030">"Unification: A multidisciplinary survey"</a>. <i>ACM Computing Surveys</i> <b>21</b>: 93–124. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F62029.62030">10.1145/62029.62030</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=62030">http://portal.acm.org/citation.cfm?id=62030</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Unification%3A+A+multidisciplinary+survey&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.aulast=Knight&amp;rft.aufirst=Kevin&amp;rft.au=Knight%2C%26%2332%3BKevin&amp;rft.date=1989&amp;rft.volume=21&amp;rft.pages=93%26ndash%3B124&amp;rft_id=info:doi/10.1145%2F62029.62030&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D62030&amp;rfr_id=info:sid/en.wikipedia.org:Disjoint-set_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-4">
<span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation Journal">Tarjan, Robert Endre (1975). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=321884">"Efficiency of a Good But Not Linear Set Union Algorithm"</a>. <i>Journal of the ACM</i> <b>22</b> (2): 215–225. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F321879.321884">10.1145/321879.321884</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=321884">http://portal.acm.org/citation.cfm?id=321884</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Efficiency+of+a+Good+But+Not+Linear+Set+Union+Algorithm&amp;rft.jtitle=Journal+of+the+ACM&amp;rft.aulast=Tarjan&amp;rft.aufirst=Robert+Endre&amp;rft.au=Tarjan%2C%26%2332%3BRobert+Endre&amp;rft.date=1975&amp;rft.volume=22&amp;rft.issue=2&amp;rft.pages=215%26ndash%3B225&amp;rft_id=info:doi/10.1145%2F321879.321884&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D321884&amp;rfr_id=info:sid/en.wikipedia.org:Disjoint-set_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation Journal">Hopcroft, J. E.; Ullman, J. D. (1973). "Set Merging Algorithms". <i>SIAM Journal on Computing</i> <b>2</b> (4): 294–303. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1137%2F0202024">10.1137/0202024</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Set+Merging+Algorithms&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.aulast=Hopcroft&amp;rft.aufirst=J.+E.&amp;rft.au=Hopcroft%2C%26%2332%3BJ.+E.&amp;rft.au=Ullman%2C%26%2332%3BJ.+D.&amp;rft.date=1973&amp;rft.volume=2&amp;rft.issue=4&amp;rft.pages=294%26ndash%3B303&amp;rft_id=info:doi/10.1137%2F0202024&amp;rfr_id=info:sid/en.wikipedia.org:Disjoint-set_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a href="http://en.m.wikipedia.org/wiki/Robert_E._Tarjan" title="Robert E. Tarjan" class="mw-redirect">Robert E. Tarjan</a> and <a href="http://en.m.wikipedia.org/wiki/Jan_van_Leeuwen" title="Jan van Leeuwen">Jan van Leeuwen</a>. Worst-case analysis of set union algorithms. Journal of the ACM, 31(2):245–281, 1984.</span>
</li>
<li id="cite_note-7">
<span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Sylvain
 Conchon and Jean-Christophe Filliâtre. A Persistent Union-Find Data 
Structure. In ACM SIGPLAN Workshop on ML, Freiburg, Germany, October 
2007.</span>
</li>
</ol>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li>
<a rel="nofollow" class="external text" href="http://www.boost.org/libs/disjoint_sets/disjoint_sets.html">C++ implementation</a>, part of the <a href="http://en.m.wikipedia.org/wiki/Boost_C%2B%2B_libraries" title="Boost C++ libraries" class="mw-redirect">Boost C++ libraries</a>
</li>
<li><a rel="nofollow" class="external text" href="http://www.lix.polytechnique.fr/%7Enielsen/Srmjava.java">A
 Java implementation with an application to color image segmentation, 
Statistical Region Merging (SRM), IEEE Trans. Pattern Anal. Mach. 
Intell. 26(11): 1452–1458 (2004)</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.unm.edu/%7Erlpm/499/uf.html">Java applet: A Graphical Union-Find Implementation</a>, by Rory L. P. McGuire</li>
<li>
<i><a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/anderson94waitfree.html">Wait-free Parallel Algorithms for the Union-Find Problem</a></i>, a 1994 paper by Richard J. Anderson and Heather Woll describing a parallelized version of Union-Find that never needs to block</li>
<li><a rel="nofollow" class="external text" href="http://code.activestate.com/recipes/215912-union-find-data-structure/">Python implementation</a></li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Disjoint-set_data_structure&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Disjoint-set+data+structure&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Disjoint-set_data_structure&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Disjoint-set+data+structure&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Disjoint-set_data_structure_files/load.php" type="text/javascript"></script>
<script src="Disjoint-set_data_structure_files/load_002.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>