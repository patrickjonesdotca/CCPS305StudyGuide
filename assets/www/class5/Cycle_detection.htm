<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Cycle detection - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Cycle_detection_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 6 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Cycle_detection">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Cycle_detection_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Cycle_detection_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Cycle_detection_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Cycle_detection" selected="selected">English</option><option value="//de.m.wikipedia.org/wiki/Hase-Igel-Algorithmus">Deutsch</option><option value="//fr.m.wikipedia.org/wiki/Algorithme_du_li%C3%A8vre_et_de_la_tortue">français</option><option value="//id.m.wikipedia.org/wiki/Algoritma_pencari-siklus_Floyd">Bahasa Indonesia</option><option value="//ja.m.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E3%81%AE%E5%BE%AA%E7%92%B0%E6%A4%9C%E5%87%BA%E6%B3%95">日本語</option><option value="//pt.m.wikipedia.org/wiki/Algoritmo_busca-ciclos_de_Floyd">português</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Cycle detection</h1>			
<div class="dablink">This article is about iterated functions.  For another use, see <a href="http://en.m.wikipedia.org/wiki/Cycle_detection_%28graph_theory%29" title="Cycle detection (graph theory)" class="mw-redirect">Cycle detection (graph theory)</a>.</div>
<p>In <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, <b>cycle detection</b> is the <a href="http://en.m.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithmic</a> problem of finding a cycle in a <a href="http://en.m.wikipedia.org/wiki/Sequence" title="Sequence">sequence</a> of <a href="http://en.m.wikipedia.org/wiki/Iterated_function" title="Iterated function">iterated function</a> values.</p>
<p>For any <a href="http://en.m.wikipedia.org/wiki/Function_%28mathematics%29" title="Function (mathematics)">function</a> <i>ƒ</i> that maps a <a href="http://en.m.wikipedia.org/wiki/Finite_set" title="Finite set">finite set</a> <i>S</i> to itself, and any initial value <i>x</i><sub>0</sub> in <i>S</i>, the sequence of iterated function values</p>
<dl>
<dd><img class="tex" alt=" x_0,\ x_1=f(x_0),\ x_2=f(x_1),\ \dots,\ x_i=f(x_{i-1}),\ \dots" src="Cycle_detection_files/572b371fa990321a0809ac2af7075317.png"></dd>
</dl>
<p>must eventually use the same value twice: there must be some <i>i</i> ≠ <i>j</i> such that <i>x<sub>i</sub></i> = <i>x<sub>j</sub></i>. Once this happens, the sequence must continue by repeating the <a href="http://en.m.wikipedia.org/wiki/Cycle_%28mathematics%29" title="Cycle (mathematics)">cycle</a> of values from <i>x<sub>i</sub></i> to <i>x</i><sub><i>j</i>−1</sub>. Cycle detection is the problem of finding <i>i</i> and <i>j</i>, given <i>ƒ</i> and <i>x</i><sub>0</sub>.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Example">Example</span></h2><div class="content_block" id="content_1">
<div class="thumb tright">
<div class="thumbinner" style="width:242px;">
<a href="http://en.m.wikipedia.org/wiki/File:Functional_graph.svg" class="image"><img alt="" src="Cycle_detection_files/240px-Functional_graph.png" class="thumbimage" width="240" height="182"></a>
<div class="thumbcaption">

A function from and to the set {0,1,2,3,4,5,6,7,8} and the corresponding functional graph</div>
</div>
</div>
<p>The figure shows a function ƒ that maps the set <i>S</i> = {0,1,2,3,4,5,6,7,8} to itself. If one starts from <i>x</i><sub>0</sub> = 2 and repeatedly applies ƒ, one sees the sequence of values</p>
<dl>
<dd>2, 0, 6, 3, 1, 6, 3, 1, 6, 3, 1, ....</dd>
</dl>
<p>The cycle to be detected is the repeating subsequence of values 6, 3, 1 in this sequence.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Definitions">Definitions</span></h2><div class="content_block" id="content_2">
<p>Let <i>S</i> be any finite set, ƒ be any function from <i>S</i> to itself, and <i>x</i><sub>0</sub> be any element of <i>S</i>. For any <i>i</i> &gt; 0, let <i>x<sub>i</sub></i> = ƒ(<i>x</i><sub><i>i</i>−1</sub>). Let μ be the smallest index such that the value <i>x</i><sub>μ</sub> reappears infinitely often within the sequence of values <i>x<sub>i</sub></i>, and let λ (the loop length) be the smallest positive integer such that <i>x</i><sub>μ</sub> = <i>x</i><sub>λ+μ</sub>. The cycle detection problem is the task of finding λ and μ.</p>
<p>One can view the same problem <a href="http://en.m.wikipedia.org/wiki/Graph_theory" title="Graph theory">graph-theoretically</a>, by constructing a <a href="http://en.m.wikipedia.org/wiki/Functional_graph" title="Functional graph" class="mw-redirect">functional graph</a> (that is, a <a href="http://en.m.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a> in which each vertex has a single outgoing edge) the vertices of which are the elements of <i>S</i> and the edges of which map an element to the corresponding function value, as shown in the figure. The set of vertices <a href="http://en.m.wikipedia.org/wiki/Reachability" title="Reachability">reachable</a> from any starting vertex <i>x</i><sub>0</sub> form a <a href="http://en.m.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs" title="Glossary of graph theory">subgraph</a> with a shape resembling the <a href="http://en.m.wikipedia.org/wiki/Rho_%28letter%29" title="Rho (letter)" class="mw-redirect">Greek letter rho</a> (ρ): a path of length μ from <i>x</i><sub>0</sub> to a <a href="http://en.m.wikipedia.org/wiki/Cycle_graph" title="Cycle graph">cycle</a> of λ vertices.</p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Computer_representation">Computer representation</span></h2><div class="content_block" id="content_3">
<p>Generally, ƒ will not be specified as a table of values, as we have 
given it in the figure above. Rather, we may be given access either to 
the sequence of values <i>x<sub>i</sub></i>, or to a subroutine for 
calculating ƒ. The task is to find λ and μ while examining as few values
 from the sequence or performing as few subroutine calls as possible. 
Typically, also, the <a href="http://en.m.wikipedia.org/wiki/Space_complexity" title="Space complexity" class="mw-redirect">space complexity</a>
 of an algorithm for the cycle detection problem is of importance: we 
wish to solve the problem while using an amount of memory significantly 
smaller than it would take to store the entire sequence.</p>
<p>In some applications, and in particular in <a href="http://en.m.wikipedia.org/wiki/Pollard%27s_rho_algorithm" title="Pollard's rho algorithm">Pollard's rho algorithm</a> for <a href="http://en.m.wikipedia.org/wiki/Integer_factorization" title="Integer factorization">integer factorization</a>, the algorithm has much more limited access to <i>S</i> and to ƒ. In Pollard's rho algorithm, for instance, <i>S</i> is the set of integers modulo an unknown prime factor of the number to be factorized, so even the size of <i>S</i>
 is unknown to the algorithm. We may view a cycle detection algorithm 
for this application as having the following capabilities: it initially 
has in its memory an object representing a pointer to the starting value
 <i>x</i><sub>0</sub>. At any step, it may perform one of three actions:
 it may copy any pointer it has to another object in memory, it may 
apply ƒ and replace any of its pointers by a pointer to the next object 
in the sequence, or it may apply a subroutine for determining whether 
two of its pointers represent equal values in the sequence. The equality
 test action may involve some nontrivial computation: in Pollard's rho 
algorithm, it is implemented by testing whether the difference between 
two stored values has a nontrivial <a href="http://en.m.wikipedia.org/wiki/Greatest_common_divisor" title="Greatest common divisor">gcd</a>
 with the number to be factored. In this context, we will call an 
algorithm that only uses pointer copying, advancement within the 
sequence, and equality tests a <i>pointer algorithm</i>.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Algorithms">Algorithms</span></h2><div class="content_block" id="content_4">
<p>If the input is given as a subroutine for calculating ƒ, the cycle 
detection problem may be trivially solved using only λ+μ function 
applications, simply by computing the sequence of values <i>x<sub>i</sub></i> and using a <a href="http://en.m.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> such as a <a href="http://en.m.wikipedia.org/wiki/Hash_table" title="Hash table">hash table</a>
 to store these values and test whether each subsequent value has 
already been stored. However, the space complexity of this algorithm is 
λ+μ, unnecessarily large. Additionally, to implement this method as a 
pointer algorithm would require applying the equality test to each pair 
of values, resulting in quadratic time overall. Thus, research in this 
area has concentrated on two goals: using less space than this naive 
algorithm, and finding pointer algorithms that use fewer equality tests.</p>
<h3> <span class="mw-headline" id="Tortoise_and_hare">Tortoise and hare</span>
</h3>
<div class="thumb tright">
<div class="thumbinner" style="width:302px;">
<a href="http://en.m.wikipedia.org/wiki/File:Tortoise_and_hare_algorithm.svg" class="image"><img alt="" src="Cycle_detection_files/300px-Tortoise_and_hare_algorithm.png" class="thumbimage" width="300" height="292"></a>
<div class="thumbcaption">

Floyd's "tortoise and hare" cycle detection algorithm, applied to the sequence 2, 0, 6, 3, 1, 6, 3, 1, ...</div>
</div>
</div>
<p><b>Floyd's cycle-finding algorithm</b>, also called the "<a href="http://en.m.wikipedia.org/wiki/The_Tortoise_and_the_Hare" title="The Tortoise and the Hare">tortoise and the hare</a>"
 algorithm, is a pointer algorithm that uses only two pointers, which 
move through the sequence at different speeds. The algorithm is named 
for <a href="http://en.m.wikipedia.org/wiki/Robert_W._Floyd" title="Robert W. Floyd">Robert W. Floyd</a>, who invented it in the late 1960s.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup></p>
<p>The key insight in the algorithm is that, for any integers <span class="nowrap"><i>i</i> ≥ μ</span> and <span class="nowrap"><i>k</i> ≥ 0</span>, <span class="nowrap"><i>x<sub>i</sub></i> = <i>x</i><sub><i>i</i> + <i>k</i>λ</sub>,</span> where λ is the length of the loop to be found. In particular, whenever <span class="nowrap"><i>i</i> = <i>k</i>λ ≥ μ</span>, it follows that <span class="nowrap"><i>x<sub>i</sub></i> = <i>x</i><sub>2<i>i</i></sub></span>.
 Thus, the algorithm only needs to check for repeated values of this 
special form, one twice as far from the start of the sequence than the 
other, to find a period ν of a repetition that is a multiple of λ. Once ν
 is found, the algorithm retraces the sequence from its start to find 
the first repeated value <i>x</i><sub>μ</sub> in the sequence, using the fact that λ divides ν and therefore that <span class="nowrap"><i>x</i><sub>μ</sub> = <i>x</i><sub>ν + μ</sub></span>.
 Finally, once the value of μ is known it is trivial to find the length λ
 of the shortest repeating cycle, by searching for the first position <span class="nowrap">μ + λ</span> for which <span class="nowrap"><i>x</i><sub>μ + λ</sub> = <i>x</i><sub>μ</sub></span>.</p>
<p>The algorithm thus maintains two pointers into the given sequence, one (the tortoise) at <i>x<sub>i</sub></i>, and the other (the hare) at <i>x</i><sub>2<i>i</i></sub>. At each step of the algorithm, it increases <i>i</i>
 by one, moving the tortoise one step forward and the hare two steps 
forward in the sequence, and then compares the sequence values at these 
two pointers. The smallest value of <i>i</i> &gt; 0 for which the tortoise and hare point to equal values is the desired value ν.</p>
<p>The following <a href="http://en.m.wikipedia.org/wiki/Python_%28programming_language%29" title="Python (programming language)">Python</a> code shows how this idea may be implemented as an algorithm.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="python source-python">
<pre class="de1"><span class="kw1">def</span> floyd<span class="br0">(</span>f<span class="sy0">,</span> x0<span class="br0">)</span>:
    <span class="co1"># The main phase of the algorithm, finding a repetition x_mu = x_2mu</span>
    <span class="co1"># The hare moves twice as quickly as the tortoise</span>
    tortoise <span class="sy0">=</span> f<span class="br0">(</span>x0<span class="br0">)</span> <span class="co1"># f(x0) is the element/node next to x0.</span>
    hare <span class="sy0">=</span> f<span class="br0">(</span>f<span class="br0">(</span>x0<span class="br0">)</span><span class="br0">)</span>
    <span class="kw1">while</span> tortoise <span class="sy0">!=</span> hare:
        tortoise <span class="sy0">=</span> f<span class="br0">(</span>tortoise<span class="br0">)</span>
        hare <span class="sy0">=</span> f<span class="br0">(</span>f<span class="br0">(</span>hare<span class="br0">)</span><span class="br0">)</span>
 
    <span class="co1"># at this point the start of the loop is equi-distant from current tortoise</span>
    <span class="co1"># position and x0, so hare moving in circle and tortoise (set to x0 )</span>
    <span class="co1"># moving towards circle, will intersect at the beginning of the circle.</span>
 
    <span class="co1"># Find the position of the first repetition of length mu</span>
    <span class="co1"># The hare and tortoise move at the same speeds</span>
    mu <span class="sy0">=</span> <span class="nu0">0</span>
    tortoise <span class="sy0">=</span> x0
    <span class="kw1">while</span> tortoise <span class="sy0">!=</span> hare:
        tortoise <span class="sy0">=</span> f<span class="br0">(</span>tortoise<span class="br0">)</span>
        hare <span class="sy0">=</span> f<span class="br0">(</span>hare<span class="br0">)</span>
        mu +<span class="sy0">=</span> <span class="nu0">1</span>
 
    <span class="co1"># Find the length of the shortest cycle starting from x_mu</span>
    <span class="co1"># The hare moves while the tortoise stays still</span>
    lam <span class="sy0">=</span> <span class="nu0">1</span>
    hare <span class="sy0">=</span> f<span class="br0">(</span>tortoise<span class="br0">)</span>
    <span class="kw1">while</span> tortoise <span class="sy0">!=</span> hare:
        hare <span class="sy0">=</span> f<span class="br0">(</span>hare<span class="br0">)</span>
        lam +<span class="sy0">=</span> <span class="nu0">1</span>
 
    <span class="kw1">return</span> lam<span class="sy0">,</span> mu
</pre>
</div>
</div>
<p>This code only accesses the sequence by storing and copying pointers,
 function evaluations, and equality tests; therefore, it qualifies as a 
pointer algorithm. The algorithm uses <span class="nowrap">O(λ + μ)</span> operations of these types, and O(1) storage space.</p>
<h3> <span class="mw-headline" id="Brent.27s_algorithm">Brent's algorithm</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Richard_Brent_%28scientist%29" title="Richard Brent (scientist)" class="mw-redirect">Richard P. Brent</a>
 described an alternative cycle detection algorithm that, like the 
tortoise and hare algorithm, requires only two pointers into the 
sequence.<sup id="cite_ref-brent_1-0" class="reference"><a href="#cite_note-brent-1"><span>[</span>2<span>]</span></a></sup> However, it is based on a different principle: searching for the smallest <a href="http://en.m.wikipedia.org/wiki/Power_of_two" title="Power of two">power of two</a> 2<sup><i>i</i></sup> that is larger than both λ and μ. For <i>i</i> = 0, 1, 2, etc., the algorithm compares <i>x</i><sub>2<sup><i>i</i></sup>−1</sub>
 with each subsequent sequence value up to the next power of two, 
stopping when it finds a match. It has two advantages compared to the 
tortoise and hare algorithm: it finds the correct length λ of the cycle 
directly, rather than needing to search for it in a subsequent stage, 
and its steps involve only one evaluation of ƒ rather than three.</p>
<p>The following Python code shows how this technique works in more detail.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="python source-python">
<pre class="de1"><span class="kw1">def</span> brent<span class="br0">(</span>f<span class="sy0">,</span> x0<span class="br0">)</span>:
    <span class="co1"># main phase: search successive powers of two</span>
    power <span class="sy0">=</span> lam <span class="sy0">=</span> <span class="nu0">1</span>
    tortoise <span class="sy0">=</span> x0
    hare <span class="sy0">=</span> f<span class="br0">(</span>x0<span class="br0">)</span>  <span class="co1"># f(x0) is the element/node next to x0.</span>
    <span class="kw1">while</span> tortoise <span class="sy0">!=</span> hare:
        <span class="kw1">if</span> power <span class="sy0">==</span> lam:  <span class="co1"># time to start a new power of two?</span>
            tortoise <span class="sy0">=</span> hare
            power *<span class="sy0">=</span> <span class="nu0">2</span>
            lam <span class="sy0">=</span> <span class="nu0">0</span>
        hare <span class="sy0">=</span> f<span class="br0">(</span>hare<span class="br0">)</span>
        lam +<span class="sy0">=</span> <span class="nu0">1</span>
 
    <span class="co1"># Find the position of the first repetition of length lambda</span>
    mu <span class="sy0">=</span> <span class="nu0">0</span>
    tortoise <span class="sy0">=</span> hare <span class="sy0">=</span> x0
    <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span>lam<span class="br0">)</span>:
    <span class="co1"># range(lam) produces a list with the values 0, 1, ... , lam-1</span>
        hare <span class="sy0">=</span> f<span class="br0">(</span>hare<span class="br0">)</span>
    <span class="kw1">while</span> tortoise <span class="sy0">!=</span> hare:
        tortoise <span class="sy0">=</span> f<span class="br0">(</span>tortoise<span class="br0">)</span>
        hare <span class="sy0">=</span> f<span class="br0">(</span>hare<span class="br0">)</span>
        mu +<span class="sy0">=</span> <span class="nu0">1</span>
 
    <span class="kw1">return</span> lam<span class="sy0">,</span> mu
</pre>
</div>
</div>
<p>Like the tortoise and hare algorithm, this is a pointer algorithm that uses <span class="nowrap">O(λ + μ)</span>
 tests and function evaluations and O(1) storage space. It is not 
difficult to show that the number of function evaluations can never be 
higher than for Floyd's algorithm. Brent claims that, on average, his 
cycle finding algorithm runs around 36% more quickly than Floyd's and 
that it speeds up the Pollard rho algorithm by around 24%. He also 
performs an <a href="http://en.m.wikipedia.org/wiki/Average_case_analysis" title="Average case analysis" class="mw-redirect">average case analysis</a>
 for a randomized version of the algorithm in which the sequence of 
indices traced by the slower of the two pointers is not the powers of 
two themselves, but rather a randomized multiple of the powers of two. 
Although his main intended application was in integer factorization 
algorithms, Brent also discusses applications in testing pseudorandom 
number generators.</p>
<h3> <span class="mw-headline" id="Time.E2.80.93space_tradeoffs">Time–space tradeoffs</span>
</h3>
<p>A number of authors have studied techniques for cycle detection that 
use more memory than Floyd's and Brent's methods, but detect cycles more
 quickly. In general these methods store several previously-computed 
sequence values, and test whether each new value equals one of the 
previously-computed values. In order to do so quickly, they typically 
use a hash table or similar data structure for storing the 
previously-computed values, and therefore are not pointer algorithms: in
 particular, they usually cannot be applied to Pollard's rho algorithm. 
Where these methods differ is in how they determine which values to 
store. Following Nivasch,<sup id="cite_ref-nivasch_2-0" class="reference"><a href="#cite_note-nivasch-2"><span>[</span>3<span>]</span></a></sup> we survey these techniques briefly.</p>
<ul>
<li>Brent<sup id="cite_ref-brent_1-1" class="reference"><a href="#cite_note-brent-1"><span>[</span>2<span>]</span></a></sup> already describes variations of his technique in which the indices of saved sequence values are powers of a number <i>R</i> other than two. By choosing <i>R</i> to be a number close to one, and storing the sequence values at indices that are near a sequence of consecutive powers of <i>R</i>,
 a cycle detection algorithm can use a number of function evaluations 
that is within an arbitrarily small factor of the optimum λ+μ.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-teske_4-0" class="reference"><a href="#cite_note-teske-4"><span>[</span>5<span>]</span></a></sup>
</li>
</ul>
<ul>
<li>Sedgewick, Szymanski, and Yao<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>6<span>]</span></a></sup> provide a method that uses <i>M</i> memory cells and requires in the worst case only <img class="tex" alt="(\lambda+\mu)(1+cM^{-1/2})" src="Cycle_detection_files/79d3e0d42d87d476a4c80d467677bd80.png"> function evaluations, for some constant <i>c</i>, which they show to be optimal. The technique involves maintaining a numerical parameter <i>d</i>, storing in a table only those positions in the sequence that are multiples of <i>d</i>, and clearing the table and doubling <i>d</i> whenever too many values have been stored.</li>
</ul>
<ul>
<li>Several authors have described <i>distinguished point</i> methods 
that store function values in a table based on a criterion involving the
 values, rather than (as in the method of Sedgewick et al.) based on 
their positions. For instance, values equal to zero modulo some value <i>d</i> might be stored.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>7<span>]</span></a></sup><sup id="cite_ref-qd_7-0" class="reference"><a href="#cite_note-qd-7"><span>[</span>8<span>]</span></a></sup> More simply, Nivasch<sup id="cite_ref-nivasch_2-1" class="reference"><a href="#cite_note-nivasch-2"><span>[</span>3<span>]</span></a></sup>
 credits D. P. Woodruff with the suggestion of storing a random sample 
of previously seen values, making an appropriate random choice at each 
step so that the sample remains random.</li>
</ul>
<ul>
<li>Nivasch<sup id="cite_ref-nivasch_2-2" class="reference"><a href="#cite_note-nivasch-2"><span>[</span>3<span>]</span></a></sup>
 describes an algorithm that does not use a fixed amount of memory, but 
for which the expected amount of memory used (under the assumption that 
the input function is random) is logarithmic in the sequence length. An 
item is stored in the memory table, with this technique, when no later 
item has a smaller value. As Nivasch shows, the items with this 
technique can be maintained using a <a href="http://en.m.wikipedia.org/wiki/Stack_%28data_structure%29" title="Stack (data structure)" class="mw-redirect">stack data structure</a>,
 and each successive sequence value need be compared only to the top of 
the stack. The algorithm terminates when the repeated sequence element 
with smallest value is found. Running the same algorithm with multiple 
stacks, using random permutations of the values to reorder the values 
within each stack, allows a time–space tradeoff similar to the previous 
algorithms. However, even the version of this algorithm with a single 
stack is not a pointer algorithm, due to the comparisons needed to 
determine which of two values is smaller.</li>
</ul>
<p>Any cycle detection algorithm that stores at most <i>M</i> values from the input sequence must perform at least <img class="tex" alt="\scriptstyle (\lambda+\mu)(1+\frac{1}{M-1})" src="Cycle_detection_files/debe231c7e8f53bb91e1f07743f0d4e4.png"> function evaluations.<sup id="cite_ref-fich_8-0" class="reference"><a href="#cite_note-fich-8"><span>[</span>9<span>]</span></a></sup><sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>10<span>]</span></a></sup></p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="Applications">Applications</span></h2><div class="content_block" id="content_5">
<p>Cycle detection has been used in many applications.</p>
<ul>
<li>Determining the cycle length of a <a href="http://en.m.wikipedia.org/wiki/Pseudorandom_number_generator" title="Pseudorandom number generator">pseudorandom number generator</a> is one measure of its strength. This is the application cited by Knuth in describing Floyd's method. Brent<sup id="cite_ref-brent_1-2" class="reference"><a href="#cite_note-brent-1"><span>[</span>2<span>]</span></a></sup> describes the results of testing a <a href="http://en.m.wikipedia.org/wiki/Linear_congruential_generator" title="Linear congruential generator">linear congruential generator</a>
 in this fashion; its period turned out to be significantly smaller than
 advertised. For more complex generators, the sequence of values in 
which the cycle is to be found may not represent the output of the 
generator, but rather its internal state.</li>
<li>Several <a href="http://en.m.wikipedia.org/wiki/Number_theory" title="Number theory">number-theoretic</a> algorithms are based on cycle detection, including <a href="http://en.m.wikipedia.org/wiki/Pollard%27s_rho_algorithm" title="Pollard's rho algorithm">Pollard's rho algorithm</a> for integer factorization<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>11<span>]</span></a></sup> and his related <a href="http://en.m.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm" title="Pollard's kangaroo algorithm">kangaroo algorithm</a> for the <a href="http://en.m.wikipedia.org/wiki/Discrete_logarithm" title="Discrete logarithm">discrete logarithm</a> problem.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>12<span>]</span></a></sup>
</li>
<li>In <a href="http://en.m.wikipedia.org/wiki/Cryptography" title="Cryptography">cryptographic</a> applications, the ability to find two distinct values <i>x</i><sub>μ−-1</sub> and <i>x</i><sub>λ+μ−-1</sub> mapped by some cryptographic function ƒ to the same value <i>x</i><sub>μ</sub> may indicate a weakness in ƒ. For instance, Quisquater and Delescaille<sup id="cite_ref-qd_7-1" class="reference"><a href="#cite_note-qd-7"><span>[</span>8<span>]</span></a></sup> apply cycle detection algorithms in the search for a message and a pair of <a href="http://en.m.wikipedia.org/wiki/Data_Encryption_Standard" title="Data Encryption Standard">Data Encryption Standard</a> keys that map that message to the same encrypted value; Kaliski, Rivest, and Sherman<sup id="cite_ref-krs_12-0" class="reference"><a href="#cite_note-krs-12"><span>[</span>13<span>]</span></a></sup> also use cycle detection algorithms to attack DES. The technique may also be used to find a <a href="http://en.m.wikipedia.org/wiki/Hash_collision" title="Hash collision" class="mw-redirect">collision</a> in a <a href="http://en.m.wikipedia.org/wiki/Cryptographic_hash_function" title="Cryptographic hash function">cryptographic hash function</a>.</li>
<li>Cycle detection may be helpful as a way of discovering <a href="http://en.m.wikipedia.org/wiki/Infinite_loop" title="Infinite loop">infinite loops</a> in certain types of <a href="http://en.m.wikipedia.org/wiki/Computer_program" title="Computer program">computer programs</a>.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>14<span>]</span></a></sup>
</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29" title="Oscillator (cellular automaton)">Periodic configurations</a> in <a href="http://en.m.wikipedia.org/wiki/Cellular_automaton" title="Cellular automaton">cellular automaton</a> simulations may be found by applying cycle detection algorithms to the sequence of automaton states.<sup id="cite_ref-nivasch_2-3" class="reference"><a href="#cite_note-nivasch-2"><span>[</span>3<span>]</span></a></sup>
</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Shape_analysis_%28software%29" title="Shape analysis (software)" class="mw-redirect">Shape analysis</a> of <a href="http://en.m.wikipedia.org/wiki/Linked_list" title="Linked list">linked list</a>
 data structures is a technique for verifying the correctness of an 
algorithm using those structures. If a node in the list incorrectly 
points to an earlier node in the same list, the structure will form a 
cycle that can be detected by these algorithms.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>15<span>]</span></a></sup>
</li>
<li>Teske<sup id="cite_ref-teske_4-1" class="reference"><a href="#cite_note-teske-4"><span>[</span>5<span>]</span></a></sup> describes applications in <a href="http://en.m.wikipedia.org/wiki/Computational_group_theory" title="Computational group theory">computational group theory</a>: determining the structure of an <a href="http://en.m.wikipedia.org/wiki/Abelian_group" title="Abelian group">Abelian group</a> from a set of its generators. The cryptographic algorithms of Kaliski et al.<sup id="cite_ref-krs_12-1" class="reference"><a href="#cite_note-krs-12"><span>[</span>13<span>]</span></a></sup> may also be viewed as attempting to infer the structure of an unknown group.</li>
<li>Fich<sup id="cite_ref-fich_8-1" class="reference"><a href="#cite_note-fich-8"><span>[</span>9<span>]</span></a></sup> briefly mentions an application to <a href="http://en.m.wikipedia.org/wiki/Computer_simulation" title="Computer simulation">computer simulation</a> of <a href="http://en.m.wikipedia.org/wiki/Celestial_mechanics" title="Celestial mechanics">celestial mechanics</a>, which she attributes to <a href="http://en.m.wikipedia.org/wiki/William_Kahan" title="William Kahan">William Kahan</a>. In this application, cycle detection in the <a href="http://en.m.wikipedia.org/wiki/Phase_space" title="Phase space">phase space</a> of an orbital system may be used to determine whether the system is periodic to within the accuracy of the simulation.</li>
</ul>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_6">
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text">Floyd describes algorithms for listing all simple cycles in a <a href="http://en.m.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a> in a 1967 paper: <span class="citation" id="CITEREFFloyd1967"><a href="http://en.m.wikipedia.org/wiki/Robert_W._Floyd" title="Robert W. Floyd">Floyd, R.W.</a> (1967), <a rel="nofollow" class="external text" href="http://doi.acm.org/10.1145/321420.321422">"Non-deterministic Algorithms"</a>, <i>J. ACM</i> <b>14</b> (4): 636–644, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F321420.321422">10.1145/321420.321422</a><span class="printonly">, <a rel="nofollow" class="external free" href="http://doi.acm.org/10.1145/321420.321422">http://doi.acm.org/10.1145/321420.321422</a></span></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Non-deterministic+Algorithms&amp;rft.jtitle=J.+ACM&amp;rft.aulast=Floyd&amp;rft.aufirst=R.W.&amp;rft.au=Floyd%2C%26%2332%3BR.W.&amp;rft.date=1967&amp;rft.volume=14&amp;rft.issue=4&amp;rft.pages=636%E2%80%93644&amp;rft_id=info:doi/10.1145%2F321420.321422&amp;rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F321420.321422&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.
 However this paper does not describe the cycle-finding problem in 
functional graphs that is the subject of this article. An early 
description of the tortoise and hare algorithm appears in <span class="citation" id="CITEREFKnuth1969"><a href="http://en.m.wikipedia.org/wiki/Donald_Knuth" title="Donald Knuth">Knuth, Donald E.</a> (1969), <i>The Art of Computer Programming, vol. II: Seminumerical Algorithms</i>, Addison-Wesley</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Art+of+Computer+Programming%2C+vol.+II%3A+Seminumerical+Algorithms&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald+E.&amp;rft.au=Knuth%2C%26%2332%3BDonald+E.&amp;rft.date=1969&amp;rft.pub=Addison-Wesley&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>, exercises 6 and 7, page 7. Knuth (p.4) credits Floyd for the algorithm, without citation.</span>
</li>
<li id="cite_note-brent-1">
<span class="mw-cite-backlink">^ <a href="#cite_ref-brent_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-brent_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-brent_1-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFBrent1980"><a href="http://en.m.wikipedia.org/wiki/Richard_Brent_%28scientist%29" title="Richard Brent (scientist)" class="mw-redirect">Brent, R. P.</a> (1980), <a rel="nofollow" class="external text" href="http://wwwmaths.anu.edu.au/%7Ebrent/pd/rpb051i.pdf">"An improved Monte Carlo factorization algorithm"</a>, <i>BIT</i> <b>20</b> (2): 176–184, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FBF01933190">10.1007/BF01933190</a><span class="printonly">, <a rel="nofollow" class="external free" href="http://wwwmaths.anu.edu.au/%7Ebrent/pd/rpb051i.pdf">http://wwwmaths.anu.edu.au/~brent/pd/rpb051i.pdf</a></span></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=An+improved+Monte+Carlo+factorization+algorithm&amp;rft.jtitle=BIT&amp;rft.aulast=Brent&amp;rft.aufirst=R.+P.&amp;rft.au=Brent%2C%26%2332%3BR.+P.&amp;rft.date=1980&amp;rft.volume=20&amp;rft.issue=2&amp;rft.pages=176%E2%80%93184&amp;rft_id=info:doi/10.1007%2FBF01933190&amp;rft_id=http%3A%2F%2Fwwwmaths.anu.edu.au%2F%7Ebrent%2Fpd%2Frpb051i.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-nivasch-2">
<span class="mw-cite-backlink">^ <a href="#cite_ref-nivasch_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-nivasch_2-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-nivasch_2-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-nivasch_2-3"><sup><i><b>d</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFNivasch2004">Nivasch, Gabriel (2004), "Cycle detection using a stack", <i>Information Processing Letters</i> <b>90</b> (3): 135–140, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fj.ipl.2004.01.016">10.1016/j.ipl.2004.01.016</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Cycle+detection+using+a+stack&amp;rft.jtitle=Information+Processing+Letters&amp;rft.aulast=Nivasch&amp;rft.aufirst=Gabriel&amp;rft.au=Nivasch%2C%26%2332%3BGabriel&amp;rft.date=2004&amp;rft.volume=90&amp;rft.issue=3&amp;rft.pages=135%E2%80%93140&amp;rft_id=info:doi/10.1016%2Fj.ipl.2004.01.016&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFSchnorrLenstra1984"><a href="http://en.m.wikipedia.org/wiki/Claus_P._Schnorr" title="Claus P. Schnorr">Schnorr, Claus P.</a>; <a href="http://en.m.wikipedia.org/wiki/Hendrik_Lenstra" title="Hendrik Lenstra">Lenstra, Hendrik W.</a> (1984), "A Monte Carlo Factoring Algorithm With Linear Storage", <i>Mathematics of Computation</i> (American Mathematical Society) <b>43</b> (167): 289–311, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.2307%2F2007414">10.2307/2007414</a>, <a href="http://en.m.wikipedia.org/wiki/JSTOR" title="JSTOR">JSTOR</a>&nbsp;<a rel="nofollow" class="external text" href="http://www.jstor.org/stable/2007414">2007414</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+Monte+Carlo+Factoring+Algorithm+With+Linear+Storage&amp;rft.jtitle=Mathematics+of+Computation&amp;rft.aulast=Schnorr&amp;rft.aufirst=Claus+P.&amp;rft.au=Schnorr%2C%26%2332%3BClaus+P.&amp;rft.au=Lenstra%2C%26%2332%3BHendrik+W.&amp;rft.date=1984&amp;rft.volume=43&amp;rft.issue=167&amp;rft.pages=289%E2%80%93311&amp;rft.pub=American+Mathematical+Society&amp;rft_id=info:doi/10.2307%2F2007414&amp;rft.jstor=2007414&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-teske-4">
<span class="mw-cite-backlink">^ <a href="#cite_ref-teske_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-teske_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFTeske1998">Teske, Edlyn (1998), "A space-efficient algorithm for group structure computation", <i>Mathematics of Computation</i> <b>67</b> (224): 1637–1663, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1090%2FS0025-5718-98-00968-5">10.1090/S0025-5718-98-00968-5</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+space-efficient+algorithm+for+group+structure+computation&amp;rft.jtitle=Mathematics+of+Computation&amp;rft.aulast=Teske&amp;rft.aufirst=Edlyn&amp;rft.au=Teske%2C%26%2332%3BEdlyn&amp;rft.date=1998&amp;rft.volume=67&amp;rft.issue=224&amp;rft.pages=1637%E2%80%931663&amp;rft_id=info:doi/10.1090%2FS0025-5718-98-00968-5&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFSedgewickSzymanskiYao1982"><a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_%28computer_scientist%29" title="Robert Sedgewick (computer scientist)">Sedgewick, Robert</a>; Szymanski, Thomas G.; <a href="http://en.m.wikipedia.org/wiki/Andrew_Yao" title="Andrew Yao">Yao, Andrew C.-C.</a> (1982), "The complexity of finding cycles in periodic functions", <i>SIAM Journal on Computing</i> <b>11</b> (2): 376–390, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1137%2F0211030">10.1137/0211030</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=The+complexity+of+finding+cycles+in+periodic+functions&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.aulast=Sedgewick&amp;rft.aufirst=Robert&amp;rft.au=Sedgewick%2C%26%2332%3BRobert&amp;rft.au=Szymanski%2C%26%2332%3BThomas+G.&amp;rft.au=Yao%2C%26%2332%3BAndrew+C.-C.&amp;rft.date=1982&amp;rft.volume=11&amp;rft.issue=2&amp;rft.pages=376%E2%80%93390&amp;rft_id=info:doi/10.1137%2F0211030&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFvan_OorschotWiener1999">van Oorschot, Paul C.; Wiener, Michael J. (1999), "Parallel collision search with cryptanalytic applications", <i>Journal of Cryptology</i> <b>12</b> (1): 1–28, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FPL00003816">10.1007/PL00003816</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Parallel+collision+search+with+cryptanalytic+applications&amp;rft.jtitle=Journal+of+Cryptology&amp;rft.aulast=van+Oorschot&amp;rft.aufirst=Paul+C.&amp;rft.au=van+Oorschot%2C%26%2332%3BPaul+C.&amp;rft.au=Wiener%2C%26%2332%3BMichael+J.&amp;rft.date=1999&amp;rft.volume=12&amp;rft.issue=1&amp;rft.pages=1%E2%80%9328&amp;rft_id=info:doi/10.1007%2FPL00003816&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-qd-7">
<span class="mw-cite-backlink">^ <a href="#cite_ref-qd_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-qd_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFQuisquaterDelescaille">Quisquater, J.-J.; Delescaille, J.-P., <a rel="nofollow" class="external text" href="http://www.springerlink.com/content/0wnq56dava5nnm17/">"How easy is collision search? Application to DES"</a>, <i>Advances in Cryptology – EUROCRYPT '89, Workshop on the Theory and Application of Cryptographic Techniques</i>, Lecture Notes in Computer Science, <b>434</b>, Springer-Verlag, pp.&nbsp;429–434<span class="printonly">, <a rel="nofollow" class="external free" href="http://www.springerlink.com/content/0wnq56dava5nnm17/">http://www.springerlink.com/content/0wnq56dava5nnm17/</a></span></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=How+easy+is+collision+search%3F+Application+to+DES&amp;rft.atitle=Advances+in+Cryptology+%E2%80%93+EUROCRYPT+%2789%2C+Workshop+on+the+Theory+and+Application+of+Cryptographic+Techniques&amp;rft.aulast=Quisquater&amp;rft.aufirst=J.-J.&amp;rft.au=Quisquater%2C%26%2332%3BJ.-J.&amp;rft.au=Delescaille%2C%26%2332%3BJ.-P.&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.volume=434&amp;rft.pages=pp.%26nbsp%3B429%E2%80%93434&amp;rft.pub=Springer-Verlag&amp;rft_id=http%3A%2F%2Fwww.springerlink.com%2Fcontent%2F0wnq56dava5nnm17%2F&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-fich-8">
<span class="mw-cite-backlink">^ <a href="#cite_ref-fich_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-fich_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFFich1981">Fich, Faith Ellen (1981), "Lower bounds for the cycle detection problem", <i>Proc. 13th ACM Symp. Theory of Computation</i>, pp.&nbsp;96–105, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F800076.802462">10.1145/800076.802462</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Lower+bounds+for+the+cycle+detection+problem&amp;rft.atitle=Proc.+13th+ACM+Symp.+Theory+of+Computation&amp;rft.aulast=Fich&amp;rft.aufirst=Faith+Ellen&amp;rft.au=Fich%2C%26%2332%3BFaith+Ellen&amp;rft.date=1981&amp;rft.pages=pp.%26nbsp%3B96%E2%80%93105&amp;rft_id=info:doi/10.1145%2F800076.802462&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-9">
<span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFAllenderKlawe1985"><a href="http://en.m.wikipedia.org/wiki/Eric_Allender" title="Eric Allender">Allender, Eric W.</a>; <a href="http://en.m.wikipedia.org/wiki/Maria_Klawe" title="Maria Klawe">Klawe, Maria M.</a> (1985), "Improved lower bounds for the cycle detection problem", <i>Theoretical Computer Science</i> <b>36</b> (2–3): 231–237, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0304-3975%2885%2990044-1">10.1016/0304-3975(85)90044-1</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Improved+lower+bounds+for+the+cycle+detection+problem&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.aulast=Allender&amp;rft.aufirst=Eric+W.&amp;rft.au=Allender%2C%26%2332%3BEric+W.&amp;rft.au=Klawe%2C%26%2332%3BMaria+M.&amp;rft.date=1985&amp;rft.volume=36&amp;rft.issue=2%E2%80%933&amp;rft.pages=231%E2%80%93237&amp;rft_id=info:doi/10.1016%2F0304-3975%2885%2990044-1&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-10">
<span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFPollard1975">Pollard, J. M. (1975), "A Monte Carlo method for factorization", <i>BIT</i> <b>15</b> (3): 331–334, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FBF01933667">10.1007/BF01933667</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+Monte+Carlo+method+for+factorization&amp;rft.jtitle=BIT&amp;rft.aulast=Pollard&amp;rft.aufirst=J.+M.&amp;rft.au=Pollard%2C%26%2332%3BJ.+M.&amp;rft.date=1975&amp;rft.volume=15&amp;rft.issue=3&amp;rft.pages=331%E2%80%93334&amp;rft_id=info:doi/10.1007%2FBF01933667&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-11">
<span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFPollard1978">Pollard, J. M. (1978), "Monte Carlo methods for index computation (mod <i>p</i>)", <i>Math. Comp.</i> (American Mathematical Society) <b>32</b> (143): 918–924, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.2307%2F2006496">10.2307/2006496</a>, <a href="http://en.m.wikipedia.org/wiki/JSTOR" title="JSTOR">JSTOR</a>&nbsp;<a rel="nofollow" class="external text" href="http://www.jstor.org/stable/2006496">2006496</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Monte+Carlo+methods+for+index+computation+%28mod+%27%27p%27%27%29&amp;rft.jtitle=Math.+Comp.&amp;rft.aulast=Pollard&amp;rft.aufirst=J.+M.&amp;rft.au=Pollard%2C%26%2332%3BJ.+M.&amp;rft.date=1978&amp;rft.volume=32&amp;rft.issue=143&amp;rft.pages=918%E2%80%93924&amp;rft.pub=American+Mathematical+Society&amp;rft_id=info:doi/10.2307%2F2006496&amp;rft.jstor=2006496&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-krs-12">
<span class="mw-cite-backlink">^ <a href="#cite_ref-krs_12-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-krs_12-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFKaliskiRivestSherman1988">Kaliski, Burton S., Jr.; <a href="http://en.m.wikipedia.org/wiki/Ron_Rivest" title="Ron Rivest">Rivest, Ronald L.</a>; Sherman, Alan T. (1988), "Is the Data Encryption Standard a group? (Results of cycling experiments on DES)", <i>Journal of Cryptology</i> <b>1</b> (1): 3–36, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FBF00206323">10.1007/BF00206323</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Is+the+Data+Encryption+Standard+a+group%3F+%28Results+of+cycling+experiments+on+DES%29&amp;rft.jtitle=Journal+of+Cryptology&amp;rft.aulast=Kaliski&amp;rft.aufirst=Burton+S.%2C+Jr.&amp;rft.au=Kaliski%2C%26%2332%3BBurton+S.%2C+Jr.&amp;rft.au=Rivest%2C%26%2332%3BRonald+L.&amp;rft.au=Sherman%2C%26%2332%3BAlan+T.&amp;rft.date=1988&amp;rft.volume=1&amp;rft.issue=1&amp;rft.pages=3%E2%80%9336&amp;rft_id=info:doi/10.1007%2FBF00206323&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-13">
<span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFVan_Gelder1987">Van Gelder, Allen (1987), "Efficient loop detection in Prolog using the tortoise-and-hare technique", <i>Journal of Logic Programming</i> <b>4</b> (1): 23–31, <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0743-1066%2887%2990020-3">10.1016/0743-1066(87)90020-3</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Efficient+loop+detection+in+Prolog+using+the+tortoise-and-hare+technique&amp;rft.jtitle=Journal+of+Logic+Programming&amp;rft.aulast=Van+Gelder&amp;rft.aufirst=Allen&amp;rft.au=Van+Gelder%2C%26%2332%3BAllen&amp;rft.date=1987&amp;rft.volume=4&amp;rft.issue=1&amp;rft.pages=23%E2%80%9331&amp;rft_id=info:doi/10.1016%2F0743-1066%2887%2990020-3&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
<li id="cite_note-14">
<span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation" id="CITEREFAugustonHon1997">Auguston, Mikhail; Hon, Miu Har (1997), <a rel="nofollow" class="external text" href="http://www.ep.liu.se/ea/cis/1997/009/04/">"Assertions for Dynamic Shape Analysis of List Data Structures"</a>, <i>AADEBUG '97, Proceedings of the Third International Workshop on Automatic Debugging</i>, Linköping Electronic Articles in Computer and Information Science, <a href="http://en.m.wikipedia.org/wiki/Link%C3%B6ping_University" title="Linköping University">Linköping University</a>, pp.&nbsp;37–42<span class="printonly">, <a rel="nofollow" class="external free" href="http://www.ep.liu.se/ea/cis/1997/009/04/">http://www.ep.liu.se/ea/cis/1997/009/04/</a></span></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Assertions+for+Dynamic+Shape+Analysis+of+List+Data+Structures&amp;rft.atitle=AADEBUG+%2797%2C+Proceedings+of+the+Third+International+Workshop+on+Automatic+Debugging&amp;rft.aulast=Auguston&amp;rft.aufirst=Mikhail&amp;rft.au=Auguston%2C%26%2332%3BMikhail&amp;rft.au=Hon%2C%26%2332%3BMiu+Har&amp;rft.date=1997&amp;rft.series=Link%C3%B6ping+Electronic+Articles+in+Computer+and+Information+Science&amp;rft.pages=pp.%26nbsp%3B37%E2%80%9342&amp;rft.pub=%5B%5BLink%C3%B6ping+University%5D%5D&amp;rft_id=http%3A%2F%2Fwww.ep.liu.se%2Fea%2Fcis%2F1997%2F009%2F04%2F&amp;rfr_id=info:sid/en.wikipedia.org:Cycle_detection"><span style="display: none;">&nbsp;</span></span>.</span>
</li>
</ol>
</div>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li>Gabriel Nivasch, <a rel="nofollow" class="external text" href="http://www.gabrielnivasch.org/fun/cycle-detection">The Cycle Detection Problem and the Stack Algorithm</a>.</li>
<li>
<a rel="nofollow" class="external text" href="http://c2.com/cgi/wiki/Curry?TortoiseAndHare">Tortoise and Hare</a>, Portland Pattern Repository</li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Cycle_detection&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Cycle+detection&amp;mobiletoken=dc83e2c6ae93b1fadc6882196f529c1b" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Cycle_detection&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Cycle+detection&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Cycle_detection_files/load_002.php" type="text/javascript"></script>
<script src="Cycle_detection_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>