<!DOCTYPE html>
<html class="jsEnabled page-loading" dir="ltr" lang="en"><head>
		<title>Universal hashing - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Universal_hashing_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 4 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Universal_hashing">
	</head>
	<body class="mobile">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Universal_hashing_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Universal_hashing_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Universal_hashing_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Universal_hashing" selected="selected">English</option><option value="//de.m.wikipedia.org/wiki/Universelle_Hash-Funktion">Deutsch</option><option value="//ko.m.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EB%B2%84%EC%84%A4_%ED%95%B4%EC%8B%B1">한국어</option><option value="//fa.m.wikipedia.org/wiki/%D8%AF%D8%B1%D9%87%D9%85_%D8%B3%D8%A7%D8%B2%DB%8C_%D8%AC%D9%87%D8%A7%D9%86%DB%8C">فارسی</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Universal hashing</h1>			
<p>Using <b>universal hashing</b> (in a <a href="http://en.m.wikipedia.org/wiki/Randomized_algorithm" title="Randomized algorithm">randomized algorithm</a> or data structure) refers to selecting a <a href="http://en.m.wikipedia.org/wiki/Hash_function" title="Hash function">hash function</a>
 at random from a family of hash functions with a certain mathematical 
property (see definition below). This guarantees a low number of 
collisions in expectation, even if the data is chosen by an adversary. 
Many universal families are known (for hashing integers, vectors, 
strings), and their evaluation is often very efficient. Universal 
hashing has numerous uses in computer science, for example in 
implementations of <a href="http://en.m.wikipedia.org/wiki/Hash_table" title="Hash table">hash tables</a>, randomized algorithms, and <a href="http://en.m.wikipedia.org/wiki/Cryptography" title="Cryptography">cryptography</a>.</p>
<div class="section"><h2 class="section_heading" id="section_1"><span id="Introduction">Introduction</span></h2><div class="content_block" id="content_1">
<div class="rellink boilerplate seealso">See also: <a href="http://en.m.wikipedia.org/wiki/Hash_function" title="Hash function">Hash function</a>
</div>
<p>Assume we want to map keys from some universe <img class="tex" alt="U" src="Universal_hashing_files/4c614360da93c0a041b22e537de151eb.png"> into <img class="tex" alt="m" src="Universal_hashing_files/6f8f57715090da2632453988d9a1501b.png"> bins (labelled <img class="tex" alt="[m] = \{0, \dots, m-1\}" src="Universal_hashing_files/996198cf634c01f7df11d24f34f17980.png">). The algorithm will have to handle some data set <img class="tex" alt="S \subseteq U" src="Universal_hashing_files/8e8fd947728f32b7e0b5d6a1cbf753a3.png"> of <img class="tex" alt="|S|=n" src="Universal_hashing_files/1114c80010a66a42faea3d20cfa4cbd2.png"> keys, which is not known in advance. Usually, the goal of hashing is to obtain a low number of collisions (keys from <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png"> that land in the same bin). A deterministic hash function cannot offer any guarantee in an adversarial setting if the size of <img class="tex" alt="U" src="Universal_hashing_files/4c614360da93c0a041b22e537de151eb.png"> is greater than <img class="tex" alt="m^2" src="Universal_hashing_files/b8c460643608d59ace5819d3971b4261.png">, since the adversary may choose <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png"> to be precisely the <a href="http://en.m.wikipedia.org/wiki/Image_%28mathematics%29" title="Image (mathematics)">preimage</a>
 of a bin. This means that all data keys land in the same bin, making 
hashing useless. Furthermore, a deterministic hash function does not 
allow for <i>rehashing</i>: sometimes the input data turns out to be bad
 for the hash function (e.g. there are too many collisions), so one 
would like to change the hash function.</p>
<p>The solution to these problems is to pick a function randomly from a family of hash functions. A family of functions <img class="tex" alt="H = \{ h&nbsp;: U \to [m] \}" src="Universal_hashing_files/4f541cb630b1b1301c0aecfc337b0844.png"> is called a <b>universal family</b> if, <img class="tex" alt="\forall x, y \in U, ~ x\ne y: ~~ \Pr_{h\in H} [h(x) = h(y)] \le \frac{1}{m}" src="Universal_hashing_files/030fb4de473ae00dd33831fca8d4cbaa.png">.</p>
<p>In other words, any two keys of the universe collide with probability at most <img class="tex" alt="1/m" src="Universal_hashing_files/66e395e2c81b71fbbe0aa725fd4e8c82.png"> when the hash function <img class="tex" alt="h" src="Universal_hashing_files/2510c39011c5be704182423e3a695e91.png"> is drawn randomly from <img class="tex" alt="H" src="Universal_hashing_files/c1d9f50f86825a1a2302ec2449c17196.png">.
 This is exactly the probability of collision we would expect if the 
hash function assigned truly random hash codes to every key. Sometimes, 
the definition is relaxed to allow collision probability <img class="tex" alt="O(1/m)" src="Universal_hashing_files/7e5471555a2941aa1b1b96e8197fe10b.png">. This concept was introduced by Carter and Wegman<sup id="cite_ref-CW77_0-0" class="reference"><a href="#cite_note-CW77-0"><span>[</span>1<span>]</span></a></sup> in 1977, and has found numerous applications in computer science (see, for example <sup id="cite_ref-Miltersen_1-0" class="reference"><a href="#cite_note-Miltersen-1"><span>[</span>2<span>]</span></a></sup>). If we have an upper bound of <img class="tex" alt="\epsilon&lt;1" src="Universal_hashing_files/77f9c753a5926d6a7394057176713433.png"> on the collision probability, we say that we have <img class="tex" alt="\epsilon" src="Universal_hashing_files/c50b9e82e318d4c163e4b1b060f7daf5.png">-almost universality.</p>
<p>Many, but not all, universal families have the following stronger <b>uniform difference property</b>:</p>
<dl>
<dd>
<img class="tex" alt="\forall x,y\in U, ~ x\ne y" src="Universal_hashing_files/3b2570194a921d4e40bdb721b8d6ba9a.png">, when <img class="tex" alt="h" src="Universal_hashing_files/2510c39011c5be704182423e3a695e91.png"> is drawn randomly from the family <img class="tex" alt="H" src="Universal_hashing_files/c1d9f50f86825a1a2302ec2449c17196.png">, the difference <img class="tex" alt="h(x)-h(y) ~\bmod~ m" src="Universal_hashing_files/e715664ac3f594a6469d8847f9c10b5a.png"> is uniformly distributed in <img class="tex" alt="[m]" src="Universal_hashing_files/efc831aabf9ade051f781ccb54c2dcdb.png">. Note that the definition of universality is only concerned with whether <img class="tex" alt="h(x)-h(y)=0" src="Universal_hashing_files/3528fe167d6dd743b46460ace71f47cb.png">, which counts collisions. The uniform difference property is stronger.</dd>
</dl>
<p>(Similarly, a universal family can be XOR universal if <img class="tex" alt="\forall x,y\in U, ~ x\ne y" src="Universal_hashing_files/3b2570194a921d4e40bdb721b8d6ba9a.png">, the value <img class="tex" alt="h(x) \oplus h(y) ~\bmod~ m" src="Universal_hashing_files/ba53d36c7576b80dd47024ac9fdea9eb.png"> is uniformly distributed in <img class="tex" alt="[m]" src="Universal_hashing_files/efc831aabf9ade051f781ccb54c2dcdb.png"> where <img class="tex" alt="\oplus" src="Universal_hashing_files/b71edd70fcad670e99a9912ba5e55d77.png"> is the bitwise exclusive or operation. This is only possible if <img class="tex" alt="m" src="Universal_hashing_files/6f8f57715090da2632453988d9a1501b.png"> is a power of two.)</p>
<p>An even stronger condition is <a href="http://en.m.wikipedia.org/wiki/Pairwise_independent" title="Pairwise independent" class="mw-redirect">pairwise independence</a>: we have this property when <img class="tex" alt="\forall x,y\in U, ~ x\ne y" src="Universal_hashing_files/3b2570194a921d4e40bdb721b8d6ba9a.png"> we have the probability that <img class="tex" alt="x,y" src="Universal_hashing_files/f10bc3c94b77e1d6b9f98106daf335c1.png"> will hash to any pair of hash values <img class="tex" alt="z_1, z_2" src="Universal_hashing_files/69748c0e35087dc0d3c54ab0a0d41cd6.png"> is as if they were perfectly random: <img class="tex" alt="P(h(x)=z_1 \land h(y)=z_2)= 1/m^2" src="Universal_hashing_files/b0e69b8b176b5027044991cf53227482.png">. Pairwise independence is sometimes called strong universality.</p>
<p>Another property is uniformity. We say that a family is uniform if all hash values are equally likely: <img class="tex" alt="P(h(x)=z)=1/m" src="Universal_hashing_files/ff40a0f5f45ff7d42ee70296897240a7.png"> for any hash value <img class="tex" alt="z" src="Universal_hashing_files/fbade9e36a3f36d3d676c1b808451dd7.png">. Universality does not imply uniformity. However, strong universality does imply uniformity.</p>
<p>Given a family with the uniform distance property, one can produce a 
pairwise independent or strongly universal hash family by adding a 
uniformly distributed random constant with values in <img class="tex" alt="[m]" src="Universal_hashing_files/efc831aabf9ade051f781ccb54c2dcdb.png"> to the hash functions. (Similarly, if <img class="tex" alt="m" src="Universal_hashing_files/6f8f57715090da2632453988d9a1501b.png">
 is a power of two, we can achieve pairwise independence from an XOR 
universal hash family by doing an exclusive or with a uniformly 
distributed random constant.) Since a shift by a constant is sometimes 
irrelevant in applications (e.g. hash tables), a careful distinction 
between the uniform distance property and pairwise independent is 
sometimes not made.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>3<span>]</span></a></sup></p>
<p>For some applications (such as hash tables), it is important for the 
least significant bits of the hash values to be also universal. When a 
family is strongly universal, this is guaranteed: if <img class="tex" alt="H" src="Universal_hashing_files/c1d9f50f86825a1a2302ec2449c17196.png"> is a strongly universal family with <img class="tex" alt="m=2^L" src="Universal_hashing_files/d4b2d170152c718c54e1d9d3bb9f0211.png">, then the family made of the functions <img class="tex" alt="h \bmod{2^{L'}}" src="Universal_hashing_files/efececd1b42a4195efeb11ccd3b3f894.png"> for all <img class="tex" alt="h \in H" src="Universal_hashing_files/3675c32b8a780f2e55bc4c046f1acfd3.png"> is also strongly universal for <img class="tex" alt="L'\leq L" src="Universal_hashing_files/42dec5642ebd5f959fe63db4d5c734b1.png">. Unfortunately, the same is not true of (merely) universal families. For example the family made of the identity function <img class="tex" alt="h(x)=x" src="Universal_hashing_files/c489dbb15f7d1ce4d75dffecc7102bb2.png"> is clearly universal, but the family made of the function <img class="tex" alt="h(x)=x  \bmod{2^{L'}}" src="Universal_hashing_files/b28b2b42ed20af3682b2aa4e8274e2ac.png"> fails to be universal.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><span id="Mathematical_guarantees">Mathematical guarantees</span></h2><div class="content_block" id="content_2">
<p>For any fixed set <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png"> of <img class="tex" alt="n" src="Universal_hashing_files/7b8b965ad4bca0e41ab51de7b31363a1.png"> keys, using a universal family guarantees the following properties.</p>
<ol>
<li>For any fixed <img class="tex" alt="x" src="Universal_hashing_files/9dd4e461268c8034f5c8564e155c67a6.png"> in <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png">, the expected number of keys in the bin <img class="tex" alt="h(x)" src="Universal_hashing_files/ca8e608169b20a94570ac837e8ba0833.png"> is <img class="tex" alt="n/m" src="Universal_hashing_files/a40e90362648982ac44f754f22d4f677.png">. When implementing hash tables by <a href="http://en.m.wikipedia.org/wiki/Hash_table#Separate_chaining" title="Hash table">chaining</a>, this number is proportional to the expected running time of an operation involving the key <img class="tex" alt="x" src="Universal_hashing_files/9dd4e461268c8034f5c8564e155c67a6.png"> (for example a query, insertion or deletion).</li>
<li>The expected number of pairs of keys <img class="tex" alt="x,y" src="Universal_hashing_files/f10bc3c94b77e1d6b9f98106daf335c1.png"> in <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png"> with <img class="tex" alt="x\ne y" src="Universal_hashing_files/73c7070fbc887c38daea22738774c01c.png"> that collide (<img class="tex" alt="h(x) = h(y)" src="Universal_hashing_files/7ad9b0846fd98d4bcd01575c83e0c383.png">) is bounded above by <img class="tex" alt="n(n-1)/2m" src="Universal_hashing_files/a74b13f822d0c55a1c9beb0961bbd3c5.png">, which is of order <img class="tex" alt="O(n^2/m)" src="Universal_hashing_files/af900183f62d33b94a7c200e2b8e3936.png">. When the number of bins, <img class="tex" alt="m" src="Universal_hashing_files/6f8f57715090da2632453988d9a1501b.png">, is <img class="tex" alt="O(n)" src="Universal_hashing_files/7ba55e7c64a9405a0b39a1107e90ca94.png">, the expected number of collisions is <img class="tex" alt="O(n)" src="Universal_hashing_files/7ba55e7c64a9405a0b39a1107e90ca94.png">. When hashing into <img class="tex" alt="n^2" src="Universal_hashing_files/b08b1c6ec09f20907eb1d6f1392c01c6.png"> bins, there are no collisions at all with probability at least a half.</li>
<li>The expected number of keys in bins with at least <img class="tex" alt="t" src="Universal_hashing_files/e358efa489f58062f10dd7316b65649e.png"> keys in them is bounded above by <img class="tex" alt="2n/(t-2(n/m)+1)" src="Universal_hashing_files/463c447a31dd7d475123f381c9bfedc8.png">.<sup id="cite_ref-BDP_3-0" class="reference"><a href="#cite_note-BDP-3"><span>[</span>4<span>]</span></a></sup> Thus, if the capacity of each bin is capped to three times the average size (<img class="tex" alt="t = 3n/m" src="Universal_hashing_files/8afbe7c0d1bececb4eadc894a4eef55a.png">), the total number of keys in overflowing bins is at most <img class="tex" alt="O(m)" src="Universal_hashing_files/0e2ae329177722b1818828e92b441032.png">. This only holds with a hash family whose collision probability is bounded above by <img class="tex" alt="1/m" src="Universal_hashing_files/66e395e2c81b71fbbe0aa725fd4e8c82.png">. If a weaker definition is used, bounding it by <img class="tex" alt="O(1/m)" src="Universal_hashing_files/7e5471555a2941aa1b1b96e8197fe10b.png">, this result is no longer true.<sup id="cite_ref-BDP_3-1" class="reference"><a href="#cite_note-BDP-3"><span>[</span>4<span>]</span></a></sup>
</li>
</ol>
<p>As the above guarantees hold for any fixed set <img class="tex" alt="S" src="Universal_hashing_files/5dbc98dcc983a70728bd082d1a47546e.png">,
 they hold if the data set is chosen by an adversary. However, the 
adversary has to make this choice before (or independent of) the 
algorithm's random choice of a hash function. If the adversary can 
observe the random choice of the algorithm, randomness serves no 
purpose, and the situation is the same as deterministic hashing.</p>
<p>The second and third guarantee are typically used in conjunction with <a href="http://en.m.wikipedia.org/wiki/Double_hashing" title="Double hashing">rehashing</a>. For instance, a randomized algorithm may be prepared to handle some <img class="tex" alt="O(n)" src="Universal_hashing_files/7ba55e7c64a9405a0b39a1107e90ca94.png"> number of collisions. If it observes too many collisions, it chooses another random <img class="tex" alt="h" src="Universal_hashing_files/2510c39011c5be704182423e3a695e91.png"> from the family and repeats. Universality guarantees that the number of repetitions is a <a href="http://en.m.wikipedia.org/wiki/Geometric_distribution" title="Geometric distribution">geometric random variable</a>.</p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><span id="Constructions">Constructions</span></h2><div class="content_block" id="content_3">
<p>Since any computer data can be represented as one or more machine 
words, one generally needs hash functions for three types of domains: 
machine words ("integers"); fixed-length vectors of machine words; and 
variable-length vectors ("strings").</p>
<h3> <span class="mw-headline" id="Hashing_integers">Hashing integers</span>
</h3>
<p>This section refers to the case of hashing integers that fit in 
machines words; thus, operations like multiplication, addition, 
division, etc. are cheap machine-level instructions. Let the universe to
 be hashed be <img class="tex" alt="U = \{0, \dots, u-1\}" src="Universal_hashing_files/69b28b2263e01b690703cd567eca7a5f.png">.</p>
<p>The original proposal of Carter and Wegman<sup id="cite_ref-CW77_0-1" class="reference"><a href="#cite_note-CW77-0"><span>[</span>1<span>]</span></a></sup> was to pick a prime <img class="tex" alt="p \ge u" src="Universal_hashing_files/77789787d4a22a8eb6391ce7ecfcdaeb.png"> and define</p>
<dl>
<dd><img class="tex" alt=" h_{a,b}(x) = ((ax + b)~\bmod ~ p)~\bmod ~ m" src="Universal_hashing_files/89428f50e7110f9e50f98281ab80ee36.png"></dd>
</dl>
<p>where <img class="tex" alt="a,b" src="Universal_hashing_files/b345e1dc09f20fdefdea469f09167892.png"> are randomly chosen integers modulo <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png"> with <img class="tex" alt="a \neq 0" src="Universal_hashing_files/df44347863ac17dc898a13f44f681d01.png">. Technically, adding <img class="tex" alt="b" src="Universal_hashing_files/92eb5ffee6ae2fec3ad71c777531578f.png"> is not needed for universality (but it does make the hash function 2-independent).</p>
<p>To see that <img class="tex" alt="H = \{ h_{a,b} \}" src="Universal_hashing_files/5ff1199d4718b38dfe6d7dfea317ba1b.png"> is a universal family, note that <img class="tex" alt="h(x) = h(y)" src="Universal_hashing_files/7ad9b0846fd98d4bcd01575c83e0c383.png"> only holds when</p>
<dl>
<dd><img class="tex" alt="ax+b \equiv ay + b + i\cdot m \pmod{p}" src="Universal_hashing_files/b47b7c524233b6c08179076dc630f715.png"></dd>
</dl>
<p>for some integer <img class="tex" alt="i" src="Universal_hashing_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> between <img class="tex" alt="0" src="Universal_hashing_files/cfcd208495d565ef66e7dff9f98764da.png"> and <img class="tex" alt="p/m" src="Universal_hashing_files/18657a80050f9b39dc140f0c7010defb.png">. If <img class="tex" alt="x \neq y" src="Universal_hashing_files/73c7070fbc887c38daea22738774c01c.png">, their difference, <img class="tex" alt="x-y" src="Universal_hashing_files/19d59c7d61b117f2865b20b59c8b70f7.png"> is nonzero and has an inverse modulo <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png">. Solving for <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png">,</p>
<dl>
<dd>
<img class="tex" alt="a \equiv i\cdot m \cdot (x-y)^{-1} \pmod{p}" src="Universal_hashing_files/78c407c86d21a1f81a727ca6112515f1.png">.</dd>
</dl>
<p>There are <img class="tex" alt="p-1" src="Universal_hashing_files/70ff83728fb2701cbc52fac8df762bf1.png"> possible choices for <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> (since <img class="tex" alt="a=0" src="Universal_hashing_files/ded681eaa02d11064c9a469dd1b3e04c.png"> is excluded) and, varying <img class="tex" alt="i" src="Universal_hashing_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> in the allowed range, <img class="tex" alt="\lfloor p/m \rfloor" src="Universal_hashing_files/4c8b77b3e731dc186dfc70812dec631c.png"> possible values for the right hand side. Thus the collision probability is</p>
<dl>
<dd><img class="tex" alt="\lfloor p/m \rfloor / (p-1)" src="Universal_hashing_files/719fcb903bc73e97688e3b3337dcae44.png"></dd>
</dl>
<p>which tends to <img class="tex" alt="1/m" src="Universal_hashing_files/66e395e2c81b71fbbe0aa725fd4e8c82.png"> for large <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png"> as required. This analysis also shows that <img class="tex" alt="b" src="Universal_hashing_files/92eb5ffee6ae2fec3ad71c777531578f.png"> does not have to be randomised in order to have universality.</p>
<p>Another way to see <img class="tex" alt="H" src="Universal_hashing_files/c1d9f50f86825a1a2302ec2449c17196.png"> is a universal family is via the notion of <a href="http://en.m.wikipedia.org/wiki/Statistical_distance" title="Statistical distance">statistical distance</a>. Write the difference <img class="tex" alt="h(x) - h(y)" src="Universal_hashing_files/cca9890d5b99f0c6f9f81b8cd3241163.png"> as</p>
<dl>
<dd>
<img class="tex" alt="h(x)-h(y) \equiv (a(x-y)~ \bmod~ p) \pmod{m}" src="Universal_hashing_files/d171adc54d2ec9ccdc6226a515654097.png">.</dd>
</dl>
<p>Since <img class="tex" alt="x - y" src="Universal_hashing_files/19d59c7d61b117f2865b20b59c8b70f7.png"> is nonzero and <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> is uniformly distributed in <img class="tex" alt="\{1,\dots,p\}" src="Universal_hashing_files/ab957e5531ec41c2ae46154d44a0cb0a.png">, it follows that <img class="tex" alt="a(x-y)" src="Universal_hashing_files/1e878283d8545e84fa5ae0c64ad5c558.png"> modulo <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png"> is also uniformly distributed in <img class="tex" alt="\{1,\dots,p\}" src="Universal_hashing_files/ab957e5531ec41c2ae46154d44a0cb0a.png">. The distribution of <img class="tex" alt="(h(x)-h(y)) ~\bmod~ m" src="Universal_hashing_files/39d6741ba516f2f4454b8f475c3a4358.png"> is thus almost uniform, up to a difference in probability of <img class="tex" alt="\pm 1/p" src="Universal_hashing_files/ac567eee0a6fef4b26e9eded313b1e3b.png"> between the samples. As a result, the statistical distance to a uniform family is <img class="tex" alt="O(m/p)" src="Universal_hashing_files/07563033a4de7e7e36e051717b7b93e0.png">, which becomes negligible when <img class="tex" alt="p \gg m" src="Universal_hashing_files/eaf978632855668be8172174460dd569.png">.</p>
<h4> <span class="mw-headline" id="Avoiding_modular_arithmetic">Avoiding modular arithmetic</span>
</h4>
<p>The state of the art for hashing integers is the <b>multiply-shift</b> scheme described by Dietzfelbinger et al. in 1997.<sup id="cite_ref-DHKP97_4-0" class="reference"><a href="#cite_note-DHKP97-4"><span>[</span>5<span>]</span></a></sup>
 By avoiding modular arithmetic, this method is much easier to implement
 and also runs significantly faster in practice (usually by at least a 
factor of four<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>6<span>]</span></a></sup>). The scheme assumes the number of bins is a power of two, <img class="tex" alt="m=2^M" src="Universal_hashing_files/04fe2259a7ced8c5385cebb1e232f9c4.png">. Let <img class="tex" alt="w" src="Universal_hashing_files/f1290186a5d0b1ceab27f4e77c0c5d68.png"> be the number of bits in a machine word. Then the hash functions are parametrised over odd positive integers <img class="tex" alt="a &lt; 2^w" src="Universal_hashing_files/d792dc1f9cd799cf896d409ca78476a4.png"> (that fit in a word of <img class="tex" alt="w" src="Universal_hashing_files/f1290186a5d0b1ceab27f4e77c0c5d68.png"> bits). To evaluate <img class="tex" alt="h_{a}(x)" src="Universal_hashing_files/b3efbfec079d7a0c56c87c010c4b7efa.png">, multiply <img class="tex" alt="x" src="Universal_hashing_files/9dd4e461268c8034f5c8564e155c67a6.png"> by <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> modulo <img class="tex" alt="2^w" src="Universal_hashing_files/87e0723e7037feff1d625225caec78a0.png"> and then keep the high order <img class="tex" alt="M" src="Universal_hashing_files/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> bits as the hash code. In mathematical notation, this is</p>
<dl>
<dd><img class="tex" alt="h_a(x) = (a\cdot x\,\, \bmod\, 2^w)\,\, \mathrm{div}\,\, 2^{w-M}" src="Universal_hashing_files/1b3276617a35fa852c55105c92f649aa.png"></dd>
</dl>
<p>and it can be implemented in <a href="http://en.m.wikipedia.org/wiki/C_%28programming_language%29" title="C (programming language)">C</a>-like programming languages by</p>
<dl>
<dd>
<img class="tex" alt="h_a(x) = " src="Universal_hashing_files/3c2901f3208cefd37832ef9607cd49ec.png"><code>(unsigned) (a*x) &gt;&gt; (w-M)</code>
</dd>
</dl>
<p>This scheme does <i>not</i> satisfy the uniform difference property and is only <i><img class="tex" alt="2/m" src="Universal_hashing_files/4e52893efe38d1d90ab63cfd1e83df57.png">-almost-universal</i>; for any <img class="tex" alt="x\neq y" src="Universal_hashing_files/73c7070fbc887c38daea22738774c01c.png">, <img class="tex" alt="\Pr\{h_a(x) = h_a(y)\} \le 2/m" src="Universal_hashing_files/5dbc0977f35140c9a19c62de3621f848.png">.</p>
<p>To understand the behavior of the hash function, notice that, if <img class="tex" alt="ax \bmod 2^w" src="Universal_hashing_files/c02eebe71114ff2ea82556c768b700e0.png"> and <img class="tex" alt="ay\bmod 2^w" src="Universal_hashing_files/c29bc5d6910c30625a8151ec9b913241.png"> have the same highest-order 'M' bits, then <img class="tex" alt="a(x-y) \bmod 2^w" src="Universal_hashing_files/71f28fc531c8e57412a0ff19c9bd2be9.png"> has either all 1's or all 0's as its highest order M bits (depending on whether <img class="tex" alt="ax \bmod 2^w" src="Universal_hashing_files/c02eebe71114ff2ea82556c768b700e0.png"> or <img class="tex" alt="ay \bmod 2^w" src="Universal_hashing_files/c29bc5d6910c30625a8151ec9b913241.png"> is larger. Assume that the least significant set bit of <img class="tex" alt="x-y" src="Universal_hashing_files/19d59c7d61b117f2865b20b59c8b70f7.png"> appears on position <img class="tex" alt="w-c" src="Universal_hashing_files/47f85f2dbdc2d846f0524067d2ce0655.png">. Since <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> is a random odd integer and odd integers have inverses in the <a href="http://en.m.wikipedia.org/wiki/Ring_%28mathematics%29" title="Ring (mathematics)">ring</a> <img class="tex" alt="Z_{2^w}" src="Universal_hashing_files/ea31d84bda468201975d0bbbfd751847.png">, it follows that <img class="tex" alt="a(x-y)\bmod 2^w" src="Universal_hashing_files/71f28fc531c8e57412a0ff19c9bd2be9.png"> will be uniformly distributed among <img class="tex" alt="w" src="Universal_hashing_files/f1290186a5d0b1ceab27f4e77c0c5d68.png">-bit integers with the least significant set bit on position <img class="tex" alt="w-c" src="Universal_hashing_files/47f85f2dbdc2d846f0524067d2ce0655.png">. The probability that these bits are all 0's or all 1's is therefore at most <img class="tex" alt="2/2^M=2/m" src="Universal_hashing_files/faaaf575a36fb7df7db5f08850d39fc6.png">. On the other hand, if <img class="tex" alt="c &lt; M" src="Universal_hashing_files/81e03b128a355abb4d90d7ca898c9f30.png">, then higher-order M bits of <img class="tex" alt="a(x-y) \bmod 2^w" src="Universal_hashing_files/71f28fc531c8e57412a0ff19c9bd2be9.png"> contain both 0's and 1's, so it is certain that <img class="tex" alt="h(x) \ne h(y)" src="Universal_hashing_files/b7a44a0dcd878c7fb7f2af68d449b9fe.png">. Finally, if <img class="tex" alt="c=M" src="Universal_hashing_files/d449922bd5d933a3c3fe9525cb921fd8.png"> then bit <img class="tex" alt="w-M" src="Universal_hashing_files/22a9b1494679181dc52202d0ba1f31ec.png"> of <img class="tex" alt="a(x-y) \bmod 2^w" src="Universal_hashing_files/71f28fc531c8e57412a0ff19c9bd2be9.png"> is 1 and <img class="tex" alt="h_a(x)=h_a(y)" src="Universal_hashing_files/c1906e302881be93518285ee1a353334.png"> if and only if bits <img class="tex" alt="w-1,\ldots,w-M+1" src="Universal_hashing_files/4521f05a61036f1293442b3fbd0d98be.png"> are also 1, which happens with probability <img class="tex" alt="1/2^{M-1}=2/m" src="Universal_hashing_files/0ff91759075539342270f1e63f01ea8a.png">.</p>
<p>This analysis is tight, as can be shown with the example <img class="tex" alt="x=2^{w-M-2}" src="Universal_hashing_files/702a86357c01a8ac39799701e9e8fc0f.png"> and <img class="tex" alt="y=3x" src="Universal_hashing_files/9c6982e6b4f47b0e55208e5f8a307781.png">. To obtain a truly 'universal' hash function, one can use the multiply-add-shift scheme</p>
<dl>
<dd><img class="tex" alt="h_{a,b}(x) = ((ax + b) \bmod 2^w)\, \mathrm{div}\, 2^{w-M}" src="Universal_hashing_files/c023e51756d9afc05f5fdbbe7c080017.png"></dd>
</dl>
<p>where <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> is a random odd positive integer with <img class="tex" alt="a &lt; 2^w" src="Universal_hashing_files/d792dc1f9cd799cf896d409ca78476a4.png"> and <img class="tex" alt="b=i2^{w/2}" src="Universal_hashing_files/a213108dc453e2d66b813fa265d571ee.png"> where <img class="tex" alt="i" src="Universal_hashing_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> is chosen at random from <img class="tex" alt="\{0,\ldots,2^{w/2}-1\}" src="Universal_hashing_files/5c0798a3102f1db700c1261550fd83b0.png">. With these choices of <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> and <img class="tex" alt="b" src="Universal_hashing_files/92eb5ffee6ae2fec3ad71c777531578f.png">, <img class="tex" alt="\Pr\{h_{a,b}(x) = h_{a,b}(y)\}\le 1/m" src="Universal_hashing_files/5c18220823d5f841fe9ac6ec914541bd.png"> for all <img class="tex" alt="x\not\equiv y\pmod{2^w}" src="Universal_hashing_files/2a75cdc2ff0919a9d9f288c2f935a544.png">.<sup id="cite_ref-w99_6-0" class="reference"><a href="#cite_note-w99-6"><span>[</span>7<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Hashing_vectors">Hashing vectors</span>
</h3>
<p>This section is concerned with hashing a fixed-length vector of machine words. Interpret the input as a vector <img class="tex" alt="\bar{x} = (x_0, \dots, x_{k-1})" src="Universal_hashing_files/c750684a42d4e3c0657860917d9a696c.png"> of <img class="tex" alt="k" src="Universal_hashing_files/8ce4b16b22b58894aa86c421e8759df3.png"> machine words (integers of <img class="tex" alt="w" src="Universal_hashing_files/f1290186a5d0b1ceab27f4e77c0c5d68.png"> bits each). If <img class="tex" alt="H" src="Universal_hashing_files/c1d9f50f86825a1a2302ec2449c17196.png"> is a universal family with the uniform difference property, the following family dating back to Carter and Wegman<sup id="cite_ref-CW77_0-2" class="reference"><a href="#cite_note-CW77-0"><span>[</span>1<span>]</span></a></sup> also has the uniform difference property (and hence is universal):</p>
<dl>
<dd>
<img class="tex" alt="h(\bar{x}) = \left( \sum_{i=0}^{k-1} h_i(x_i) \right)\,\bmod~m" src="Universal_hashing_files/9f7c62bbea7f1f784bb69e758da4e46e.png">, where each <img class="tex" alt="h_i\in H" src="Universal_hashing_files/6b8b8fd78cbb2511d6f0dbc7d1d3ab28.png"> is chosen independently at random.</dd>
</dl>
<p>If <img class="tex" alt="m" src="Universal_hashing_files/6f8f57715090da2632453988d9a1501b.png"> is a power of two, one may replace summation by exclusive or.<sup id="cite_ref-thorup09_7-0" class="reference"><a href="#cite_note-thorup09-7"><span>[</span>8<span>]</span></a></sup></p>
<p>In practice, if double-precision arithmetic is available, this is instantiated with the multiply-shift hash family of.<sup id="cite_ref-DGMP_8-0" class="reference"><a href="#cite_note-DGMP-8"><span>[</span>9<span>]</span></a></sup> Initialize the hash function with a vector <img class="tex" alt="\bar{a} = (a_0, \dots, a_{k-1})" src="Universal_hashing_files/ec4fa4a9f1aa7e71e6f6d470af855707.png"> of random <b>odd</b> integers on <img class="tex" alt="2w" src="Universal_hashing_files/ec9cbcbeaf6327c7d0b9f89df3df9423.png"> bits each. Then if the number of bins is <img class="tex" alt="m=2^M" src="Universal_hashing_files/04fe2259a7ced8c5385cebb1e232f9c4.png"> for <img class="tex" alt="M\le w" src="Universal_hashing_files/c4344c3524fb8776c327eba285999cf3.png">:</p>
<dl>
<dd>
<img class="tex" alt="h_{\bar{a}}(\bar{x}) =  \left(\big( \sum_{i=0}^{k-1} x_i \cdot a_i \big) ~\bmod ~ 2^{2w} \right) \,\, \mathrm{div}\,\, 2^{2w-M}" src="Universal_hashing_files/52192aef6177015b793a1e97199280af.png">.</dd>
</dl>
<p>It is possible to halve the number of multiplications, which roughly translates to a two-fold speed-up in practice.<sup id="cite_ref-thorup09_7-1" class="reference"><a href="#cite_note-thorup09-7"><span>[</span>8<span>]</span></a></sup> Initialize the hash function with a vector <img class="tex" alt="\bar{a} = (a_0, \dots, a_{k-1})" src="Universal_hashing_files/ec4fa4a9f1aa7e71e6f6d470af855707.png"> of random <b>odd</b> integers on <img class="tex" alt="2w" src="Universal_hashing_files/ec9cbcbeaf6327c7d0b9f89df3df9423.png"> bits each. The following hash family is universal<sup id="cite_ref-black_9-0" class="reference"><a href="#cite_note-black-9"><span>[</span>10<span>]</span></a></sup>:</p>
<dl>
<dd>
<img class="tex" alt="h_{\bar{a}}(\bar{x}) = \left(\Big( \sum_{i=0}^{\lceil k/2 \rceil} (x_{2i} + a_{2i}) \cdot (x_{2i+1} + a_{2i+1}) \Big) \bmod ~ 2^{2w} \right) \,\, \mathrm{div}\,\, 2^{2w-M}" src="Universal_hashing_files/99834daf8ebe37e65f3f3712d0539f38.png">.</dd>
</dl>
<p>If double-precision operations are not available, one can interpret the input as a vector of half-words (<img class="tex" alt="w/2" src="Universal_hashing_files/79e9481e518f7e42b00028b00420161f.png">-bit integers). The algorithm will then use <img class="tex" alt="\lceil k/2 \rceil" src="Universal_hashing_files/2dd7a1212c3bc7ac9a64c123017e18f8.png"> multiplications, where <img class="tex" alt="k" src="Universal_hashing_files/8ce4b16b22b58894aa86c421e8759df3.png"> was the number of half-words in the vector. Thus, the algorithm runs at a "rate" of one multiplication per word of input.</p>
<p>The same scheme can also be used for hashing integers, by 
interpreting their bits as vectors of bytes. In this variant, the vector
 technique is known as <a href="http://en.m.wikipedia.org/wiki/Tabulation_hashing" title="Tabulation hashing">tabulation hashing</a> and it provides a practical alternative to multiplication-based universal hashing schemes.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>11<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Hashing_strings">Hashing strings</span>
</h3>
<p>This refers to hashing a <i>variable-sized</i> vector of machine 
words. If the length of the string can be bounded by a small number, it 
is best to use the vector solution from above (conceptually padding the 
vector with zeros up to the upper bound). The space required is the 
maximal length of the string, but the time to evaluate <img class="tex" alt="h(s)" src="Universal_hashing_files/990694bc2268b9bb3776144e770c25d9.png"> is just the length of <img class="tex" alt="s" src="Universal_hashing_files/03c7c0ace395d80182db07ae2c30f034.png"> (the zero-padding can be ignored when evaluating the hash function without affecting universality<sup id="cite_ref-thorup09_7-2" class="reference"><a href="#cite_note-thorup09-7"><span>[</span>8<span>]</span></a></sup>).</p>
<p>Now assume we want to hash <img class="tex" alt="\bar{x} = (x_0,\dots, x_\ell)" src="Universal_hashing_files/34f4e0ee49d2d71c630241e76f77f371.png">, where a good bound on <img class="tex" alt="\ell" src="Universal_hashing_files/334ce9eb79df1178b0380461c9eaa09e.png"> is not known a priori. A universal family proposed by.<sup id="cite_ref-DGMP_8-1" class="reference"><a href="#cite_note-DGMP-8"><span>[</span>9<span>]</span></a></sup> treats the string <img class="tex" alt="x" src="Universal_hashing_files/9dd4e461268c8034f5c8564e155c67a6.png"> as the coefficients of a polynomial modulo a large prime. If <img class="tex" alt="x_i \in [u]" src="Universal_hashing_files/172d10d5b2b0afb601ee9a6f2cacafcb.png">, let <img class="tex" alt="p \ge \max \{ u, m \}" src="Universal_hashing_files/ea1e1bad533cbdbefbb1c48f3f7f5338.png"> be a prime and define:</p>
<dl>
<dd>
<img class="tex" alt="h_a(\bar{x}) = h_\mathrm{int} \left( \big(\sum_{i=0}^\ell x_i\cdot  a^i \big) \bmod ~p \right)" src="Universal_hashing_files/f16b2dfdb22cde70095403f457fcc459.png">, where <img class="tex" alt="a \in [p]" src="Universal_hashing_files/cef7afeea1e6c15d42fae0eec49d4bd3.png"> is uniformly random and <img class="tex" alt="h_\mathrm{int}" src="Universal_hashing_files/b506f277ecbd85594f0facadf3064b83.png"> is chosen randomly from a universal family mapping integer domain <img class="tex" alt="[p] \mapsto [m]" src="Universal_hashing_files/dfb85a19f2be89413dd0ccab187872b5.png">.</dd>
</dl>
<p>Consider two strings <img class="tex" alt="\bar{x}, \bar{y}" src="Universal_hashing_files/e1d29c16fbcf8f93d938aa0b248b7caa.png"> and let <img class="tex" alt="\ell" src="Universal_hashing_files/334ce9eb79df1178b0380461c9eaa09e.png"> be length of the longer one; for the analysis, the shorter string is conceptually padded with zeros up to length <img class="tex" alt="\ell" src="Universal_hashing_files/334ce9eb79df1178b0380461c9eaa09e.png">. A collision before applying <img class="tex" alt="h_\mathrm{int}" src="Universal_hashing_files/b506f277ecbd85594f0facadf3064b83.png"> implies that <img class="tex" alt="a" src="Universal_hashing_files/0cc175b9c0f1b6a831c399e269772661.png"> is a root of the polynomial with coefficients <img class="tex" alt="\bar{x} - \bar{y}" src="Universal_hashing_files/c3b6c052bb7d558fc6dee69c69247475.png">. This polynomial has at most <img class="tex" alt="\ell" src="Universal_hashing_files/334ce9eb79df1178b0380461c9eaa09e.png"> roots modulo <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png">, so the collision probability is at most <img class="tex" alt="\ell/p" src="Universal_hashing_files/cd70b9c0e5bc405c41d702bc2e2a97fb.png">. The probability of collision through the random <img class="tex" alt="h_\mathrm{int}" src="Universal_hashing_files/b506f277ecbd85594f0facadf3064b83.png"> brings the total collision probability to <img class="tex" alt="\frac{1}{m} + \frac{\ell}{p}" src="Universal_hashing_files/d8b709fa2c68be1bcd8c140670649102.png">. Thus, if the prime <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png"> is sufficiently large compared to the length of strings hashed, the family is very close to universal (in <a href="http://en.m.wikipedia.org/wiki/Statistical_distance" title="Statistical distance">statistical distance</a>).</p>
<p>To mitigate the computational penalty of modular arithmetic, two tricks are used in practice <sup id="cite_ref-thorup09_7-3" class="reference"><a href="#cite_note-thorup09-7"><span>[</span>8<span>]</span></a></sup>:</p>
<ol>
<li>One chooses the prime <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png"> to be close to a power of two, such as a <a href="http://en.m.wikipedia.org/wiki/Mersenne_prime" title="Mersenne prime">Mersenne prime</a>. This allows arithmetic modulo <img class="tex" alt="p" src="Universal_hashing_files/83878c91171338902e0fe0fb97a8c47a.png">
 to be implemented without division (using faster operations like 
addition and shifts). For instance, on modern architectures one can work
 with <img class="tex" alt="p = 2^{61}-1" src="Universal_hashing_files/d230020e2f2c71bddbfac471959916cc.png">, while <img class="tex" alt="x_i" src="Universal_hashing_files/05e42209d67fe1eb15a055e9d3b3770e.png">'s are 32-bit values.</li>
<li>One can apply vector hashing to blocks. For instance, one applies 
vector hashing to each 16-word block of the string, and applies string 
hashing to the <img class="tex" alt="\lceil k/16 \rceil" src="Universal_hashing_files/a14a6cba08a0f416cd13b38068875bc0.png">
 results. Since the slower string hashing is applied on a substantially 
smaller vector, this will essentially be as fast as vector hashing.</li>
</ol>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><span id="See_also">See also</span></h2><div class="content_block" id="content_4">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/K-independent_hashing" title="K-independent hashing">K-independent hashing</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Rolling_hashing" title="Rolling hashing" class="mw-redirect">Rolling hashing</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Tabulation_hashing" title="Tabulation hashing">Tabulation hashing</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Min-wise_independence" title="Min-wise independence" class="mw-redirect">Min-wise independence</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Universal_one-way_hash_function" title="Universal one-way hash function">Universal one-way hash function</a></li>
</ul>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><span id="References">References</span></h2><div class="content_block" id="content_5">
<ol class="references">
<li id="cite_note-CW77-0">
<span class="mw-cite-backlink">^ <a href="#cite_ref-CW77_0-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CW77_0-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-CW77_0-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation Journal">Carter, Larry; <a href="http://en.m.wikipedia.org/wiki/Mark_N._Wegman" title="Mark N. Wegman">Wegman, Mark N.</a> (1979). "Universal Classes of Hash Functions". <i>Journal of Computer and System Sciences</i> <b>18</b> (2): 143–154. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0022-0000%2879%2990044-8">10.1016/0022-0000(79)90044-8</a>. Conference version in STOC'77.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Universal+Classes+of+Hash+Functions&amp;rft.jtitle=Journal+of+Computer+and+System+Sciences&amp;rft.aulast=Carter&amp;rft.aufirst=Larry&amp;rft.au=Carter%2C%26%2332%3BLarry&amp;rft.au=Wegman%2C%26%2332%3BMark+N.&amp;rft.date=1979&amp;rft.volume=18&amp;rft.issue=2&amp;rft.pages=143%E2%80%93154&amp;rft_id=info:doi/10.1016%2F0022-0000%2879%2990044-8&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-Miltersen-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-Miltersen_1-0">^</a></b></span> <span class="reference-text"><span class="citation web">Miltersen, Peter Bro. <a rel="nofollow" class="external text" href="http://www.webcitation.org/5hmOaVISI">"Universal Hashing"</a> (PDF). Archived from <a rel="nofollow" class="external text" href="http://www.daimi.au.dk/%7Ebromille/Notes/un.pdf">the original</a> on 24th June 2009<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.webcitation.org/5hmOaVISI">http://www.webcitation.org/5hmOaVISI</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Universal+Hashing&amp;rft.atitle=&amp;rft.aulast=Miltersen&amp;rft.aufirst=Peter+Bro&amp;rft.au=Miltersen%2C%26%2332%3BPeter+Bro&amp;rft_id=http%3A%2F%2Fwww.webcitation.org%2F5hmOaVISI&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Motwani, Rajeev; Raghavan, Prabhakar (1995). <i>Randomized Algorithms</i>. Cambridge University Press. p.&nbsp;221. <a href="http://en.m.wikipedia.org/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-521-47465-5" title="Special:BookSources/0-521-47465-5">0-521-47465-5</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Randomized+Algorithms&amp;rft.aulast=Motwani&amp;rft.aufirst=Rajeev&amp;rft.au=Motwani%2C%26%2332%3BRajeev&amp;rft.au=Raghavan%2C%26%2332%3BPrabhakar&amp;rft.date=1995&amp;rft.pages=p.%26nbsp%3B221&amp;rft.pub=Cambridge+University+Press&amp;rft.isbn=0-521-47465-5&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-BDP-3">
<span class="mw-cite-backlink">^ <a href="#cite_ref-BDP_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-BDP_3-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation Journal">Baran, Ilya; Demaine, Erik D.; <a href="http://en.m.wikipedia.org/wiki/Mihai_P%C4%83tra%C5%9Fcu" title="Mihai Pătraşcu">Pătraşcu, Mihai</a> (2008). <a rel="nofollow" class="external text" href="http://people.csail.mit.edu/mip/papers/3sum/3sum.pdf">"Subquadratic Algorithms for 3SUM"</a>. <i>Algorithmica</i> <b>50</b> (4): 584–596. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2Fs00453-007-9036-3">10.1007/s00453-007-9036-3</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://people.csail.mit.edu/mip/papers/3sum/3sum.pdf">http://people.csail.mit.edu/mip/papers/3sum/3sum.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Subquadratic+Algorithms+for+3SUM&amp;rft.jtitle=Algorithmica&amp;rft.aulast=Baran&amp;rft.aufirst=Ilya&amp;rft.au=Baran%2C%26%2332%3BIlya&amp;rft.au=Demaine%2C%26%2332%3BErik+D.&amp;rft.au=P%C4%83tra%C5%9Fcu%2C%26%2332%3BMihai&amp;rft.date=2008&amp;rft.volume=50&amp;rft.issue=4&amp;rft.pages=584%E2%80%93596&amp;rft_id=info:doi/10.1007%2Fs00453-007-9036-3&amp;rft_id=http%3A%2F%2Fpeople.csail.mit.edu%2Fmip%2Fpapers%2F3sum%2F3sum.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-DHKP97-4">
<span class="mw-cite-backlink"><b><a href="#cite_ref-DHKP97_4-0">^</a></b></span> <span class="reference-text"><span class="citation Journal">Dietzfelbinger, Martin; Hagerup, Torben; Katajainen, Jyrki; Penttonen, Martti (1997). <a rel="nofollow" class="external text" href="http://www.diku.dk/%7Ejyrki/Paper/CP-11.4.1997.ps">"A Reliable Randomized Algorithm for the Closest-Pair Problem"</a> (Postscript). <i>Journal of Algorithms</i> <b>25</b> (1): 19–51. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1006%2Fjagm.1997.0873">10.1006/jagm.1997.0873</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.diku.dk/%7Ejyrki/Paper/CP-11.4.1997.ps">http://www.diku.dk/~jyrki/Paper/CP-11.4.1997.ps</a></span><span class="reference-accessdate">. Retrieved 10 February 2011</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+Reliable+Randomized+Algorithm+for+the+Closest-Pair+Problem&amp;rft.jtitle=Journal+of+Algorithms&amp;rft.aulast=Dietzfelbinger&amp;rft.aufirst=Martin&amp;rft.au=Dietzfelbinger%2C%26%2332%3BMartin&amp;rft.au=Hagerup%2C%26%2332%3BTorben&amp;rft.au=Katajainen%2C%26%2332%3BJyrki&amp;rft.au=Penttonen%2C%26%2332%3BMartti&amp;rft.date=1997&amp;rft.volume=25&amp;rft.issue=1&amp;rft.pages=19%E2%80%9351&amp;rft_id=info:doi/10.1006%2Fjagm.1997.0873&amp;rft_id=http%3A%2F%2Fwww.diku.dk%2F%7Ejyrki%2FPaper%2FCP-11.4.1997.ps&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web"><a href="http://en.m.wikipedia.org/wiki/Mikkel_Thorup" title="Mikkel Thorup">Thorup, Mikkel</a>. <a rel="nofollow" class="external text" href="http://mybiasedcoin.blogspot.com/2009/12/text-book-algorithms-at-soda-guest-post.html">"Text-book algorithms at SODA"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://mybiasedcoin.blogspot.com/2009/12/text-book-algorithms-at-soda-guest-post.html">http://mybiasedcoin.blogspot.com/2009/12/text-book-algorithms-at-soda-guest-post.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Text-book+algorithms+at+SODA&amp;rft.atitle=&amp;rft.aulast=Thorup&amp;rft.aufirst=Mikkel&amp;rft.au=Thorup%2C%26%2332%3BMikkel&amp;rft_id=http%3A%2F%2Fmybiasedcoin.blogspot.com%2F2009%2F12%2Ftext-book-algorithms-at-soda-guest-post.html&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-w99-6">
<span class="mw-cite-backlink"><b><a href="#cite_ref-w99_6-0">^</a></b></span> <span class="reference-text"><span class="citation book">Woelfel, Philipp (1999). <a rel="nofollow" class="external text" href="http://www.springerlink.com/content/a10p748w7pr48682/">"Efficient Strongly Universal and Optimally Universal Hashing"</a> (PDF). LNCS. <b>1672</b>. Mathematical Foundations of Computer Science 1999. pp.&nbsp;262-272. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-48340-3_24">10.1007/3-540-48340-3_24</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.springerlink.com/content/a10p748w7pr48682/">http://www.springerlink.com/content/a10p748w7pr48682/</a></span><span class="reference-accessdate">. Retrieved 17 May 2011</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Efficient+Strongly+Universal+and+Optimally+Universal+Hashing&amp;rft.atitle=&amp;rft.aulast=Woelfel&amp;rft.aufirst=Philipp&amp;rft.au=Woelfel%2C%26%2332%3BPhilipp&amp;rft.date=1999&amp;rft.series=LNCS&amp;rft.volume=1672&amp;rft.pages=pp.%26nbsp%3B262-272&amp;rft_id=info:doi/10.1007%2F3-540-48340-3_24&amp;rft_id=http%3A%2F%2Fwww.springerlink.com%2Fcontent%2Fa10p748w7pr48682%2F&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-thorup09-7">
<span class="mw-cite-backlink">^ <a href="#cite_ref-thorup09_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-thorup09_7-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-thorup09_7-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-thorup09_7-3"><sup><i><b>d</b></i></sup></a></span> <span class="reference-text"><span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Mikkel_Thorup" title="Mikkel Thorup">Thorup, Mikkel</a> (2009). <a rel="nofollow" class="external text" href="http://www.siam.org/proceedings/soda/2009/SODA09_072_thorupm.pdf">"String hashing for linear probing"</a>. <i>Proc. 20th ACM-SIAM Symposium on Discrete Algorithms (SODA)</i>. pp.&nbsp;655–664<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.siam.org/proceedings/soda/2009/SODA09_072_thorupm.pdf">http://www.siam.org/proceedings/soda/2009/SODA09_072_thorupm.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=String+hashing+for+linear+probing&amp;rft.atitle=Proc.+20th+ACM-SIAM+Symposium+on+Discrete+Algorithms+%28SODA%29&amp;rft.aulast=Thorup&amp;rft.aufirst=Mikkel&amp;rft.au=Thorup%2C%26%2332%3BMikkel&amp;rft.date=2009&amp;rft.pages=pp.%26nbsp%3B655%E2%80%93664&amp;rft_id=http%3A%2F%2Fwww.siam.org%2Fproceedings%2Fsoda%2F2009%2FSODA09_072_thorupm.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span>, section 5.3</span>
</li>
<li id="cite_note-DGMP-8">
<span class="mw-cite-backlink">^ <a href="#cite_ref-DGMP_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-DGMP_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation book">Dietzfelbinger,
 Martin; Gil, Joseph; Matias, Yossi; Pippenger, Nicholas (1992). 
"Polynomial Hash Functions Are Reliable (Extended Abstract)". <i>Proc. 19th International Colloquium on Automata, Languages and Programming (ICALP)</i>. pp.&nbsp;235–246.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Polynomial+Hash+Functions+Are+Reliable+%28Extended+Abstract%29&amp;rft.atitle=Proc.+19th+International+Colloquium+on+Automata%2C+Languages+and+Programming+%28ICALP%29&amp;rft.aulast=Dietzfelbinger&amp;rft.aufirst=Martin&amp;rft.au=Dietzfelbinger%2C%26%2332%3BMartin&amp;rft.au=Gil%2C%26%2332%3BJoseph&amp;rft.au=Matias%2C%26%2332%3BYossi&amp;rft.au=Pippenger%2C%26%2332%3BNicholas&amp;rft.date=1992&amp;rft.pages=pp.%26nbsp%3B235%E2%80%93246&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-black-9">
<span class="mw-cite-backlink"><b><a href="#cite_ref-black_9-0">^</a></b></span> <span class="reference-text"><span class="citation book">Black, J.; Halevi, S.; Krawczyk, H.; Krovetz, T. (1999). <a rel="nofollow" class="external text" href="http://www.cs.ucdavis.edu/%7Erogaway/papers/umac-full.pdf">"UMAC: Fast and Secure Message Authentication"</a>. <i>Advances in Cryptology (CRYPTO '99)</i><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.ucdavis.edu/%7Erogaway/papers/umac-full.pdf">http://www.cs.ucdavis.edu/~rogaway/papers/umac-full.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=UMAC%3A+Fast+and+Secure+Message+Authentication&amp;rft.atitle=Advances+in+Cryptology+%28CRYPTO+%2799%29&amp;rft.aulast=Black&amp;rft.aufirst=J.&amp;rft.au=Black%2C%26%2332%3BJ.&amp;rft.au=Halevi%2C%26%2332%3BS.&amp;rft.au=Krawczyk%2C%26%2332%3BH.&amp;rft.au=Krovetz%2C%26%2332%3BT.&amp;rft.date=1999&amp;rft_id=http%3A%2F%2Fwww.cs.ucdavis.edu%2F%7Erogaway%2Fpapers%2Fumac-full.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span>, Equation 1</span>
</li>
<li id="cite_note-10">
<span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Mihai_P%C4%83tra%C5%9Fcu" title="Mihai Pătraşcu">Pătraşcu, Mihai</a>; <a href="http://en.m.wikipedia.org/wiki/Mikkel_Thorup" title="Mikkel Thorup">Thorup, Mikkel</a> (2011). "The power of simple tabulation hashing". <i>Proceedings of the 43rd annual ACM Symposium on Theory of Computing (STOC '11)</i>. pp.&nbsp;1–10. <a href="http://en.m.wikipedia.org/wiki/ArXiv" title="ArXiv">arXiv</a>:<a rel="nofollow" class="external text" href="http://arxiv.org/abs/1011.5200">1011.5200</a>. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F1993636.1993638">10.1145/1993636.1993638</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=The+power+of+simple+tabulation+hashing&amp;rft.atitle=Proceedings+of+the+43rd+annual+ACM+Symposium+on+Theory+of+Computing+%28STOC+%2711%29&amp;rft.aulast=P%C4%83tra%C5%9Fcu&amp;rft.aufirst=Mihai&amp;rft.au=P%C4%83tra%C5%9Fcu%2C%26%2332%3BMihai&amp;rft.au=Thorup%2C%26%2332%3BMikkel&amp;rft.date=2011&amp;rft.pages=pp.%26nbsp%3B1%E2%80%9310&amp;rft_id=info:arxiv/1011.5200&amp;rft_id=info:doi/10.1145%2F1993636.1993638&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span></span>
</li>
</ol>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><span id="Further_reading">Further reading</span></h2><div class="content_block" id="content_6">
<ul>
<li>
<span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Donald_Ervin_Knuth" title="Donald Ervin Knuth" class="mw-redirect">Knuth, Donald Ervin</a> (1998). <i>[The Art of Computer Programming], Vol. III: Sorting and Searching</i> (2e ed.). Reading, Mass&nbsp;; London: Addison-Wesley. <a href="http://en.m.wikipedia.org/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-201-89685-0" title="Special:BookSources/0-201-89685-0">0-201-89685-0</a>. knuth.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=%5BThe+Art+of+Computer+Programming%5D%2C+Vol.+III%3A+Sorting+and+Searching&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald+Ervin&amp;rft.au=Knuth%2C%26%2332%3BDonald+Ervin&amp;rft.date=1998&amp;rft.edition=2e&amp;rft.place=Reading%2C+Mass+%3B+London&amp;rft.pub=Addison-Wesley&amp;rft.isbn=0-201-89685-0&amp;rfr_id=info:sid/en.wikipedia.org:Universal_hashing"><span style="display: none;">&nbsp;</span></span>
</li>
</ul>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li><a rel="nofollow" class="external text" href="http://opendatastructures.org/versions/edition-0.1d/ods-java/node31.html#SECTION00811000000000000000">Open Data Structures - Section 5.1.1 - Multiplicative Hashing</a></li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer">
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Universal_hashing&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Universal+hashing" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Universal_hashing&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Universal+hashing&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Universal_hashing_files/load_002.php" type="text/javascript"></script>
<script src="Universal_hashing_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	</body></html>