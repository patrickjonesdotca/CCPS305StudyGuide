<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Binary heap - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Binary_heap_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 13 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Binary_heap">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Binary_heap_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Binary_heap_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Binary_heap_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Binary_heap" selected="selected">English</option><option value="//cs.m.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">česky</option><option value="//de.m.wikipedia.org/wiki/Bin%C3%A4rer_Heap">Deutsch</option><option value="//es.m.wikipedia.org/wiki/Mont%C3%ADculo_binario">español</option><option value="//fa.m.wikipedia.org/wiki/%D9%85%DA%A9%D8%B3-%D9%87%DB%8C%D9%BE">فارسی</option><option value="//hu.m.wikipedia.org/wiki/Bin%C3%A1ris_kupac">magyar</option><option value="//ja.m.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E3%83%92%E3%83%BC%E3%83%97">日本語</option><option value="//pl.m.wikipedia.org/wiki/Kopiec_binarny">polski</option><option value="//ru.m.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0">русский</option><option value="//sk.m.wikipedia.org/wiki/Bin%C3%A1rna_halda">slovenčina</option><option value="//uk.m.wikipedia.org/wiki/%D0%91%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D0%B0_%D0%BA%D1%83%D0%BF%D0%B0">українська</option><option value="//vi.m.wikipedia.org/wiki/%C4%90%E1%BB%91ng_nh%E1%BB%8B_ph%C3%A2n">Tiếng Việt</option><option value="//zh.m.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86">中文</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Binary heap</h1>			
<table class="infobox" style="width: 22em;">
<tbody><tr>
<th colspan="3" style="font-size: 125%; text-align: center;">Binary Heap</th>
</tr>
<tr>
<th><a href="http://en.m.wikipedia.org/wiki/List_of_data_structures" title="List of data structures">Type</a></th>
<td colspan="2"><a href="http://en.m.wikipedia.org/wiki/Tree_%28data_structure%29" title="Tree (data structure)">Tree</a></td>
</tr>
<tr>
<th colspan="3" class="navbox-abovebelow">
<a href="http://en.m.wikipedia.org/wiki/Time_complexity" title="Time complexity">Time complexity</a><br>
in <a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation">big O notation</a>
</th>
</tr>
<tr>
<td></td>
<td>Average</td>
<td>Worst case</td>
</tr>
<tr>
<th>Space</th>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<th>Search</th>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<th>Insert</th>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<th>Delete</th>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
</tbody></table>
<div class="thumb tright">
<div class="thumbinner" style="width:242px;">
<a href="http://en.m.wikipedia.org/wiki/File:Max-heap.png" class="image"><img alt="" src="Binary_heap_files/240px-Max-heap.png" class="thumbimage" width="240" height="161"></a>
<div class="thumbcaption">

Example of a complete binary max heap</div>
</div>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:242px;">
<a href="http://en.m.wikipedia.org/wiki/File:Min-heap.png" class="image"><img alt="" src="Binary_heap_files/240px-Min-heap.png" class="thumbimage" width="240" height="155"></a>
<div class="thumbcaption">

Example of a complete binary min heap</div>
</div>
</div>
<p>A <b>binary heap</b> is a <a href="http://en.m.wikipedia.org/wiki/Heap_%28data_structure%29" title="Heap (data structure)">heap</a> <a href="http://en.m.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> created using a <a href="http://en.m.wikipedia.org/wiki/Binary_tree" title="Binary tree">binary tree</a>. It can be seen as a binary tree with two additional constraints:</p>
<ul>
<li>The <i>shape property</i>: the tree is a <i><a href="http://en.m.wikipedia.org/wiki/Complete_Binary_Tree" title="Complete Binary Tree" class="mw-redirect">complete binary tree</a></i>;
 that is, all levels of the tree, except possibly the last one (deepest)
 are fully filled, and, if the last level of the tree is not complete, 
the nodes of that level are filled from left to right.</li>
<li>The <i>heap property</i>: each node is greater than or equal to each of its children according to a comparison <a href="http://en.m.wikipedia.org/wiki/Predicate_%28mathematical_logic%29" title="Predicate (mathematical logic)">predicate</a> defined for the data structure.</li>
</ul>
<p>Heaps with a mathematical "greater than or equal to" comparison function are called <i>max-heaps</i>; those with a mathematical "less than or equal to" comparison function are called <i>min-heaps</i>. Min-heaps are often used to implement <a href="http://en.m.wikipedia.org/wiki/Priority_queue" title="Priority queue">priority queues</a>.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>2<span>]</span></a></sup></p>
<p>Since the ordering of siblings in a heap is not specified by the heap
 property, a single node's two children can be freely interchanged 
unless doing so violates the shape property (compare with <a href="http://en.m.wikipedia.org/wiki/Treap" title="Treap">treap</a>).</p>
<p>The binary heap is a special case of the <a href="http://en.m.wikipedia.org/wiki/D-ary_heap" title="D-ary heap">d-ary heap</a> in which d = 2.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Heap_operations">Heap operations</span></h2><div class="content_block" id="content_1">
<p>Both the insert and remove operations modify the heap to conform to 
the shape property first, by adding or removing from the end of the 
heap. Then the heap property is restored by traversing up or down the 
heap. Both operations take O(log <i>n</i>) time.</p>
<h3> <span class="mw-headline" id="Insert">Insert</span>
</h3>
<p>To add an element to a heap we must perform an <i>up-heap</i> operation (also known as <i>bubble-up</i>, <i>percolate-up</i>, <i>sift-up</i>, <i>trickle up</i>, <i>heapify-up</i>, or <i>cascade-up</i>), by following this algorithm:</p>
<ol>
<li>Add the element to the bottom level of the heap.</li>
<li>Compare the added element with its parent; if they are in the correct order, stop.</li>
<li>If not, swap the element with its parent and return to the previous step.</li>
</ol>
<p>The number of operations required is dependent on the amount of 
levels the new element must rise to satisfy the heap property, thus the 
insertion operation has a time complexity of O(log <i>n</i>).</p>
<p>As an example, say we have a max-heap</p>
<dl>
<dd>
<dl>
<dd><a href="http://en.m.wikipedia.org/wiki/File:Heap_add_step1.svg" class="image"><img alt="Heap add step1.svg" src="Binary_heap_files/150px-Heap_add_step1.png" width="150" height="90"></a></dd>
</dl>
</dd>
</dl>
<p>and we want to add the number 15 to the heap. We first place the 15 
in the position marked by the X. However, the heap property is violated 
since 15 is greater than 8, so we need to swap the 15 and the 8. So, we 
have the heap looking as follows after the first swap:</p>
<dl>
<dd>
<dl>
<dd><a href="http://en.m.wikipedia.org/wiki/File:Heap_add_step2.svg" class="image"><img alt="Heap add step2.svg" src="Binary_heap_files/150px-Heap_add_step2.png" width="150" height="90"></a></dd>
</dl>
</dd>
</dl>
<p>However the heap property is still violated since 15 is greater than 11, so we need to swap again:</p>
<dl>
<dd>
<dl>
<dd><a href="http://en.m.wikipedia.org/wiki/File:Heap_add_step3.svg" class="image"><img alt="Heap add step3.svg" src="Binary_heap_files/150px-Heap_add_step3.png" width="150" height="90"></a></dd>
</dl>
</dd>
</dl>
<p>which is a valid max-heap. There is no need to check the children 
after this. Before we placed 15 on X, the heap was valid, meaning 11 is 
greater than 5. If 15 is greater than 11, and 11 is greater than 5, then
 15 must be greater than 5, because of the <a href="http://en.m.wikipedia.org/wiki/Transitive_relation" title="Transitive relation">transitive relation</a>.</p>
<h3> <span class="mw-headline" id="Delete">Delete</span>
</h3>
<p>The procedure for deleting the root from the heap (effectively 
extracting the maximum element in a max-heap or the minimum element in a
 min-heap) and restoring the properties is called <i>down-heap</i> (also known as <i>bubble-down</i>, <i>percolate-down</i>, <i>sift-down</i>, <i>trickle down</i>, <i>heapify-down</i>, <i>cascade-down</i> and <i>extract-min/max</i>).</p>
<ol>
<li>Replace the root of the heap with the last element on the last level.</li>
<li>Compare the new root with its children; if they are in the correct order, stop.</li>
<li>If not, swap the element with one of its children and return to the 
previous step. (Swap with its smaller child in a min-heap and its larger
 child in a max-heap.)</li>
</ol>
<p>So, if we have the same max-heap as before, we remove the 11 and replace it with the 4.</p>
<dl>
<dd>
<dl>
<dd><a href="http://en.m.wikipedia.org/wiki/File:Heap_remove_step1.svg" class="image"><img alt="Heap remove step1.svg" src="Binary_heap_files/150px-Heap_remove_step1.png" width="150" height="90"></a></dd>
</dl>
</dd>
</dl>
<p>Now the heap property is violated since 8 is greater than 4. In this 
case, swapping the two elements, 4 and 8, is enough to restore the heap 
property and we need not swap elements further:</p>
<dl>
<dd>
<dl>
<dd><a href="http://en.m.wikipedia.org/wiki/File:Heap_remove_step2.svg" class="image"><img alt="Heap remove step2.svg" src="Binary_heap_files/150px-Heap_remove_step2.png" width="150" height="90"></a></dd>
</dl>
</dd>
</dl>
<p>The downward-moving node is swapped with the <i>larger</i> of its 
children in a max-heap (in a min-heap it would be swapped with its 
smaller child), until it satisfies the heap property in its new 
position. This functionality is achieved by the <b>Max-Heapify</b> function as defined below in <a href="http://en.m.wikipedia.org/wiki/Pseudocode" title="Pseudocode">pseudocode</a> for an <a href="http://en.m.wikipedia.org/wiki/Array_data_structure" title="Array data structure">array</a>-backed heap <i>A</i>. Note that "A" is indexed starting at 1, not 0 as is common in many programming languages.</p>
<p>For the following algorithm to correctly re-heapify the array, the 
node at index i and its two direct children must violate the heap 
property. If they do not, the algorithm will fall through with no change
 to the array.</p>
<p><b>Max-Heapify</b><sup id="cite_ref-CLRS_2-0" class="reference"><a href="#cite_note-CLRS-2"><span>[</span>3<span>]</span></a></sup> (<i>A</i>, <i>i</i>):<br><span style="padding-left: 2em;">&nbsp;</span><i>left</i> ← 2<i>i</i><br><span style="padding-left: 2em;">&nbsp;</span><i>right</i> ← 2<i>i</i> + 1<br><span style="padding-left: 2em;">&nbsp;</span><i>largest</i> ← <i>i</i><br><span style="padding-left: 2em;">&nbsp;</span><b>if</b> <i>left</i> ≤ <i>heap_length</i>[<i>A</i>] <b>and</b> <i>A</i>[<i>left</i>] &gt; A[<i>largest</i>] <b>then</b>:<br><span style="padding-left: 4em;">&nbsp;</span><i>largest</i> ← <i>left</i><br><span style="padding-left: 2em;">&nbsp;</span><b>if</b> <i>right</i> ≤ <i>heap_length</i>[<i>A</i>] <b>and</b> <i>A</i>[<i>right</i>] &gt; <i>A</i>[<i>largest</i>] <b>then</b>:<br><span style="padding-left: 4em;">&nbsp;</span><i>largest</i> ← <i>right</i><br><span style="padding-left: 2em;">&nbsp;</span><b>if</b> <i>largest</i> ≠ <i>i</i> <b>then</b>:<br><span style="padding-left: 4em;">&nbsp;</span><b>swap</b> <i>A[</i>i<i>] ↔</i> A<i>[</i>largest<i>]<br></i> <span style="padding-left: 4em;">&nbsp;</span>Max-Heapify(<i>A</i>, <i>largest</i>)</p>
<p>The down-heap operation (without the preceding swap) can also be used
 to modify the value of the root, even when an element is not being 
deleted.</p>
<p>In the worst case, the new root has to be swapped with its child on 
each level until it reaches the bottom level of the heap, meaning that 
the delete operation has a time complexity relative to the height of the
 tree, or O(log <i>n</i>).</p>
<p>An <a href="http://en.m.wikipedia.org/wiki/Amortized_analysis" title="Amortized analysis">amortized analysis</a> of a sequence of heap insertions and deletions can associate the insert operation with O(log <i>n</i>)
 complexity, while the delete operation can be satisfied by O(1) 
complexity as long as deleting from an empty heap is forbidden. This is 
possible because any element's insert operation can be thought as 
"paying off in advance" the eventual complexity of its deletion from the
 tree for overall O(log <i>n</i>) complexity. However, it's not possible
 to associate O(1) with the insert operation in such analysis. Amortized
 analysis by its very nature does not affect the actual complexity of 
individual operations.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Building_a_heap">Building a heap</span></h2><div class="content_block" id="content_2">
<p>A heap could be built by successive insertions. This approach requires <img class="tex" alt="O(n \log n)" src="Binary_heap_files/f49341ab621f12e8cb93d0146ea51d34.png"> time because each insertion takes <img class="tex" alt="O(\log n)" src="Binary_heap_files/0ca47d9a481af371d1210a620c1945db.png"> time and there are <img class="tex" alt="n" src="Binary_heap_files/7b8b965ad4bca0e41ab51de7b31363a1.png">
 elements. However this is not the optimal method. The optimal method 
starts by arbitrarily putting the elements on a binary tree, respecting 
the shape property (the tree could be represented by an array, see 
below). Then starting from the lowest level and moving upwards, shift 
the root of each subtree downward as in the deletion algorithm until the
 heap property is restored. More specifically if all the subtrees 
starting at some height <img class="tex" alt="h" src="Binary_heap_files/2510c39011c5be704182423e3a695e91.png"> (measured from the bottom) have already been "heapified", the trees at height <img class="tex" alt="h+1" src="Binary_heap_files/f903d33b9ff801b886bf719b3c694d4d.png">
 can be heapified by sending their root down along the path of maximum 
valued children when building a max-heap, or minimum valued children 
when building a min-heap. This process takes <img class="tex" alt="O(h)" src="Binary_heap_files/0ba11ebdc4068356183c1d861d1c0bd8.png">
 operations (swaps) per node. In this method most of the heapification 
takes place in the lower levels. Since the height of the heap is <img class="tex" alt=" \left\lfloor \lg (n) \right\rfloor" src="Binary_heap_files/28e8a4ae0af159d2b6df31b28d8c727e.png">, the number of nodes at height <img class="tex" alt="h" src="Binary_heap_files/2510c39011c5be704182423e3a695e91.png"> is <img class="tex" alt="\le \left\lceil 2^{\left(\lg n - h\right) - 1} \right\rceil = \left\lceil \frac{2^{\lg n}}{2^{h+1}}\right\rceil = \left\lceil\frac{n}{2^{h+1}}\right\rceil" src="Binary_heap_files/9e0b35471a7c35952352abe0977062ec.png">. Therefore, the cost of heapifying all subtrees is:</p>
<dl>
<dd><img class="tex" alt="
\begin{align}
\sum_{h=0}^{\lceil \lg n \rceil} \frac{n}{2^{h+1}}O(h) &amp; =
O\left(n\sum_{h=0}^{\lceil \lg n \rceil} \frac{h}{2^{h + 1}}\right) \\
&amp; \le O\left(n\sum_{h=0}^{\infty} \frac{h}{2^h}\right) \\
&amp; = O(n)

\end{align}
" src="Binary_heap_files/7f31d56bc5a782424d75f1ec2c4e6c17.png"></dd>
</dl>
<p>This uses the fact that the given infinite <a href="http://en.m.wikipedia.org/wiki/Series_%28mathematics%29" title="Series (mathematics)">series</a> <i>h</i> / 2<sup><i>h</i></sup><a href="http://en.m.wikipedia.org/wiki/Convergent_series" title="Convergent series">converges</a> to 2.</p>
<p>The <b>Build-Max-Heap</b> function that follows, converts an array <i>A</i> which stores a complete binary tree with n nodes to a max-heap by repeatedly using <b>Max-Heapify</b> in a bottom up manner. It is based on the observation that the array elements indexed by <i><a href="http://en.m.wikipedia.org/wiki/Floor_function" title="Floor function" class="mw-redirect">floor</a></i>(n/2) + 1, <i>floor</i>(n/2) + 2, ..., n are all leaves for the tree, thus each is a one-element heap. <b>Build-Max-Heap</b> runs <b>Max-Heapify</b> on each of the remaining tree nodes.</p>
<p><b>Build-Max-Heap</b><sup id="cite_ref-CLRS_2-1" class="reference"><a href="#cite_note-CLRS-2"><span>[</span>3<span>]</span></a></sup> (<i>A</i>):<br><span style="padding-left: 2em;">&nbsp;</span><i>heap_length</i>[<i>A</i>] ← <i>length</i>[<i>A</i>]<br><span style="padding-left: 2em;">&nbsp;</span><b>for</b> <i>i</i> ← <i>floor</i>(<i>length</i>[<i>A</i>]/2) <b>downto</b> 1 <b>do</b><br><span style="padding-left: 4em;">&nbsp;</span><b>Max-Heapify</b>(<i>A</i>, <i>i</i>)</p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Heap_implementation">Heap implementation</span></h2><div class="content_block" id="content_3">
<div class="thumb tright">
<div class="thumbinner" style="width:372px;">
<a href="http://en.m.wikipedia.org/wiki/File:Binary_tree_in_array.svg" class="image"><img alt="" src="Binary_heap_files/370px-Binary_tree_in_array.png" class="thumbimage" width="370" height="93"></a>
<div class="thumbcaption">A small complete binary tree stored in an array</div>
</div>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:402px;">
<a href="http://en.m.wikipedia.org/wiki/File:Binary_Heap_with_Array_Implementation.JPG" class="image"><img alt="" src="Binary_heap_files/400px-Binary_Heap_with_Array_Implementation.JPG" class="thumbimage" width="400" height="103"></a>
<div class="thumbcaption">

Comparison between a binary heap and an array implementation.</div>
</div>
</div>
<p>Heaps are commonly implemented with an <a href="http://en.m.wikipedia.org/wiki/Array_data_structure" title="Array data structure">array</a>.
 Any binary tree can be stored in an array, but because a heap is always
 an almost complete binary tree, it can be stored compactly. No space is
 required for <a href="http://en.m.wikipedia.org/wiki/Pointer_%28computer_programming%29" title="Pointer (computer programming)">pointers</a>;
 instead, the parent and children of each node can be found by 
arithmetic on array indices. These properties make this heap 
implementation a simple example of an <a href="http://en.m.wikipedia.org/wiki/Implicit_data_structure" title="Implicit data structure">implicit data structure</a> or <a href="http://en.m.wikipedia.org/wiki/Binary_tree#Ahnentafel_list" title="Binary tree">Ahnentafel list</a>. Details depend on the root position, which in turn may depend on constraints of a <a href="http://en.m.wikipedia.org/wiki/Programming_language" title="Programming language">programming language</a>
 used for implementation, or programmer preference. Specifically, 
sometimes the root is placed at index 1, wasting space in order to 
simplify arithmetic.</p>
<p>Let <i>n</i> be the number of elements in the heap and <i>i</i> be an arbitrary valid index of the array storing the heap. If the tree root is at index 0, with valid indices 0 through <i>n</i>-1, then each element <i>a</i>[<i>i</i>] has</p>
<ul>
<li>children <i>a</i>[2<i>i</i>+1] and <i>a</i>[2<i>i</i>+2]</li>
<li>parent <i>a</i>[<a href="http://en.m.wikipedia.org/wiki/Floor_function" title="Floor function" class="mw-redirect">floor</a>((<i>i</i>−1)/2)]</li>
</ul>
<p>Alternatively, if the tree root is at index 1, with valid indices 1 through <i>n</i>, then each element <i>a</i>[<i>i</i>] has</p>
<ul>
<li>children <i>a</i>[2<i>i</i>] and <i>a</i>[2<i>i</i>+1]</li>
<li>parent <i>a</i>[floor(<i>i</i>/2)].</li>
</ul>
<p>This implementation is used in the <a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">heapsort</a> algorithm, where it allows the space in the input array to be reused to store the heap (i.e. the algorithm is done <a href="http://en.m.wikipedia.org/wiki/In-place_algorithm" title="In-place algorithm">in-place</a>). The implementation is also useful for use as a <a href="http://en.m.wikipedia.org/wiki/Priority_queue" title="Priority queue">Priority queue</a> where use of a <a href="http://en.m.wikipedia.org/wiki/Dynamic_array" title="Dynamic array">dynamic array</a> allows insertion of an unbounded number of items.</p>
<p>The upheap/downheap operations can then be stated in terms of an 
array as follows: suppose that the heap property holds for the indices <i>b</i>, <i>b</i>+1, ..., <i>e</i>. The sift-down function extends the heap property to <i>b</i>−1, <i>b</i>, <i>b</i>+1, ..., <i>e</i>. Only index <i>i</i> = <i>b</i>−1 can violate the heap property. Let <i>j</i> be the index of the largest child of <i>a</i>[<i>i</i>] (for a max-heap, or the smallest child for a min-heap) within the range <i>b</i>, ..., <i>e</i>. (If no such index exists because 2<i>i</i> &gt; <i>e</i> then the heap property holds for the newly extended range and nothing needs to be done.) By swapping the values <i>a</i>[<i>i</i>] and <i>a</i>[<i>j</i>] the heap property for position <i>i</i> is established. At this point, the only problem is that the heap property might not hold for index <i>j</i>. The sift-down function is applied <a href="http://en.m.wikipedia.org/wiki/Tail_recursion" title="Tail recursion" class="mw-redirect">tail-recursively</a> to index <i>j</i> until the heap property is established for all elements.</p>
<p>The sift-down function is fast. In each step it only needs two 
comparisons and one swap. The index value where it is working doubles in
 each iteration, so that at most log<sub>2</sub><i>e</i> steps are required.</p>
<p>For big heaps and using <a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">virtual memory</a>, storing elements in an array according to the above scheme is inefficient: (almost) every level is in a different <a href="http://en.m.wikipedia.org/wiki/Page_%28computer_memory%29" title="Page (computer memory)">page</a>. <a href="http://en.m.wikipedia.org/wiki/B-heap" title="B-heap">B-heaps</a> are binary heaps that keep subtrees in a single page, reducing the number of pages accessed by up to a factor of ten.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>4<span>]</span></a></sup></p>
<p>The operation of merging two binary heaps takes Θ(<i>n</i>) for 
equal-sized heaps. The best you can do is (in case of array 
implementation) simply concatenating the two heap arrays and build a 
heap of the result.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>5<span>]</span></a></sup> When merging is a common task, a different heap implementation is recommended, such as <a href="http://en.m.wikipedia.org/wiki/Binomial_heap" title="Binomial heap">binomial heaps</a>, which can be merged in O(log <i>n</i>).</p>
<p>Additionally, a binary heap can be implemented with a traditional 
binary tree data structure, but there is an issue with finding the 
adjacent element on the last level on the binary heap when adding an 
element. This element can be determined algorithmically or by adding 
extra data to the nodes, called "threading" the tree—instead of merely 
storing references to the children, we store the <a href="http://en.m.wikipedia.org/wiki/Inorder" title="Inorder" class="mw-redirect">inorder</a> successor of the node as well.</p>
<p>It is possible to modify the heap structure to allow extraction of both the smallest and largest element in <a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation"><img class="tex" alt="O" src="Binary_heap_files/f186217753c37b9b9f958d906208506e.png"></a><img class="tex" alt="(\log n)" src="Binary_heap_files/d358618227e99a5720f7d5d6c13e4792.png"> time.<sup id="cite_ref-sym_5-0" class="reference"><a href="#cite_note-sym-5"><span>[</span>6<span>]</span></a></sup>
 To do this, the rows alternate between min heap and max heap. The 
algorithms are roughly the same, but, in each step, one must consider 
the alternating rows with alternating comparisons. The performance is 
roughly the same as a normal single direction heap. This idea can be 
generalised to a min-max-median heap.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Derivation_of_children.27s_index_in_an_array_implementation">Derivation of children's index in an array implementation</span></h2><div class="content_block" id="content_4">
<p>This derivation will show how for any given node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> (starts from zero), its children would be found at <img class="tex" alt="2i+1" src="Binary_heap_files/a17022c3643548e48f666c66236fad49.png"> and <img class="tex" alt="2i+2" src="Binary_heap_files/2bc7151a37d6d8d996d810fb3d1fedd8.png">.</p>
<h3> <span class="mw-headline" id="Mathematical_proof">Mathematical proof</span>
</h3>
<p>From the figure in "Heap Implementation" section, it can be seen that
 any node can store its children only after its right siblings and its 
left siblings' children have been stored. This fact will be used for 
derivation.</p>
<p>Total number of elements from root to any given level <img class="tex" alt="l" src="Binary_heap_files/2db95e8e1a9267b7a1188556b2013b33.png"> = <img class="tex" alt="2^{l+1}-1" src="Binary_heap_files/0b766121dd3bb954ccbccea8f1984f3c.png">, where <img class="tex" alt="l" src="Binary_heap_files/2db95e8e1a9267b7a1188556b2013b33.png"> starts at zero.</p>
<p>Suppose the node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> is at level <img class="tex" alt="l" src="Binary_heap_files/2db95e8e1a9267b7a1188556b2013b33.png">.</p>
<p>So, the total number of nodes from root to previous level would be = <img class="tex" alt="2^{(l-1) + 1}-1 = 2^l-1" src="Binary_heap_files/8a57d97a2a789245cc426fee11e59fe2.png"></p>
<p>Total number of nodes stored in the array till the index <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> = <img class="tex" alt="i+1" src="Binary_heap_files/15ab2d2b0b92c13f328635e5c4bdbe64.png"> (Counting <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> too)</p>
<p>So, total number of siblings on the left of <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> is</p>
<dl>
<dd><img class="tex" alt="= \text{Number of nodes including }i - \text{Number of nodes through the previous level} - \text{One node for }i\text{ itself}" src="Binary_heap_files/9a0418815579b109599cdd30f63cea11.png"></dd>
<dd><img class="tex" alt="= (i + 1) - (2^l - 1) - 1" src="Binary_heap_files/22e1c68449f47a84dda140b95d15af69.png"></dd>
<dd><img class="tex" alt="= i + 1 - 2^l + 1 - 1" src="Binary_heap_files/92638e6a4bbc39e87e13a681d4b4b19c.png"></dd>
<dd><img class="tex" alt="= i - 2^l + 1" src="Binary_heap_files/1db14990ab895f1380f283d084f1db96.png"></dd>
</dl>
<p>Hence, total number of children of these siblings = <img class="tex" alt="2(i-2^l+1)" src="Binary_heap_files/83d2c794d7730171487d5dff1cc5200b.png"></p>
<p>Number of elements at any given level <img class="tex" alt="l" src="Binary_heap_files/2db95e8e1a9267b7a1188556b2013b33.png"> = <img class="tex" alt="2^l" src="Binary_heap_files/c095463c78ef0972e0ccf653efd26dce.png"></p>
<p>So, total siblings to right of <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> is:-</p>
<dl>
<dd><img class="tex" alt="= \text{Total nodes in level }l - (\text{Total siblings on left} + 1)" src="Binary_heap_files/1d0ccfc4076a8c6ea45704718523719a.png"></dd>
<dd><img class="tex" alt="= (2^l) - (i-2^l + 2)" src="Binary_heap_files/eee87d1a6a8cdfb2e1e2365e321e85f6.png"></dd>
<dd><img class="tex" alt="= 2^l + 2^l - i - 2)" src="Binary_heap_files/ae5a2f968c093f02f84420ba0483f8da.png"></dd>
<dd><img class="tex" alt="= 2^{l+1} - i - 2" src="Binary_heap_files/480414c7d49119f9954ce3393b7f9795.png"></dd>
</dl>
<p>So, index of 1st child of node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> would be:-</p>
<dl>
<dd><img class="tex" alt="= i + \text{Total siblings on right} + 2*\text{Total siblings on left} + 1" src="Binary_heap_files/4b913c248287559f13e039bfb88765a4.png"></dd>
<dd><img class="tex" alt="= i + (2^{l+1} - i - 2) + 2(i - 2^l + 1) + 1" src="Binary_heap_files/89b4302f277afd9e665d3f53c4480dfa.png"></dd>
<dd><img class="tex" alt="= i + 2^{l+1} - i - 2 + 2i - 2^{l+1} + 2 + 1" src="Binary_heap_files/dbab8803a4ab13aefffb72a5659df455.png"></dd>
<dd><img class="tex" alt="= i - i + 2i + 2^{l+1} - 2^{l+1} - 2 + 2 + 1" src="Binary_heap_files/8fefa6cb4024312085baa81b2e251523.png"></dd>
<dd>
<img class="tex" alt="= 2i + 1" src="Binary_heap_files/83eefc815ef15bc6b98dec89f0b06276.png"> [Proved]</dd>
</dl>
<h3> <span class="mw-headline" id="Intuitive_proof">Intuitive proof</span>
</h3>
<p>Although the mathematical approach proves this without doubt, the 
simplicity of the resulting equation suggests that there should be a 
simpler way to arrive at this conclusion.</p>
<p>For this two facts should be noted.</p>
<ul>
<li>Children for node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> will be found at the very first empty slot.</li>
<li>Second is that, all nodes previous to node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png">, right up to the root, will have exactly two children. This is necessary to maintain the shape of the <a href="http://en.m.wikipedia.org/wiki/Heap_%28data_structure%29" title="Heap (data structure)">heap</a>.</li>
</ul>
<p>Now since all nodes have two children (as per the second fact) so all memory slots taken by the children will be <img class="tex" alt="2((i+1)-1) = 2i" src="Binary_heap_files/b3965e2a501293e444bd1c1b0e42fe62.png">. We add one since <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> starts at zero. Then we subtract one since node <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png"> doesn't yet have any children.</p>
<p>This means all filled memory slots have been accounted for except one
 – the root node. Root is child to none. So finally, the count of all 
filled memory slots are <img class="tex" alt="2i + 1" src="Binary_heap_files/a17022c3643548e48f666c66236fad49.png">.</p>
<p>So, by fact one and since our indexing starts at zero, <img class="tex" alt="2i + 1" src="Binary_heap_files/a17022c3643548e48f666c66236fad49.png"> itself gives the index of the first child of <img class="tex" alt="i" src="Binary_heap_files/865c0c0b4ab0e063e5caa3387c1a8741.png">.</p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_5">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Heap_%28data_structure%29" title="Heap (data structure)">Heap</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">Heapsort</a></li>
</ul>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_6">
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="#cite_ref-0">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.python.org/library/heapq.html">"heapq – Heap queue algorithm"</a>. <i>Python Standard Library</i><span class="printonly">. <a rel="nofollow" class="external free" href="http://docs.python.org/library/heapq.html">http://docs.python.org/library/heapq.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=heapq+%E2%80%93+Heap+queue+algorithm&amp;rft.atitle=Python+Standard+Library&amp;rft_id=http%3A%2F%2Fdocs.python.org%2Flibrary%2Fheapq.html&amp;rfr_id=info:sid/en.wikipedia.org:Binary_heap"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/javase/6/docs/api/java/util/PriorityQueue.html">"Class PriorityQueue"</a>. <i>Java™ Platform Standard Ed. 6</i><span class="printonly">. <a rel="nofollow" class="external free" href="http://download.oracle.com/javase/6/docs/api/java/util/PriorityQueue.html">http://download.oracle.com/javase/6/docs/api/java/util/PriorityQueue.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Class+PriorityQueue&amp;rft.atitle=Java%E2%84%A2+Platform+Standard+Ed.+6&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fjavase%2F6%2Fdocs%2Fapi%2Fjava%2Futil%2FPriorityQueue.html&amp;rfr_id=info:sid/en.wikipedia.org:Binary_heap"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-CLRS-2">
<span class="mw-cite-backlink">^ <a href="#cite_ref-CLRS_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CLRS_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation" id="CITEREFCormenal.2001">Cormen, T. H. &amp; al. (2001), <i>Introduction to Algorithms</i> (2nd ed.), Cambridge, Massachusetts: The MIT Press, <a href="http://en.m.wikipedia.org/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-07-013151-1" title="Special:BookSources/0-07-013151-1">0-07-013151-1</a></span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+Algorithms&amp;rft.aulast=Cormen&amp;rft.aufirst=T.+H.&amp;rft.au=Cormen%2C%26%2332%3BT.+H.&amp;rft.au=al.&amp;rft.date=2001&amp;rft.edition=2nd&amp;rft.place=Cambridge%2C+Massachusetts&amp;rft.pub=The+MIT+Press&amp;rft.isbn=0-07-013151-1&amp;rfr_id=info:sid/en.wikipedia.org:Binary_heap"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Poul-Henning Kamp. <a rel="nofollow" class="external text" href="http://queue.acm.org/detail.cfm?id=1814327">"You're Doing It Wrong"</a>. ACM Queue. June 11, 2010.</span>
</li>
<li id="cite_note-4">
<span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Chris L. Kuszmaul. <a rel="nofollow" class="external text" href="http://nist.gov/dads/HTML/binaryheap.html">"binary heap"</a>.
 Dictionary of Algorithms and Data Structures, Paul E. Black, ed., U.S. 
National Institute of Standards and Technology. 16 November 2009.</span>
</li>
<li id="cite_note-sym-5">
<span class="mw-cite-backlink"><b><a href="#cite_ref-sym_5-0">^</a></b></span> <span class="reference-text"><span class="citation web">Atkinson, M.D., <a href="http://en.m.wikipedia.org/wiki/J%C3%B6rg-R%C3%BCdiger_Sack" title="Jörg-Rüdiger Sack">J.-R. Sack</a>, N. Santoro, and T. Strothotte (1 October 1986). <a rel="nofollow" class="external text" href="http://cg.scs.carleton.ca/%7Emorin/teaching/5408/refs/minmax.pdf">"Min-max heaps and generalized priority queues."</a>. Programming techniques and Data structures. Comm. ACM, 29(10): 996–1000<span class="printonly">. <a rel="nofollow" class="external free" href="http://cg.scs.carleton.ca/%7Emorin/teaching/5408/refs/minmax.pdf">http://cg.scs.carleton.ca/~morin/teaching/5408/refs/minmax.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Min-max+heaps+and+generalized+priority+queues.&amp;rft.atitle=&amp;rft.aulast=Atkinson%2C+M.D.%2C+%5B%5BJ%C3%B6rg-R%C3%BCdiger+Sack%7CJ.-R.+Sack%5D%5D%2C+N.+Santoro%2C+and+T.+Strothotte&amp;rft.au=Atkinson%2C+M.D.%2C+%5B%5BJ%C3%B6rg-R%C3%BCdiger+Sack%7CJ.-R.+Sack%5D%5D%2C+N.+Santoro%2C+and+T.+Strothotte&amp;rft.date=1+October+1986&amp;rft.pub=Programming+techniques+and+Data+structures.+Comm.+ACM%2C+29%2810%29%3A+996%E2%80%931000&amp;rft_id=http%3A%2F%2Fcg.scs.carleton.ca%2F%7Emorin%2Fteaching%2F5408%2Frefs%2Fminmax.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Binary_heap"><span style="display: none;">&nbsp;</span></span></span>
</li>
</ol>
</div>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li>
<a rel="nofollow" class="external text" href="http://people.ksp.sk/%7Ekuko/bak/index.html">Binary Heap Applet</a> by Kubo Kovac</li>
<li><a rel="nofollow" class="external text" href="http://www.policyalmanac.org/games/binaryHeaps.htm">Using Binary Heaps in A* Pathfinding</a></li>
<li><a rel="nofollow" class="external text" href="http://sites.google.com/site/indy256/algo-en/binary_heap">Java Implementation of Binary Heap</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/valyala/gheap">C++ implementation of generalized heap with Binary Heap support</a></li>
<li><a rel="nofollow" class="external text" href="http://opendatastructures.org/versions/edition-0.1d/ods-java/node52.html">Open Data Structures - Section 10.1 - BinaryHeap: An Implicit Binary Tree</a></li>
<li>
<span class="citation web">Igushev, Eduard. <a rel="nofollow" class="external text" href="http://igushev.com/implementations/binary-heap-cpp/">"Binary Heap C++ implementation"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://igushev.com/implementations/binary-heap-cpp/">http://igushev.com/implementations/binary-heap-cpp/</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Binary+Heap+C%2B%2B+implementation&amp;rft.atitle=&amp;rft.aulast=Igushev&amp;rft.aufirst=Eduard&amp;rft.au=Igushev%2C%26%2332%3BEduard&amp;rft_id=http%3A%2F%2Figushev.com%2Fimplementations%2Fbinary-heap-cpp%2F&amp;rfr_id=info:sid/en.wikipedia.org:Binary_heap"><span style="display: none;">&nbsp;</span></span>
</li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Binary_heap&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Binary+heap&amp;mobiletoken=5c89e355d2af09275b3b2ed3653e1683" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Binary_heap&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Binary+heap&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Binary_heap_files/load_002.php" type="text/javascript"></script>
<script src="Binary_heap_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>