<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Persistent data structure - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Persistent_data_structure_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 9 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Persistent_data_structure">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Persistent_data_structure_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Persistent_data_structure_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Persistent_data_structure_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Persistent_data_structure" selected="selected">English</option><option value="//es.m.wikipedia.org/wiki/Persistencia_de_objetos">español</option><option value="//fa.m.wikipedia.org/wiki/%D8%B3%D8%A7%D8%AE%D8%AA%D8%A7%D8%B1_%D8%AF%D8%A7%D8%AF%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D9%85%D8%A7%D9%86%D8%AF%DA%AF%D8%A7%D8%B1">فارسی</option><option value="//fr.m.wikipedia.org/wiki/Structure_de_donn%C3%A9es_persistante">français</option><option value="//is.m.wikipedia.org/wiki/Varanleg_gagnaskipan">íslenska</option><option value="//it.m.wikipedia.org/wiki/Struttura_dati_persistente">italiano</option><option value="//ja.m.wikipedia.org/wiki/%E6%B0%B8%E7%B6%9A%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0">日本語</option><option value="//pl.m.wikipedia.org/wiki/Trwa%C5%82a_struktura_danych">polski</option><option value="//pt.m.wikipedia.org/wiki/Persist%C3%AAncia_de_dados">português</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Persistent data structure</h1>			
<p>In <a href="http://en.m.wikipedia.org/wiki/Computing" title="Computing">computing</a>, a <b>persistent data structure</b> is a <a href="http://en.m.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> that always preserves the previous version of itself when it is modified. Such data structures are effectively <a href="http://en.m.wikipedia.org/wiki/Immutable_object" title="Immutable object">immutable</a>,
 as their operations do not (visibly) update the structure in-place, but
 instead always yield a new updated structure. (A persistent data 
structure is <i>not</i> a data structure committed to <a href="http://en.m.wikipedia.org/wiki/Persistent_storage" title="Persistent storage" class="mw-redirect">persistent storage</a>, such as a disk; this is a different and unrelated sense of the word "persistent.")</p>
<p>A data structure is partially persistent if all versions can be 
accessed but only the newest version can be modified. The data structure
 is fully persistent if every version can be both accessed and modified.
 If there is also a meld or merge operation that can create a new 
version from two previous versions, the data structure is called 
confluently persistent. Structures that are not persistent are called <a href="http://en.m.wikipedia.org/wiki/Ephemeral_%28disambiguation%29" title="Ephemeral (disambiguation)" class="mw-redirect">ephemeral</a>.<sup id="cite_ref-kaplan_0-0" class="reference"><a href="#cite_note-kaplan-0"><span>[</span>1<span>]</span></a></sup></p>
<p>These types of data structures are particularly common in <a href="http://en.m.wikipedia.org/wiki/Logic_programming" title="Logic programming">logical</a> and <a href="http://en.m.wikipedia.org/wiki/Functional_programming" title="Functional programming">functional programming</a>, and in a <a href="http://en.m.wikipedia.org/wiki/Purely_functional" title="Purely functional">purely functional</a> program all data is immutable, so all data structures are automatically fully persistent.<sup id="cite_ref-kaplan_0-1" class="reference"><a href="#cite_note-kaplan-0"><span>[</span>1<span>]</span></a></sup>
 Persistent data structures can also be created using in-place updating 
of data and these may, in general, use less time or storage space than 
their purely functional counterparts.</p>
<p>While persistence can be achieved by simple copying, this is 
inefficient in time and space, because most operations make only small 
changes to a data structure. A better method is to exploit the 
similarity between the new and old versions to share structure between 
them, such as using the same subtree in a number of <a href="http://en.m.wikipedia.org/wiki/Tree_structure" title="Tree structure">tree structures</a>.
 However, because it rapidly becomes infeasible to determine how many 
previous versions share which parts of the structure, and because it is 
often desirable to discard old versions, this necessitates an 
environment with <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">garbage collection</a>.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Partially_persistent">Partially persistent</span></h2><div class="content_block" id="content_1">
<p>In partially persistence model, we may query any previous version of 
the data structure, but we may only update the latest version. This 
implies a <a href="http://en.m.wikipedia.org/wiki/Total_order" title="Total order">linear ordering</a> among the versions.<br></p>
<p><i>Three methods on <a href="http://en.m.wikipedia.org/wiki/Balanced_binary_search_tree" title="Balanced binary search tree" class="mw-redirect">balanced binary search tree</a>:</i><br></p>
<h3> <span class="mw-headline" id="Fat_Node">Fat Node</span>
</h3>
<p>Fat node method is to record all changes made to node fields in the 
nodes themselves, without erasing old values of the fields. This 
requires that we allow nodes to become arbitrarily “fat”. In other 
words, each fat node contains the same information and <a href="http://en.m.wikipedia.org/wiki/Pointer_%28computer_programming%29" title="Pointer (computer programming)">pointer</a>
 fields as an ephemeral node, along with space for an arbitrary number 
of extra field values. Each extra field value has an associated field 
name and a version stamp which indicates the version in which the named 
field was changed to have the specified value. Besides, each fat node 
has its own version stamp, indicating the version in which the node was 
created. The only purpose of nodes having version stamps is to make sure
 that each node only contains one value per field name per version. In 
order to navigate through the structure, each original field value in a 
node has a version stamp of zero.<br></p>
<h4> <span class="mw-headline" id="Complexity_of_Fat_Node">Complexity of Fat Node</span>
</h4>
<p>With using fat node method, it requires O(1) space for every 
modification: just store the new data. Each modification takes O(1) 
additional time to store the modification at the end of the modification
 history. This is an <a href="http://en.m.wikipedia.org/wiki/Amortized_analysis" title="Amortized analysis">amortized time</a> bound, assuming we store the modification history in a growable <a href="http://en.m.wikipedia.org/wiki/Array_data_structure" title="Array data structure">array</a>. For <a href="http://en.m.wikipedia.org/wiki/Access_time" title="Access time">access time</a>,
 we must find the right version at each node as we traverse the 
structure. If we made m modifications, then each access operation has 
O(logm) slowdown, and a query in our region computation will take 
O(log2n) time. Since we have arranged the modification history, using 
time stamp, so it takes O(logm) time to find the last modification 
before an arbitrary time stamp.<br></p>
<h3> <span class="mw-headline" id="Path_Copying">Path Copying</span>
</h3>
<p>Path copy is to make a copy of all nodes on the path which contains the node we about to insert or delete. Then you have to <a href="http://en.m.wikipedia.org/wiki/Fractional_cascading" title="Fractional cascading">cascade</a>
 the change back through the data structure: all nodes that pointed to 
the old node must be modified to point to the new node instead. These 
modifications cause more cascading changes, and so on, until we reach to
 the root. Maintain an array of roots indexed by timestamp. The data 
structure pointed to by time t’s root is exactly time t’s date 
structure.<br></p>
<h4> <span class="mw-headline" id="Complexity_of_Path_Copying">Complexity of Path Copying</span>
</h4>
<p>With m modifications, this costs O(logm) additive <a href="http://en.m.wikipedia.org/wiki/Lookup" title="Lookup" class="mw-redirect">lookup</a>
 time. Modification time and space are bounded by the size of the 
structure, since a single modification may cause the entire structure to
 be copied. That’s O(m) for one update, and thus O(n2) preprocessing 
time.<br></p>
<h3> <span class="mw-headline" id="A_combination">A combination</span>
</h3>
<p>Sleator, <a href="http://en.m.wikipedia.org/wiki/Robert_Tarjan" title="Robert Tarjan">Tarjan</a> et al. came up with a way to combine the advantages of <strong class="selflink">fat nodes</strong> and <strong class="selflink">path copying</strong>, getting O(1) access slowdown and O(1) modification space and time.<br></p>
<p>In each node, we store one modification box. This box can hold one 
modification to the node—either a modification to one of the pointers, 
or to the node’s key, or to some other piece of node-specific data—and a
 timestamp for when that modification was applied. Initially, every 
node’s modification box is empty.<br></p>
<p>Whenever we access a node, we check the modification box, and compare
 its timestamp against the access time. (The access time specifies the 
version of the data structure that we care about.) If the modification 
box is empty, or the access time is before the modification time, then 
we ignore the modification box and just deal with the normal part of the
 node. On the other hand, if the access time is after the modification 
time, then we use the value in the modification box, overriding that 
value in the node. (Say the modification box has a new left pointer. 
Then we’ll use it instead of the normal left pointer, but we’ll still 
use the normal right pointer.)<br></p>
<p>Modifying a node works like this. (We assume that each modification 
touches one pointer or similar field.) If the node’s modification box is
 empty, then we fill it with the modification. Otherwise, the 
modification box is full. We make a copy of the node, but using only the
 latest values.(That is, we overwrite one of the node’s fields with the 
value that was stored in the modification box.) Then we perform the 
modification directly on the new node, without using the modification 
box. (We overwrite one of the new node’s fields, and its modification 
box stays empty.) Finally, we cascade this change to the node’s parent, 
just like path copying. (This may involve filling the parent’s 
modification box, or making a copy of the parent recursively. If the 
node has no parent—it’s the root—we add the new root to a <a href="http://en.m.wikipedia.org/wiki/Sorted_array" title="Sorted array">sorted array</a> of roots.)<br></p>
<p>With this <a href="http://en.m.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a>,
 given any time t, at most one modification box exists in the data 
structure with time t. Thus, a modification at time t splits the tree 
into three parts: one part contains the data from before time t, one 
part contains the data from after time t, and one part was unaffected by
 the modification.<br></p>
<h4> <span class="mw-headline" id="Complexity_of_the_combination">Complexity of the combination</span>
</h4>
<p>Time and space for modifications require amortized analysis. A 
modification takes O(1) amortized space, and O(1) amortized time. To see
 why, use a <a href="http://en.m.wikipedia.org/wiki/Potential_method" title="Potential method">potential function</a>
 ϕ,where ϕ(T)is the number of full live nodes in T . The live nodes of T
 are just the nodes that are reachable from the current root at the 
current time (that is, after the last modification). The full live nodes
 are the live nodes whose modification boxes are full.<br></p>
<p>Each modification involves some number of copies, say k, followed by 1
 change to a modification box. (Well, not quite—you could add a new 
root—but that doesn’t change the argument.) Consider each of the k 
copies. Each costs O(1) space and time, but decreases the potential 
function by one. (First, the node we copy must be full and live, so it 
contributes to the potential function. The potential function will only 
drop, however, if the old node isn’t reachable in the new tree. But we 
know it isn’t reachable in the new tree—the next step in the algorithm 
will be to modify the node’s parent to point at the copy. Finally, we 
know the copy’s modification box is empty. Thus, we’ve replaced a full 
live node with an empty live node, and ϕ goes down by one.) The final 
step fills a modification box, which costs O(1) time and increases ϕ by 
one.<br></p>
<p>Putting it all together, the change in ϕ is Δϕ =1− k.Thus, we’ve paid O(k +Δϕ)= O(1) space and O(k +Δϕ +1) = O(1) time.<br></p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Fully_persistent">Fully persistent</span></h2><div class="content_block" id="content_2">
<p>In fully persistent model, both updates and queries are allowed on any version of the data structure.<br></p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Confluently_persistent">Confluently persistent</span></h2><div class="content_block" id="content_3">
<p>In confluently persistent model, we use combinatiors to combine input
 of more than one previous versions to output a new single version. 
Rather than a branching tree, combinations of versions induce a <a href="http://en.m.wikipedia.org/wiki/Directed_acyclic_graph" title="Directed acyclic graph">DAG</a> (direct acyclic graph) structure on the version graph.<br></p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Examples_of_persistent_data_structures">Examples of persistent data structures</span></h2><div class="content_block" id="content_4">
<p>Perhaps the simplest persistent data structure is the <a href="http://en.m.wikipedia.org/wiki/Linked_list" title="Linked list">singly linked list</a> or <i>cons</i>-based list, a simple list of objects formed by each carrying a <a href="http://en.m.wikipedia.org/wiki/Reference" title="Reference">reference</a> to the next in the list. This is persistent because we can take a <i>tail</i> of the list, meaning the last <i>k</i> items for some <i>k</i>,
 and add new nodes on to the front of it. The tail will not be 
duplicated, instead becoming shared between both the old list and the 
new list. So long as the contents of the tail are immutable, this 
sharing will be invisible to the program.</p>
<p>Many common reference-based data structures, such as <a href="http://en.m.wikipedia.org/wiki/Red-black_tree" title="Red-black tree" class="mw-redirect">red-black trees</a>,<sup id="cite_ref-sarnak_1-0" class="reference"><a href="#cite_note-sarnak-1"><span>[</span>2<span>]</span></a></sup> and <a href="http://en.m.wikipedia.org/wiki/Stack_%28data_structure%29" title="Stack (data structure)" class="mw-redirect">stacks</a>,<sup id="cite_ref-okasaki_2-0" class="reference"><a href="#cite_note-okasaki-2"><span>[</span>3<span>]</span></a></sup> can easily be adapted to create a persistent version. Some others need slightly more effort, for example: <a href="http://en.m.wikipedia.org/wiki/Queue_%28data_structure%29" title="Queue (data structure)" class="mw-redirect">Queue</a>, <a href="http://en.m.wikipedia.org/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queues</a> (dequeue), <span class="new" title="Min-Dequeue (page does not exist)">Min-Dequeue</span>
 (which have additional operation min returning minimal element in 
constant time without incurring additional complexity on standard 
operations of queuing and dequeuing on both ends), <span class="new" title="Random access list (page does not exist)">Random access list</span>
 (with constant cons/head as single linked list, but with additional 
operation of random access with sub-linear, most often logarithmic, 
complexity), <span class="new" title="Random access queue (page does not exist)">Random access queue</span>, Random access double-ended queue and Random access stack (as well Random access Min-List, Min-Queue, Min-Dequeue, Min-Stack).</p>
<p>There also exist persistent data structures which use destructible 
operations, making them impossible to implement efficiently in purely 
functional languages (like Haskell), but possible in languages like C or
 Java. These types of data structures can be avoided with proper design.
 One primary advantage to using purely persistent data structures is 
that they often behave better in multi-threaded environments.</p>
<p><br></p>
<h3> <span class="mw-headline" id="Linked_lists">Linked lists</span>
</h3>
<p><i>This example is taken from Okasaki. See the bibliography.</i></p>
<p>Singly <a href="http://en.m.wikipedia.org/wiki/Linked_list" title="Linked list">linked lists</a> are the bread-and-butter data structure in functional languages. In <a href="http://en.m.wikipedia.org/wiki/ML_programming_language" title="ML programming language" class="mw-redirect">ML</a>-derived languages and <a href="http://en.m.wikipedia.org/wiki/Haskell_%28programming_language%29" title="Haskell (programming language)">Haskell</a>,
 they are purely functional because once a node in the list has been 
allocated, it cannot be modified, only copied or destroyed. Note that ML
 itself is <b>not</b> purely functional.</p>
<p>Consider the two lists:</p>
<pre>xs = [0, 1, 2]
ys = [3, 4, 5]
</pre>
<p>These would be represented in memory by:</p>
<p><a href="http://en.m.wikipedia.org/wiki/File:Purely_functional_list_before.svg" class="image"><img alt="Purely functional list before.svg" src="Persistent_data_structure_files/168px-Purely_functional_list_before.png" width="168" height="325"></a></p>
<p>where a circle indicates a node in the list (the arrow out showing 
the second element of the node which is a pointer to another node).</p>
<p>Now concatenating the two lists:</p>
<pre>zs = xs ++ ys
</pre>
<p>results in the following memory structure:</p>
<p><a href="http://en.m.wikipedia.org/wiki/File:Purely_functional_list_after.svg" class="image"><img alt="Purely functional list after.svg" src="Persistent_data_structure_files/258px-Purely_functional_list_after.png" width="258" height="595"></a></p>
<p>Notice that the nodes in list <code>xs</code> have been copied, but the nodes in <code>ys</code> are shared. As a result, the original lists (<code>xs</code> and <code>ys</code>) persist and have not been modified.</p>
<p>The reason for the copy is that the last node in <code>xs</code> (the node containing the original value <code>2</code>) cannot be modified to point to the start of <code>ys</code>, because that would change the value of <code>xs</code>.</p>
<h3> <span class="mw-headline" id="Trees">Trees</span>
</h3>
<p><i>This example is taken from Okasaki. See the bibliography.</i></p>
<p>Consider a <a href="http://en.m.wikipedia.org/wiki/Binary_tree" title="Binary tree">binary tree</a> used for fast searching, where every node has the <a href="http://en.m.wikipedia.org/wiki/Recursion" title="Recursion">recursive</a> <a href="http://en.m.wikipedia.org/wiki/Invariant_%28computer_science%29" title="Invariant (computer science)">invariant</a> that subnodes on the left are less than the node, and subnodes on the right are greater than the node.</p>
<p>For instance, the set of data</p>
<pre>xs = [a, b, c, d, f, g, h]
</pre>
<p>might be represented by the following binary search tree:</p>
<p><a href="http://en.m.wikipedia.org/wiki/File:Purely_functional_tree_before.svg" class="image"><img alt="Purely functional tree before.svg" src="Persistent_data_structure_files/348px-Purely_functional_tree_before.png" width="348" height="325"></a></p>
<p>A function which inserts data into the binary tree and maintains the invariant is:</p>
<pre>fun insert (x, E) = T (E, x, E)
  | insert (x, s as T (a, y, b)) =
       if x &lt; y then T (insert (x, a), y, b)
       else if x &gt; y then T (a, y, insert (x, b))
       else s
</pre>
<p>After executing</p>
<pre>ys = insert ("e", xs)
</pre>
<p>we end up with the following:</p>
<p><a href="http://en.m.wikipedia.org/wiki/File:Purely_functional_tree_after.svg" class="image"><img alt="Purely functional tree after.svg" src="Persistent_data_structure_files/438px-Purely_functional_tree_after.png" width="438" height="415"></a></p>
<p>Notice two points: Firstly the original tree (<code>xs</code>) 
persists. Secondly many common nodes are shared between the old tree and
 the new tree. Such persistence and sharing is difficult to manage 
without some form of <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" title="Garbage collection (computer science)">garbage collection</a> (GC) to automatically free up nodes which have no live references, and this is why GC is a feature commonly found in <a href="http://en.m.wikipedia.org/wiki/Functional_programming" title="Functional programming">functional programming languages</a>.</p>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="Reference_cycles">Reference cycles</span></h2><div class="content_block" id="content_5">
<p>Since every value in a purely functional computation is built up out 
of existing values, it would seem that it is impossible to create a 
cycle of references. In that case, the reference graph (the graph of the
 references from object to object) could only be a <a href="http://en.m.wikipedia.org/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graph</a>. However, in most functional languages, functions can be defined <a href="http://en.m.wikipedia.org/wiki/Recursion" title="Recursion">recursively</a>; this capability allows recursive structures using functional <span class="new" title="Suspension (computer science) (page does not exist)">suspensions</span>. In <a href="http://en.m.wikipedia.org/wiki/Lazy_evaluation" title="Lazy evaluation">lazy</a> languages, such as <a href="http://en.m.wikipedia.org/wiki/Haskell_%28programming_language%29" title="Haskell (programming language)">Haskell</a>, all data structures are represented as implicitly suspended <a href="http://en.m.wikipedia.org/wiki/Thunk" title="Thunk">thunks</a>;
 in these languages any data structure can be recursive because a value 
can be defined in terms of itself. Some other languages, such as <a href="http://en.m.wikipedia.org/wiki/OCaml" title="OCaml">OCaml</a>, allow the explicit definition of recursive values.</p>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="See_also">See also</span></h2><div class="content_block" id="content_6">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Persistence_%28computer_science%29" title="Persistence (computer science)">Persistence (computer science)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Navigational_Database" title="Navigational Database" class="mw-redirect">Navigational Database</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Copy-on-write" title="Copy-on-write">Copy-on-write</a></li>
</ul>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_7">
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-kaplan-0">
<span class="mw-cite-backlink">^ <a href="#cite_ref-kaplan_0-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-kaplan_0-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation Journal">Kaplan, Haim (2001). <a rel="nofollow" class="external text" href="http://www.math.tau.ac.il/%7Ehaimk/papers/persistent-survey.ps">"Persistent data structures"</a>. <i>Handbook on Data Structures and Applications</i> (CRC Press)<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.math.tau.ac.il/%7Ehaimk/papers/persistent-survey.ps">http://www.math.tau.ac.il/~haimk/papers/persistent-survey.ps</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Persistent+data+structures&amp;rft.jtitle=Handbook+on+Data+Structures+and+Applications&amp;rft.aulast=Kaplan%2C+Haim&amp;rft.au=Kaplan%2C+Haim&amp;rft.date=2001&amp;rft.pub=CRC+Press&amp;rft_id=http%3A%2F%2Fwww.math.tau.ac.il%2F%7Ehaimk%2Fpapers%2Fpersistent-survey.ps&amp;rfr_id=info:sid/en.wikipedia.org:Persistent_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-sarnak-1">
<span class="mw-cite-backlink"><b><a href="#cite_ref-sarnak_1-0">^</a></b></span> <span class="reference-text"><span class="citation Journal">Neil Sarnak, <a href="http://en.m.wikipedia.org/wiki/Robert_Tarjan" title="Robert Tarjan">Robert E. Tarjan</a> (1986). <a rel="nofollow" class="external text" href="http://www.link.cs.cmu.edu/15859-f07/papers/point-location.pdf">"Planar Point Location Using Persistent Search Trees"</a>. <i>Communications of the ACM</i> <b>29</b> (7): 669–679. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F6138.6151">10.1145/6138.6151</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.link.cs.cmu.edu/15859-f07/papers/point-location.pdf">http://www.link.cs.cmu.edu/15859-f07/papers/point-location.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Planar+Point+Location+Using+Persistent+Search+Trees&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.aulast=Neil+Sarnak%2C+%5B%5BRobert+Tarjan%7CRobert+E.+Tarjan%5D%5D&amp;rft.au=Neil+Sarnak%2C+%5B%5BRobert+Tarjan%7CRobert+E.+Tarjan%5D%5D&amp;rft.date=1986&amp;rft.volume=29&amp;rft.issue=7&amp;rft.pages=669%E2%80%93679&amp;rft_id=info:doi/10.1145%2F6138.6151&amp;rft_id=http%3A%2F%2Fwww.link.cs.cmu.edu%2F15859-f07%2Fpapers%2Fpoint-location.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Persistent_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-okasaki-2">
<span class="mw-cite-backlink"><b><a href="#cite_ref-okasaki_2-0">^</a></b></span> <span class="reference-text"><span class="citation Journal">Chris Okasaki. <a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/%7Erwh/theses/okasaki.pdf"><i>Purely Functional Data Structures (thesis)</i></a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.cmu.edu/%7Erwh/theses/okasaki.pdf">http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Purely+Functional+Data+Structures+%28thesis%29&amp;rft.aulast=Chris+Okasaki&amp;rft.au=Chris+Okasaki&amp;rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2F%7Erwh%2Ftheses%2Fokasaki.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Persistent_data_structure"><span style="display: none;">&nbsp;</span></span></span>
</li>
</ol>
</div>
</div><a id="anchor_7" href="#section_7" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_8"><button>Show</button><span id="Further_reading">Further reading</span></h2><div class="content_block" id="content_8">
<div class="refbegin" style="">
<ul>
<li>
<a rel="nofollow" class="external text" href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey">Persistent Data Structures and Managed References</a> - video presentation by Rich Hickey on Clojure's use of persistent data structures and how they support concurrency</li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/%7Esleator/papers/Persistence.htm">Making Data Structures Persistent</a> by James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan</li>
<li><a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1317">Fully persistent arrays for efficient incremental updates and voluminous reads</a></li>
<li><a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.2895">Real-Time Deques, Multihead Turing Machines, and Purely Functional Programming</a></li>
<li>
<i>Purely functional data structures</i> by Chris Okasaki, <a href="http://en.m.wikipedia.org/wiki/Cambridge_University_Press" title="Cambridge University Press">Cambridge University Press</a>, 1998, <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0521663504" class="internal mw-magiclink-isbn">ISBN 0-521-66350-4</a>.</li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/%7Erwh/theses/okasaki.pdf">Purely Functional Data Structures</a> thesis by Chris Okasaki (PDF format)</li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/%7Esleator/papers/fully-persistent-lists.pdf">Fully Persistent Lists with Catenation</a> by James R. Driscoll, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li>
<a rel="nofollow" class="external text" href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005/lecture-notes/persistent.pdf">Persistent Data Structures</a> from MIT open course <a rel="nofollow" class="external text" href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005">Advanced Algorithms</a>
</li>
</ul>
</div>
</div><a id="anchor_8" href="#section_8" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_9"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_9">
<ul>
<li><a rel="nofollow" class="external text" href="http://wiki.edinburghhacklab.com/PersistentRedBlackTreeSet">Lightweight Java implementation of Persistent Red-Black Trees</a></li>
</ul>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Persistent_data_structure&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Persistent+data+structure&amp;mobiletoken=5c89e355d2af09275b3b2ed3653e1683" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Persistent_data_structure&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Persistent+data+structure&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Persistent_data_structure_files/load_002.php" type="text/javascript"></script>
<script src="Persistent_data_structure_files/load.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>