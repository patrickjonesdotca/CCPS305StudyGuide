<!DOCTYPE html>
<html class="jsEnabled togglingEnabled" dir="ltr" lang="en"><head>
		<title>Binary space partitioning - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="robots" content="noindex,nofollow">		<link rel="stylesheet" href="Binary_space_partitioning_files/load.css" type="text/css" media="all">		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png">		<script type="text/javascript">
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-header":"This article is available in 12 languages","mobile-frontend-language-footer":"<a href=\"\/wiki\/Special:Special:MobileOptions\/Language\">Wikipedia is available in other languages.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"scriptPath":"\/w","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			document.documentElement.className = 'jsEnabled page-loading';		</script>
		<link rel="canonical" href="http://en.wikipedia.org/wiki/Binary_space_partitioning">
	</head>
	<body class="mobile mw-mf-checkboxes">
							<div id="mw-mf-header">
					<form id="mw-mf-searchForm" action="/w/index.php" class="search_bar" method="get">
							<img alt="Logo" id="mw-mf-logo" src="Binary_space_partitioning_files/W_logo_for_Mobile_Frontend.gif" width="35" height="22">
						<input value="Special:Search" name="title" type="hidden">
			<div id="mw-mf-sq" class="divclearable">
				<input name="search" id="mw-mf-search" size="22" autocomplete="off" maxlength="1024" class="search" placeholder="Type your search here..." type="search">
				<img src="Binary_space_partitioning_files/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear">
			</div>
						<button id="goButton" class="goButton" type="submit">
				<img src="Binary_space_partitioning_files/blank.gif" alt="Go" title="Go">
			</button>
					</form>
									<div class="nav" id="nav">
				<div id="mw-mf-language-selection">
		Language:<br>
		<select id="languageselection"><option value="http://en.wikipedia.org/wiki/Binary_space_partitioning" selected="selected">English</option><option value="//cs.m.wikipedia.org/wiki/BSP_(po%C4%8D%C3%ADta%C4%8De)">česky</option><option value="//de.m.wikipedia.org/wiki/Binary_Space_Partitioning">Deutsch</option><option value="//es.m.wikipedia.org/wiki/Partici%C3%B3n_binaria_del_espacio">español</option><option value="//fr.m.wikipedia.org/wiki/Partition_binaire_de_l%27espace">français</option><option value="//ko.m.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%EA%B3%B5%EA%B0%84_%EB%B6%84%ED%95%A0%EB%B2%95">한국어</option><option value="//it.m.wikipedia.org/wiki/Partizione_binaria_dello_spazio">italiano</option><option value="//ja.m.wikipedia.org/wiki/%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E7%A9%BA%E9%96%93%E5%88%86%E5%89%B2">日本語</option><option value="//pl.m.wikipedia.org/wiki/Binary_Space_Partitioning">polski</option><option value="//pt.m.wikipedia.org/wiki/Particionamento_bin%C3%A1rio_de_espa%C3%A7o">português</option><option value="//ru.m.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0">русский</option><option value="//fi.m.wikipedia.org/wiki/Binary_space_partitioning">suomi</option></select>
	</div><br>
			<a href="http://en.m.wikipedia.org/wiki/Main_Page" id="homeButton" class="button">Home</a>
			<a href="http://en.m.wikipedia.org/wiki/Special:Random" id="randomButton" class="button">Random</a>
			</div>
		</div>
				<div id="results"><ul class="suggestions-results" title="No Results"><li class="suggestions-result">Type search term above and matching article titles will appear here.</li></ul></div>
		<div class="show" id="content_wrapper">
				<div id="content">
			<h1 id="firstHeading">Binary space partitioning</h1>			
<div class="dablink">For the .BSP file extension, see <a href="http://en.m.wikipedia.org/wiki/BSP_%28file_format%29" title="BSP (file format)">BSP (file format)</a>.</div>
<p>In <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, <b>binary space partitioning</b> (<b>BSP</b>) is a method for recursively subdividing a <a href="http://en.m.wikipedia.org/wiki/Euclidean_space" title="Euclidean space">space</a> into <a href="http://en.m.wikipedia.org/wiki/Convex_set" title="Convex set">convex sets</a> by <a href="http://en.m.wikipedia.org/wiki/Hyperplane" title="Hyperplane">hyperplanes</a>. This subdivision gives rise to a representation of objects within the space by means of a <a href="http://en.m.wikipedia.org/wiki/Tree_%28data_structure%29" title="Tree (data structure)">tree data structure</a> known as a <b>BSP tree</b>.</p>
<p>Binary space partitioning was developed in the context of <a href="http://en.m.wikipedia.org/wiki/3D_computer_graphics" title="3D computer graphics">3D computer graphics</a><sup id="cite_ref-schumacker69_0-0" class="reference"><a href="#cite_note-schumacker69-0"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-fuchs80_1-0" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>, where the structure of a BSP tree allows spatial information about the objects in a scene that is useful in <a href="http://en.m.wikipedia.org/wiki/Rendering_%28computer_graphics%29" title="Rendering (computer graphics)">rendering</a>,
 such as their ordering from front-to-back with respect to a viewer at a
 given location, to be accessed rapidly. Other applications include 
performing geometrical operations with shapes (<a href="http://en.m.wikipedia.org/wiki/Constructive_solid_geometry" title="Constructive solid geometry">constructive solid geometry</a>) in <a href="http://en.m.wikipedia.org/wiki/CAD" title="CAD" class="mw-redirect">CAD</a><sup id="cite_ref-thibault87_2-0" class="reference"><a href="#cite_note-thibault87-2"><span>[</span>3<span>]</span></a></sup>, <a href="http://en.m.wikipedia.org/wiki/Collision_detection" title="Collision detection">collision detection</a> in <a href="http://en.m.wikipedia.org/wiki/Robotics" title="Robotics">robotics</a> and 3-D <a href="http://en.m.wikipedia.org/wiki/Video_game" title="Video game">video games</a>, <a href="http://en.m.wikipedia.org/wiki/Ray_tracing" title="Ray tracing" class="mw-redirect">ray tracing</a> and other computer applications that involve handling of complex spatial scenes.</p>
<div class="section"><h2 class="section_heading" id="section_1"><button>Show</button><span id="Overview">Overview</span></h2><div class="content_block" id="content_1">
<p>Binary space partitioning is a generic process of <a href="http://en.m.wikipedia.org/wiki/Recursion" title="Recursion">recursively</a>
 dividing a scene into two until the partitioning satisfies one or more 
requirements. It can be seen as a generalisation of other spatial tree 
structures such as <a href="http://en.m.wikipedia.org/wiki/K-d_tree" title="K-d tree"><i>k</i>-d trees</a> and <a href="http://en.m.wikipedia.org/wiki/Quadtree" title="Quadtree">quadtrees</a>,
 one in which the hyperplanes which partition the space may have any 
orientation, rather than being aligned with the coordinate axes as they 
are in <i>k</i>-d trees or quadtrees. When used in computer graphics to render scenes composed of planar <a href="http://en.m.wikipedia.org/wiki/Polygon_mesh" title="Polygon mesh">polygons</a>, the partitioning planes are frequently (but not always) chosen to coincide with the planes defined by polygons in the scene.</p>
<p>The specific choice of partitioning plane and criterion for 
terminating the partitioning process varies depending on the purpose of 
the BSP tree. For example, in computer graphics rendering, the scene is 
divided until each node of the BSP tree contains only polygons which can
 be rendered in arbitrary order. When <a href="http://en.m.wikipedia.org/wiki/Back-face_culling" title="Back-face culling">back-face culling</a>
 is used, each node therefore contains a convex set of polygons, whereas
 when rendering double-sided polygons, each node of the BSP tree 
contains only polygons which lie in a single plane. In collision 
detection or ray tracing, a scene may be divided up into <a href="http://en.m.wikipedia.org/wiki/Geometric_primitive" title="Geometric primitive">primitives</a> on which collision or ray intersection tests are straightforward.</p>
<p>Binary space partitioning arose from the requirement in computer 
graphics to rapidly draw three dimensional scenes composed of polygons. A
 simple way to draw such scenes is the <a href="http://en.m.wikipedia.org/wiki/Painter%27s_algorithm" title="Painter's algorithm">painter's algorithm</a>,
 in which polygons are drawn in order of distance from the viewer, from 
back to front, painting over the background and previous polygons with 
each closer object. This approach has two disadvantages: the time 
required to sort polygons in order from back to front, and the 
possibility of errors when drawing overlapping polygons. Fuchs and 
co-authors<sup id="cite_ref-fuchs80_1-1" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>
 showed that construction of a BSP tree solved both of these problems, 
by providing a rapid method of sorting polygons with respect to a given 
viewpoint (linear in the number of polygons in the scene) and by 
subdividing overlapping polygons to avoid the errors that can occur when
 using the painter's algorithm. A disadvantage of using binary space 
partitioning is that the generation of a BSP tree can be a 
time-consuming operation. Typically, it is therefore performed once on 
static geometry, as a pre-calculation step, prior its use in rendering 
or other realtime operations on a scene. The expense of constructing a 
BSP tree makes it difficult and inefficient to directly implement moving
 objects into a tree.</p>
<p>BSP trees are often used by 3D <a href="http://en.m.wikipedia.org/wiki/Video_game" title="Video game">video games</a>, particularly <a href="http://en.m.wikipedia.org/wiki/First-person_shooter" title="First-person shooter">first-person shooters</a> and those with indoor environments. <a href="http://en.m.wikipedia.org/wiki/Game_engine" title="Game engine">Game engines</a> utilising BSP trees include the <a href="http://en.m.wikipedia.org/wiki/Doom_engine" title="Doom engine">Doom engine</a> (probably the earliest game to use a BSP data structure was <i><a href="http://en.m.wikipedia.org/wiki/Doom_%28video_game%29" title="Doom (video game)">Doom</a></i>), the <a href="http://en.m.wikipedia.org/wiki/Quake_engine" title="Quake engine">Quake engine</a> and its descendants. In video games, BSP trees containing the static geometry of a scene are often used together with a <a href="http://en.m.wikipedia.org/wiki/Z-buffer" title="Z-buffer" class="mw-redirect">Z-buffer</a>,
 to correctly merge movable objects such as doors and characters onto 
the background scene. While binary space partitioning provides a 
convenient way to store and retrieve spatial information about polygons 
in a scene, it does not solve the problem of <a href="http://en.m.wikipedia.org/wiki/Hidden_surface_determination" title="Hidden surface determination">visible surface determination</a>.</p>
</div><a id="anchor_1" href="#section_1" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_2"><button>Show</button><span id="Generation">Generation</span></h2><div class="content_block" id="content_2">
<p>The canonical use of a BSP tree is for rendering polygons (that are 
double-sided, that is, without back-face culling) with the painter's 
algorithm<sup id="cite_ref-fuchs80_1-2" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>.
 Such a tree is constructed from an unsorted list of all the polygons in
 a scene. The recursive algorithm for construction of a BSP tree from 
that list of polygons is<sup id="cite_ref-fuchs80_1-3" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>:</p>
<ol>
<li>Choose a polygon <i>P</i> from the list.</li>
<li>Make a node <i>N</i> in the BSP tree, and add <i>P</i> to the list of polygons at that node.</li>
<li>For each other polygon in the list:
<ol>
<li>If that polygon is wholly in front of the plane containing <i>P</i>, move that polygon to the list of nodes in front of <i>P</i>.</li>
<li>If that polygon is wholly behind the plane containing <i>P</i>, move that polygon to the list of nodes behind <i>P</i>.</li>
<li>If that polygon is intersected by the plane containing <i>P</i>, split it into two polygons and move them to the respective lists of polygons behind and in front of <i>P</i>.</li>
<li>If that polygon lies in the plane containing <i>P</i>, add it to the list of polygons at node <i>N</i>.</li>
</ol>
</li>
<li>Apply this algorithm to the list of polygons in front of <i>P</i>.</li>
<li>Apply this algorithm to the list of polygons behind <i>P</i>.</li>
</ol>
<p>The following diagram illustrates the use of this algorithm in 
converting a list of lines or polygons into a BSP tree. At each of the 
eight steps (i.-viii.), the algorithm above is applied to a list of 
lines, and one new node is added to the tree.</p>
<table class="wikitable">
<tbody><tr valign="top">
<td></td>
<td width="450pt">Start with a list of lines, (or in 3-D, polygons) 
making up the scene. In the tree diagrams, lists are denoted by rounded 
rectangles and nodes in the BSP tree by circles. In the spatial diagram 
of the lines, direction chosen to be the 'front' of a line is denoted by
 an arrow.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_1.svg" class="image"><img alt="Example of BSP tree construction - step 1.svg" src="Binary_space_partitioning_files/256px-Example_of_BSP_tree_construction_-_step_1.png" width="256" height="96"></a></td>
</tr>
<tr valign="top">
<td><b>i.</b></td>
<td>Following the steps of the algorithm above,
<ol>
<li>We choose a line, A, from the list and,...</li>
<li>...add it to a node.</li>
<li>We split the remaining lines in the list into those which lie in 
front of A (i.e. B2, C2, D2), and those which lie behind (B1, C1, D1).</li>
<li>We process first the lines lying in front of A (in steps ii–v),...</li>
<li>...followed by those behind it (in steps vi–vii).</li>
</ol>
</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_2.svg" class="image"><img alt="Example of BSP tree construction - step 2.svg" src="Binary_space_partitioning_files/282px-Example_of_BSP_tree_construction_-_step_2.png" width="282" height="96"></a></td>
</tr>
<tr valign="top">
<td><b>ii.</b></td>
<td>We now apply the algorithm to the list of lines in front of A 
(containing B2, C2, D2). We choose a line, B2, add it to a node and 
split the rest of the list into those lines that are in front of B2 
(D2), and those that are behind it (C2, D3).</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_3.svg" class="image"><img alt="Example of BSP tree construction - step 3.svg" src="Binary_space_partitioning_files/295px-Example_of_BSP_tree_construction_-_step_3.png" width="295" height="100"></a></td>
</tr>
<tr valign="top">
<td><b>iii.</b></td>
<td>Choose a line, D2, from the list of lines in front of B2. It is the 
only line in the list, so after adding it to a node, nothing further 
needs to be done.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_4.svg" class="image"><img alt="Example of BSP tree construction - step 4.svg" src="Binary_space_partitioning_files/295px-Example_of_BSP_tree_construction_-_step_4.png" width="295" height="94"></a></td>
</tr>
<tr valign="top">
<td><b>iv.</b></td>
<td>We are done with the lines in front of B2, so consider the lines 
behind B2 (C2 and D3). Choose one of these (C2), add it to a node, and 
put the other line in the list (D3) into the list of lines in front of 
C2.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_5.svg" class="image"><img alt="Example of BSP tree construction - step 5.svg" src="Binary_space_partitioning_files/297px-Example_of_BSP_tree_construction_-_step_5.png" width="297" height="109"></a></td>
</tr>
<tr valign="top">
<td><b>v.</b></td>
<td>Now look at the list of lines in front of C2. There is only one line (D3), so add this to a node and continue.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_6.svg" class="image"><img alt="Example of BSP tree construction - step 6.svg" src="Binary_space_partitioning_files/295px-Example_of_BSP_tree_construction_-_step_6.png" width="295" height="99"></a></td>
</tr>
<tr valign="top">
<td><b>vi.</b></td>
<td>We have now added all of the lines in front of A to the BSP tree, so
 we now start on the list of lines behind A. Choosing a line (B1) from 
this list, we add B1 to a node and split the remainder of the list into 
lines in front of B1 (i.e. D1), and lines behind B1 (i.e. C1).</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_7.svg" class="image"><img alt="Example of BSP tree construction - step 7.svg" src="Binary_space_partitioning_files/310px-Example_of_BSP_tree_construction_-_step_7.png" width="310" height="99"></a></td>
</tr>
<tr valign="top">
<td><b>vii.</b></td>
<td>Processing first the list of lines in front of B1, D1 is the only line in this list, so add this to a node and continue.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_8.svg" class="image"><img alt="Example of BSP tree construction - step 8.svg" src="Binary_space_partitioning_files/310px-Example_of_BSP_tree_construction_-_step_8.png" width="310" height="99"></a></td>
</tr>
<tr valign="top">
<td><b>viii.</b></td>
<td>Looking next at the list of lines behind B1, the only line in this 
list is C1, so add this to a node, and the BSP tree is complete.</td>
<td><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_construction_-_step_9.svg" class="image"><img alt="Example of BSP tree construction - step 9.svg" src="Binary_space_partitioning_files/308px-Example_of_BSP_tree_construction_-_step_9.png" width="308" height="99"></a></td>
</tr>
</tbody></table>
<p>The final number of polygons or lines in a tree will often be larger (sometimes much larger<sup id="cite_ref-fuchs80_1-4" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>)
 than that in the original list, since lines or polygons that cross the 
partitioning plane must be split into two. It is desirable that this 
increase is minimised, but also that the final tree remains reasonably <a href="http://en.m.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" title="Binary tree">balanced</a>.
 The choice of which polygon or line is used as a partitioning plane (in
 step 1 of the algorithm) is therefore important in creating an 
efficient BSP tree.</p>
</div><a id="anchor_2" href="#section_2" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_3"><button>Show</button><span id="Traversal">Traversal</span></h2><div class="content_block" id="content_3">
<p>A BSP tree is <a href="http://en.m.wikipedia.org/wiki/Tree_traversal" title="Tree traversal">traversed</a>
 in a linear time, in an order determined by the particular function of 
the tree. Again using the example of rendering double-sided polygons 
using the painter's algorithm, for a polygon <i>P</i> to be drawn correctly, all the polygons which are behind the plane in which <i>P</i> lies must be drawn first, then polygon <i>P</i> must be drawn, then finally the polygons in front of <i>P</i>
 must be drawn. If this drawing order is satisfied for all polygons in a
 scene, then the entire scene is rendered in the correct order. This 
procedure can be implemented by recursively traversing a BSP tree using 
the following algorithm<sup id="cite_ref-fuchs80_1-5" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>. From a given viewing location <i>V</i>, to render a BSP tree,</p>
<ol>
<li>If the current node is a leaf node, render the polygons at the current node.</li>
<li>Otherwise, if the viewing location <i>V</i> is in front of the current node:
<ol>
<li>Render the child BSP tree containing polygons behind the current node</li>
<li>Render the polygons at the current node</li>
<li>Render the child BSP tree containing polygons in front of the current node</li>
</ol>
</li>
<li>Otherwise, if the viewing location <i>V</i> is behind the current node:
<ol>
<li>Render the child BSP tree containing polygons in front of the current node</li>
<li>Render the polygons at the current node</li>
<li>Render the child BSP tree containing polygons behind the current node</li>
</ol>
</li>
<li>Otherwise, the viewing location <i>V</i> is must be exactly on the plane associated with the current node. Then:
<ol>
<li>Render the child BSP tree containing polygons in front of the current node</li>
<li>Render the child BSP tree containing polygons behind the current node</li>
</ol>
</li>
</ol>
<p><br></p>
<pre><a href="http://en.m.wikipedia.org/wiki/File:Example_of_BSP_tree_traversal.svg" class="image"><img alt="Example of BSP tree traversal.svg" src="Binary_space_partitioning_files/308px-Example_of_BSP_tree_traversal.png" width="308" height="99"></a>
</pre>
<p>Applying this algorithm recursively to the BSP tree generated above results in the following steps:</p>
<ul>
<li>The algorithm is first applied to the root node of the tree, node <i>A</i>. <i>V</i> is in front of node <i>A</i>, so we apply the algorithm first to the child BSP tree containing polygons behind <i>A</i>
<ul>
<li>This tree has root node <i>B1</i>. <i>V</i> is behind <i>B1</i> so first we apply the algorithm to the child BSP tree containing polygons in front of <i>B1</i>:
<ul>
<li>This tree is just the leaf node <i>D1</i>, so the polygon <i>D1</i> is rendered.</li>
</ul>
</li>
<li>We then render the polygon <i>B1</i>.</li>
<li>We then apply the algorithm to the child BSP tree containing polygons behind <i>B1</i>:
<ul>
<li>This tree is just the leaf node <i>C1</i>, so the polygon <i>C1</i> is rendered.</li>
</ul>
</li>
</ul>
</li>
<li>We then draw the polygons of <i>A</i>
</li>
<li>We then apply the algorithm to the child BSP tree containing polygons in front of <i>A</i>
<ul>
<li>This tree has root node <i>B2</i>. <i>V</i> is behind <i>B2</i> so first we apply the algorithm to the child BSP tree containing polygons in front of <i>B2</i>:
<ul>
<li>This tree is just the leaf node <i>D2</i>, so the polygon <i>D2</i> is rendered.</li>
</ul>
</li>
<li>We then render the polygon <i>B2</i>.</li>
<li>We then apply the algorithm to the child BSP tree containing polygons behind <i>B2</i>:
<ul>
<li>This tree has root node <i>C2</i>. <i>V</i> is in front of <i>C2</i> so first we would apply the algorithm to the child BSP tree containing polygons behind <i>C2</i>. There is no such tree, however, so we continue.</li>
<li>We render the polygon <i>C2</i>.</li>
<li>We apply the algorithm to the child BSP tree containing polygons in front of <i>C2</i>
<ul>
<li>This tree is just the leaf node <i>D3</i>, so the polygon <i>D3</i> is rendered.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The tree is traversed in linear time and renders the polygons in a far-to-near ordering (<i>D1</i>, <i>B1</i>, <i>C1</i>, <i>A</i>, <i>D2</i>, <i>B2</i>, <i>C2</i>, <i>D3</i>) suitable for the painter's algorithm.</p>
</div><a id="anchor_3" href="#section_3" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_4"><button>Show</button><span id="Timeline">Timeline</span></h2><div class="content_block" id="content_4">
<ul>
<li>1969 Schumacker et al.<sup id="cite_ref-schumacker69_0-1" class="reference"><a href="#cite_note-schumacker69-0"><span>[</span>1<span>]</span></a></sup>
 published a report that described how carefully positioned planes in a 
virtual environment could be used to accelerate polygon ordering. The 
technique made use of depth coherence, which states that a polygon on 
the far side of the plane cannot, in any way, obstruct a closer polygon.
 This was used in flight simulators made by GE as well as Evans and 
Sutherland. However, creation of the polygonal data organization was 
performed manually by scene designer.</li>
</ul>
<ul>
<li>1980 <a href="http://en.m.wikipedia.org/wiki/Henry_Fuchs" title="Henry Fuchs">Fuchs</a> et al.<sup id="cite_ref-fuchs80_1-6" class="reference"><a href="#cite_note-fuchs80-1"><span>[</span>2<span>]</span></a></sup>
 extended Schumacker’s idea to the representation of 3D objects in a 
virtual environment by using planes that lie coincident with polygons to
 recursively partition the 3D space. This provided a fully automated and
 algorithmic generation of a hierarchical polygonal data structure known
 as a Binary Space Partitioning Tree (BSP Tree). The process took place 
as an off-line preprocessing step that was performed once per 
environment/object. At run-time, the view-dependent visibility ordering 
was generated by traversing the tree.</li>
</ul>
<ul>
<li>1981 Naylor's Ph.D thesis containing a full development of both BSP 
trees and a graph-theoretic approach using strongly connected components
 for pre-computing visibility, as well as the connection between the two
 methods. BSP trees as a dimension independent spatial search structure 
was emphasized, with applications to visible surface determination. The 
thesis also included the first empirical data demonstrating that the 
size of the tree and the number of new polygons was reasonable (using a 
model of the Space Shuttle).</li>
</ul>
<ul>
<li>1983 <a href="http://en.m.wikipedia.org/wiki/Henry_Fuchs" title="Henry Fuchs">Fuchs</a>
 et al. describe a micro-code implementation of the BSP tree algorithm 
on an Ikonas frame buffer system. This was the first demonstration of 
real-time visible surface determination using BSP trees.</li>
</ul>
<ul>
<li>1987 Thibault and Naylor<sup id="cite_ref-thibault87_2-1" class="reference"><a href="#cite_note-thibault87-2"><span>[</span>3<span>]</span></a></sup>
 described how arbitrary polyhedra may be represented using a BSP tree 
as opposed to the traditional b-rep (boundary representation). This 
provided a solid representation vs. a surface based-representation. Set 
operations on polyhedra were described using a tool, enabling 
Constructive Solid Geometry (CSG) in real-time. This was the fore runner
 of BSP level design using <a href="http://en.m.wikipedia.org/wiki/Brush_%28video_game%29" title="Brush (video game)">brushes</a>, introduced in the Quake editor and picked up in the Unreal Editor.</li>
</ul>
<ul>
<li>1990 Naylor, Amanatides, and Thibault provide an algorithm for 
merging two bsp trees to form a new bsp tree from the two original 
trees. This provides many benefits including: combining moving objects 
represented by BSP trees with a static environment (also represented by a
 BSP tree), very efficient CSG operations on polyhedra, exact collisions
 detection in O(log n * log n), and proper ordering of transparent 
surfaces contained in two interpenetrating objects (has been used for an
 x-ray vision effect).</li>
</ul>
<ul>
<li>1990 <a href="http://en.m.wikipedia.org/wiki/Seth_J._Teller" title="Seth J. Teller">Teller</a>
 and Séquin proposed the offline generation of potentially visible sets 
to accelerate visible surface determination in orthogonal 2D 
environments.</li>
</ul>
<ul>
<li>1991 Gordon and Chen [CHEN91] described an efficient method of 
performing front-to-back rendering from a BSP tree, rather than the 
traditional back-to-front approach. They utilised a special data 
structure to record, efficiently, parts of the screen that have been 
drawn, and those yet to be rendered. This algorithm, together with the 
description of BSP Trees in the standard computer graphics textbook of 
the day (Foley, Van Dam, Feiner and Hughes) was used by <a href="http://en.m.wikipedia.org/wiki/John_D._Carmack" title="John D. Carmack">John Carmack</a> in the making of <i><a href="http://en.m.wikipedia.org/wiki/Doom_%28video_game%29" title="Doom (video game)">Doom</a></i>.</li>
</ul>
<ul>
<li>1992 <a href="http://en.m.wikipedia.org/wiki/Seth_J._Teller" title="Seth J. Teller">Teller</a>’s
 PhD thesis described the efficient generation of potentially visible 
sets as a pre-processing step to acceleration real-time visible surface 
determination in arbitrary 3D polygonal environments. This was used in <i><a href="http://en.m.wikipedia.org/wiki/Quake_%28video_game%29" title="Quake (video game)">Quake</a></i> and contributed significantly to that game's performance.</li>
</ul>
<ul>
<li>1993 Naylor answers the question of what characterizes a good BSP 
tree. He used expected case models (rather than worst case analysis) to 
mathematically measure the expected cost of searching a tree and used 
this measure to build good BSP trees. Intuitively, the tree represents 
an object in a multi-resolution fashion (more exactly, as a tree of 
approximations). Parallels with Huffman codes and probabilistic binary 
search trees are drawn.</li>
</ul>
</div><a id="anchor_4" href="#section_4" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_5"><button>Show</button><span id="References">References</span></h2><div class="content_block" id="content_5">
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-schumacker69-0">
<span class="mw-cite-backlink">^ <a href="#cite_ref-schumacker69_0-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-schumacker69_0-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation report">Schumacker,
 Robert A.&nbsp;;; Brand, Brigitta; Gilliland, Maurice G.; Sharp, Werner
 H (1969). ﻿Study for Applying Computer-Generated Images to Visual 
Simulation﻿ (report). U.S. Air Force Human Resources Laboratory. pp. 
142. AFHRL-TR-69-14.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=%27%27%26%23xFEFF%3BStudy+for+Applying+Computer-Generated+Images+to+Visual+Simulation%26%23xFEFF%3B%27%27&amp;rft.aulast=Schumacker%2C+Robert+A.+%3B&amp;rft.au=Schumacker%2C+Robert+A.+%3B&amp;rft.date=1969&amp;rft.pages=pp.+142&amp;rft.pub=U.S.+Air+Force+Human+Resources+Laboratory&amp;rfr_id=info:sid/en.wikipedia.org:Binary_space_partitioning"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-fuchs80-1">
<span class="mw-cite-backlink">^ <a href="#cite_ref-fuchs80_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-fuchs80_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-fuchs80_1-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-fuchs80_1-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-fuchs80_1-4"><sup><i><b>e</b></i></sup></a> <a href="#cite_ref-fuchs80_1-5"><sup><i><b>f</b></i></sup></a> <a href="#cite_ref-fuchs80_1-6"><sup><i><b>g</b></i></sup></a></span> <span class="reference-text"><span class="citation book">Fuchs, Henry; Kedem, Zvi. M; Naylor, Bruce F. (1980). "On Visible Surface Generation by A Priori Tree Structures". <i>SIGGRAPH '80 Proceedings of the 7th annual conference on Computer graphics and interactive techniques</i>. ACM, New York. p.&nbsp;124-133. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F965105.807481">10.1145/965105.807481</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=On+Visible+Surface+Generation+by+A+Priori+Tree+Structures&amp;rft.atitle=SIGGRAPH+%2780+Proceedings+of+the+7th+annual+conference+on+Computer+graphics+and+interactive+techniques&amp;rft.aulast=Fuchs&amp;rft.aufirst=Henry&amp;rft.au=Fuchs%2C%26%2332%3BHenry&amp;rft.au=Kedem%2C%26%2332%3BZvi.+M&amp;rft.au=Naylor%2C%26%2332%3BBruce+F.&amp;rft.date=1980&amp;rft.pages=p.%26nbsp%3B124-133&amp;rft.pub=ACM%2C+New+York&amp;rft_id=info:doi/10.1145%2F965105.807481&amp;rfr_id=info:sid/en.wikipedia.org:Binary_space_partitioning"><span style="display: none;">&nbsp;</span></span></span>
</li>
<li id="cite_note-thibault87-2">
<span class="mw-cite-backlink">^ <a href="#cite_ref-thibault87_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-thibault87_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation book">Thibault, William C.; Naylor, Bruce F. (1987). "Set operations on polyhedra using binary space partitioning trees". <i>SIGGRAPH '87 Proceedings of the 14th annual conference on Computer graphics and interactive techniques</i>. ACM, New York. p.&nbsp;153-162. <a href="http://en.m.wikipedia.org/wiki/Digital_object_identifier" title="Digital object identifier">DOI</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F37402.37421">10.1145/37402.37421</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Set+operations+on+polyhedra+using+binary+space+partitioning+trees&amp;rft.atitle=SIGGRAPH+%2787+Proceedings+of+the+14th+annual+conference+on+Computer+graphics+and+interactive+techniques&amp;rft.aulast=Thibault&amp;rft.aufirst=William+C.&amp;rft.au=Thibault%2C%26%2332%3BWilliam+C.&amp;rft.au=Naylor%2C%26%2332%3BBruce+F.&amp;rft.date=1987&amp;rft.pages=p.%26nbsp%3B153-162&amp;rft.pub=ACM%2C+New+York&amp;rft_id=info:doi/10.1145%2F37402.37421&amp;rfr_id=info:sid/en.wikipedia.org:Binary_space_partitioning"><span style="display: none;">&nbsp;</span></span></span>
</li>
</ol>
</div>
</div><a id="anchor_5" href="#section_5" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_6"><button>Show</button><span id="Additional_references">Additional references</span></h2><div class="content_block" id="content_6">
<ul>
<li>[NAYLOR90] B. Naylor, J. Amanatides, and W. Thibualt, "Merging BSP 
Trees Yields Polyhedral Set Operations", Computer Graphics (Siggraph 
'90), 24(3), 1990.</li>
<li>[NAYLOR93] B. Naylor, "Constructing Good Partitioning Trees", Graphics Interface (annual Canadian CG conference) May, 1993.</li>
<li>[CHEN91] S. Chen and D. Gordon. <a rel="nofollow" class="external text" href="http://www.rothschild.haifa.ac.il/%7Egordon/ftb-bsp.pdf">“Front-to-Back Display of BSP Trees.”</a> IEEE Computer Graphics &amp; Algorithms, pp 79–85. September 1991.</li>
<li>[RADHA91] H. Radha, R. Leoonardi, M. Vetterli, and B. Naylor “Binary
 Space Partitioning Tree Representation of Images,” Journal of Visual 
Communications and Image Processing 1991, vol. 2(3).</li>
<li>[RADHA93] H. Radha, "Efficient Image Representation using Binary 
Space Partitioning Trees.", Ph.D. Thesis, Columbia University, 1993.</li>
<li>[RADHA96] H. Radha, M. Vetterli, and R. Leoonardi, “Image 
Compression Using Binary Space Partitioning Trees,” IEEE Transactions on
 Image Processing, vol. 5, No.12, December 1996, pp.&nbsp;1610–1624.</li>
<li>[WINTER99] AN INVESTIGATION INTO REAL-TIME 3D POLYGON RENDERING 
USING BSP TREES. Andrew Steven Winter. April 1999. available online</li>
<li>
<span class="citation book"><span class="new" title="Mark de Berg (page does not exist)">Mark de Berg</span>, <span class="new" title="Marc van Kreveld (page does not exist)">Marc van Kreveld</span>, <a href="http://en.m.wikipedia.org/wiki/Mark_Overmars" title="Mark Overmars">Mark Overmars</a>, and <span class="new" title="Otfried Schwarzkopf (page does not exist)">Otfried Schwarzkopf</span> (2000). <i>Computational Geometry</i> (2nd revised edition ed.). <a href="http://en.m.wikipedia.org/wiki/Springer-Verlag" title="Springer-Verlag" class="mw-redirect">Springer-Verlag</a>. <a href="http://en.m.wikipedia.org/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/3-540-65620-0" title="Special:BookSources/3-540-65620-0">3-540-65620-0</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computational+Geometry&amp;rft.aulast=%5B%5BMark+de+Berg%5D%5D%2C+%5B%5BMarc+van+Kreveld%5D%5D%2C+%5B%5BMark+Overmars%5D%5D%2C+and+%5B%5BOtfried+Schwarzkopf%5D%5D&amp;rft.au=%5B%5BMark+de+Berg%5D%5D%2C+%5B%5BMarc+van+Kreveld%5D%5D%2C+%5B%5BMark+Overmars%5D%5D%2C+and+%5B%5BOtfried+Schwarzkopf%5D%5D&amp;rft.date=2000&amp;rft.edition=2nd+revised+edition&amp;rft.pub=%5B%5BSpringer-Verlag%5D%5D&amp;rft.isbn=3-540-65620-0&amp;rfr_id=info:sid/en.wikipedia.org:Binary_space_partitioning"><span style="display: none;">&nbsp;</span></span> Section 12: Binary Space Partitions: pp.&nbsp;251–265. Describes a randomized Painter's Algorithm.</li>
<li>Christer Ericson: <i>Real-Time <a href="http://en.m.wikipedia.org/wiki/Collision_detection" title="Collision detection">Collision Detection</a> (The Morgan Kaufmann Series in Interactive 3-D Technology)</i>. Verlag <i>Morgan Kaufmann</i>, S. 349-382, Jahr 2005, <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/1558607323" class="internal mw-magiclink-isbn">ISBN 1-55860-732-3</a>
</li>
</ul>
</div><a id="anchor_6" href="#section_6" class="section_anchors back_to_top">↑Jump back a section</a></div><div class="section"><h2 class="section_heading" id="section_7"><button>Show</button><span id="External_links">External links</span></h2><div class="content_block" id="content_7">
<ul>
<li><a rel="nofollow" class="external text" href="http://www.cs.wpi.edu/%7Ematt/courses/cs563/talks/bsp/bsp.html">BSP trees presentation</a></li>
<li><a rel="nofollow" class="external text" href="http://web.archive.org/web/20110719195212/http://www.cc.gatech.edu/classes/AY2004/cs4451a_fall/bsp.pdf">Another BSP trees presentation</a></li>
<li><a rel="nofollow" class="external text" href="http://symbolcraft.com/graphics/bsp/">A Java applet which demonstrates the process of tree generation</a></li>
<li><a rel="nofollow" class="external text" href="http://archive.gamedev.net/archive/reference/programming/features/bsptree/bsp.pdf">A Master Thesis about BSP generating</a></li>
<li><a rel="nofollow" class="external text" href="http://www.devmaster.net/articles/bsp-trees/">BSP Trees: Theory and Implementation</a></li>
<li><a rel="nofollow" class="external text" href="http://www.euclideanspace.com/threed/solidmodel/spatialdecomposition/bsp/index.htm">BSP in 3D space</a></li>
</ul>
<table class="navbox" style="border-spacing: 0pt;" cellspacing="0"><tbody><tr>
<td style="padding: 2px;">
<table class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing: 0pt; background: none repeat scroll 0% 0% transparent; color: inherit;" cellspacing="0">
<tbody><tr>
<th scope="col" style="" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:CS_trees" title="Template:CS trees"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:CS_trees" title="Template talk:CS trees"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:CS_trees&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;">
<a href="http://en.m.wikipedia.org/wiki/Tree_%28data_structure%29" title="Tree (data structure)">Trees</a> in <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>
</div>
</th>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Binary_tree" title="Binary tree">Binary trees</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Binary_search_tree" title="Binary search tree">Binary search tree (BST)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cartesian_tree" title="Cartesian tree">Cartesian tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Top_tree" title="Top tree">Top tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/T-tree" title="T-tree">T-tree</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">Self-balancing binary search trees</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/AA_tree" title="AA tree">AA tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/AVL_tree" title="AVL tree">AVL tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/LLRB_tree" title="LLRB tree" class="mw-redirect">LLRB tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Red%E2%80%93black_tree" title="Red–black tree">Red–black tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Scapegoat_tree" title="Scapegoat tree">Scapegoat tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Splay_tree" title="Splay tree">Splay tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Treap" title="Treap">Treap</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/B-tree" title="B-tree">B-trees</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/B%2B_tree" title="B+ tree">B+ tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/B*-tree" title="B*-tree" class="mw-redirect">B*-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bx-tree" title="Bx-tree">B<small><sup>x</sup></small>-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/UB-tree" title="UB-tree">UB-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/2-3_tree" title="2-3 tree">2-3 tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/2-3-4_tree" title="2-3-4 tree">2-3-4 tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/%28a,b%29-tree" title="(a,b)-tree">(a,b)-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Dancing_tree" title="Dancing tree">Dancing tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Htree" title="Htree">Htree</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=""><a href="http://en.m.wikipedia.org/wiki/Trie" title="Trie">Tries</a></th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Suffix_tree" title="Suffix tree">Suffix tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Radix_tree" title="Radix tree">Radix tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Ternary_search_tree" title="Ternary search tree">Ternary search tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/X-fast_trie" title="X-fast trie">X-fast trie</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Y-fast_trie" title="Y-fast trie">Y-fast trie</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">
<strong class="selflink">Binary space partitioning (BSP)</strong> trees</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Quadtree" title="Quadtree">Quadtree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Octree" title="Octree">Octree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/K-d_tree" title="K-d tree"><i>k</i>-d tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Implicit_k-d_tree" title="Implicit k-d tree">Implicit <i>k</i>-d tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Vp-tree" title="Vp-tree">vp-tree</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Non-binary trees</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Exponential_tree" title="Exponential tree">Exponential tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Fusion_tree" title="Fusion tree">Fusion tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Interval_tree" title="Interval tree">Interval tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/PQ_tree" title="PQ tree">PQ tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Range_tree" title="Range tree">Range tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/SPQR_tree" title="SPQR tree">SPQR tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Van_Emde_Boas_tree" title="Van Emde Boas tree">Van Emde Boas tree</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">
<a href="http://en.m.wikipedia.org/wiki/Spatial_index" title="Spatial index" class="mw-redirect">Spatial</a> data partitioning trees</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/R-tree" title="R-tree">R-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/R%2B_tree" title="R+ tree">R+ tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/R*_tree" title="R* tree">R* tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/X-tree" title="X-tree">X-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/M-tree" title="M-tree">M-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Segment_tree" title="Segment tree">Segment tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert R-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Priority_R-tree" title="Priority R-tree">Priority R-tree</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height: 2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style="">Other trees</th>
<td style="text-align: left; border-left-width: 2px; border-left-style: solid; width: 100%; padding: 0px;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Heap_%28data_structure%29" title="Heap (data structure)">Heap</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Hash_tree" title="Hash tree">Hash tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Finger_tree" title="Finger tree">Finger tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Metric_tree" title="Metric tree">Metric tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cover_tree" title="Cover tree">Cover tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/BK-tree" title="BK-tree">BK-tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Doubly_chained_tree" title="Doubly chained tree">Doubly chained tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/IDistance" title="IDistance">iDistance</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Link-cut_tree" title="Link-cut tree" class="mw-redirect">Link-cut tree</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Fenwick_tree" title="Fenwick tree">Fenwick tree</a></li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</td>
</tr></tbody></table>

</div>
</div>		</div>
	</div>
			<div id="footer">
			<h2 class="section_heading" id="section_footer"><button>Show</button>
		<div class="license">Wikipedia ™</div>		<span class="toggleCopyright">
			<span class="more">more</span><span class="less">less</span>
		</span>
	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Binary_space_partitioning&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li>
				<span class="left"><a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span><span class="right">Images ON / <a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions/DisableImages&amp;returnto=Binary+space+partitioning&amp;mobiletoken=5c89e355d2af09275b3b2ed3653e1683" title="Special:MobileOptions/DisableImages" id="imagetoggle">OFF</a></span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Binary_space_partitioning&amp;action=history">contributors</a> like you<br>
				Content available under <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>			</li>
		</ul>
		<ul class="links">
			<li>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Binary+space+partitioning&amp;feedbacksource=MobileFrontend">Contact</a>
			</li><li>
			<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="http://en.m.wikipedia.org/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div>
	</div>
				<!--[if gt IE 7]><!-->
		<script type="text/javascript">mw={loader:{state:function(){}}};</script>		<script src="Binary_space_partitioning_files/load.php" type="text/javascript"></script>
<script src="Binary_space_partitioning_files/load_002.php" type="text/javascript"></script>	<script type="text/javascript">
	window.onload = function() {
		mw.mobileFrontend.init();
	};
	</script>
	<!----><!--[endif]---->
	
	<div style="display: none;" id="mf-references"><div></div><button>close</button></div></body></html>